---
layout: docs
category: 운영체제
title: 리눅스
slug: ko.Linux
icon: icon-linux.svg
order: 0x64
---
# 소개
[리눅스](https://ko.wikipedia.org/wiki/리눅스_커널)(Linux)는 운영체제 커널이며, 이를 사용하는 리눅스 배포판 운영체제가 대표적으로 [우분투](https://ko.wikipedia.org/wiki/우분투_(운영_체제))(Ubuntu)/[데비안](https://ko.wikipedia.org/wiki/데비안)(Debian), [페도라](https://ko.wikipedia.org/wiki/페도라_리눅스)(Fedora), [안드로이드](https://ko.wikipedia.org/wiki/안드로이드_(운영_체제))(Android) 등이 있다. 배포판이 아닌 "순수" 리눅스를 설치하여 사용해보겠다는 생각을 가질 수 있겠으나, 커널 자체는 하드웨어와 소프트웨어의 징검다리 역할을 할 뿐이며 사용자 측에서 사용할 수 있는 소프트웨어가 없으므로 부팅 이후에 아무것도 실행되지 않는다. 본 장은 리눅스를 컴퓨터 과학 관점에서 아키텍처 및 드라이버 등을 기술적으로 다루기에 앞서 운영체제에 대하여 기본적인 내용을 소개한다.

> 본 문서는 [*Debian 11 "Bullseye"*](https://www.debian.org/releases/bullseye/) 운영체제를 예시로 설명한다.

## 운영체제
[운영체제](https://ko.wikipedia.org/wiki/운영_체제)(operating system; OS)는 [어플리케이션](https://ko.wikipedia.org/wiki/응용_소프트웨어)(application)과 같은 타 소프트웨어를 사용할 수 있도록 플랫폼을 제공하는 소프트웨어로 다음 세 가지의 목적을 갖는다:

1. **하드웨어 상호작용**
    : *CPU, RAM, 입출력 장치 등의 컴퓨터에서 시스템을 구동하기 위해 필요한 외부적 요소들과 상호작용한다.*

2. **소프트웨어 리소스 관리**
    : *컴퓨터 하드웨어들로부터 안정적인 시스템 성능을 유지할 수 있도록 소프트웨어 면에서 관리한다.*

3. **사용자에게 서비스를 제공**
    : *관리된 리소스를 기반으로 사용자가 사용할 수 있는 어플리케이션 등의 서비스를 제공한다.*

## 커널
[커널](https://ko.wikipedia.org/wiki/커널_(컴퓨팅))(kernel)은 운영체제의 핵심 부분으로 시스템 전체의 완전한 통제권을 쥐고 있으며, 또한 하드웨어와 소프트웨어 간의 상호작용을 가능케 한다. 상당히 민감하고 중요한 역할을 수행하기 때문에 사용자나 어플리케이션 [프로세스](https://ko.wikipedia.org/wiki/프로세스)(process)가 커널에 함부로 접근하지 못하게 보호되어 있다. 간략하게 커널에서 수행하는 일부 작업들은 다음과 같이 나열할 수 있다.

* **프로세스 관리(Resource management)**
    : *프로세스의 생성 및 제거, CPU에 프로세스를 할당하는 [스케쥴링](https://ko.wikipedia.org/wiki/스케줄링_(컴퓨팅))(scheduling), 그리고 프로세스 간 통신을 담당한다.*

* **메모리 관리(Memory management)**
    : *각 프로세스마다 주기억장치에 제한된 용량을 갖는 [가상 주소 공간](https://ko.wikipedia.org/wiki/가상_주소_공간)(virtual address space)을 할당하므로써 안전한 메모리 접근을 보장한다.*

* **장치 관리(Device management)**
    : *프로세스가 시스템에 연결된 장치를 사용할 수 있도록 연결된 장치 목록 관리하며 [디바이스 드라이버](https://ko.wikipedia.org/wiki/장치_드라이버)(device driver)를 통해 장치와 상호작용한다.*

위에서 나열한 커널에서 제공하는 서비스들은 [시스템 호출](https://ko.wikipedia.org/wiki/시스템_호출)(System call)이란 사용자와 커널 간의 인터페이스를 통해 요청할 수 있다. 운영체제가 부팅되는 과정에서 BIOS에 의해 (부트로더 다음으로) 커널이 가장 먼저 [RAM](https://ko.wikipedia.org/wiki/랜덤_액세스_메모리) [주기억장치](https://ko.wikipedia.org/wiki/주기억장치)에 로드되어 시스템 초기화를 위한 하드웨어 처리를 진행한다. 부팅하여 로드된 커널은 시스템이 종료될 때까지 RAM에 남아있는다.

> 여기서 [BIOS](https://ko.wikipedia.org/wiki/바이오스)란, 컴퓨터 [마더보드](https://ko.wikipedia.org/wiki/메인보드)에 들어있는 [펌웨어](https://ko.wikipedia.org/wiki/펌웨어)(firmware)로 절대 운영체제의 일부가 아니다. 펌웨어는 매우 단순한 프로세스이므로 마더보드에 탑재되어 있는 [EEPROM](https://ko.wikipedia.org/wiki/EEPROM) 혹은 [플래시 메모리](https://ko.wikipedia.org/wiki/플래시_메모리)에서 코드 저장 및 실행이 모두 이루어진다. 펌웨어가 별도의 RAM이 필요한 경우는 방대한 양의 변수를 저장하는 등 휘발성 목적에 그친다.

![커널 설계에 따른 운영체제 구조<sub><i>출처: <a href="https://commons.wikimedia.org/wiki/File:OS-structure2.svg">위키미디어</a></i></sub>](/images/docs/shared/os_kernel_designs.png)

개발자가 지향하는 운영체제에 따라 커널 설계가 크게 두 가지로 나뉘어진다: 모놀리식 그리고 마이크로커널이 있다.

### 모놀리식 커널
[모놀리식 커널](https://ko.wikipedia.org/wiki/모놀리식_커널)(monolithic kernel)은 모든 커널 서비스가 단일 프로그램으로 빌드되어 커널 공간에서 처리하는 설계이다. 여기서 [커널 공간](https://ko.wikipedia.org/wiki/사용자_공간)(kernel space)이란, 사용자 측에서 함부로 접근할 수 없는 보호된 메모리 주소 공간으로 커널 서비스에 종사하는 [커널 모드](#보호-링)(kernel mode) 프로세스들은 하나의 주기억장치 메모리 공간을 공유하여 사용한다. 주의해야 할 점은 커널 공간(메모리 영역)은 커널(프로그램) 자체를 가리키는 것이 아니다. 그 반대의 개념으로는 사용자 공간이 존재하나, 이는 다음 커널 설계에서 소개할 예정이다.

모놀리식 커널은 설계 구조가 매우 간단하여 관리가 매우 편하고, 단일 프로그램에서 모든 작업을 수행하니 성능 속도가 매우 빠르다. 그러나 커널 서비스 혹은 심지어 드라이버에서 문제가 발생하면 "공유된 메모리 공간"에 의해 타 커널 서비스 및 드라이버에도 영향을 미쳐 운영체제 전체가 충돌할 수 있는 위험이 항상 존재한다. 특히 모듈성(modularity)과 같은 현대 모놀리식 커널에서 볼 수 있는 여러 기능들이 추가되어 방대해진 크기는 코드 관리를 매우 어렵게 한다.

그럼에도 불구하고 모놀리식 커널은 운영체제 런타임 도중에도 필요하다면 언제든지 불러올 수 있는 [커널 모듈](#커널-모듈)(kernel module)을 지원하고 커스터마이징이 쉽다는 장점을 갖는다. 이러한 이유로 대표적인 모놀리식 커널 중 하나인 리눅스는 임베디드 시스템에 많이 활용된다.

### 마이크로커널
[마이크로커널](https://ko.wikipedia.org/wiki/마이크로커널)(microkernel)은 운영체제 구동에서 매우 필수적인 커널 서비스만을 제외한 나머지를 [사용자 공간](https://ko.wikipedia.org/wiki/사용자_공간)(user space)에서 처리하는 설계이다. 여기서 사용자 공간이란, 사용자 측에서 쉽게 접근할 수 있는 영역으로 거의 모든 응용 프로그램들은 모두 [사용자 모드](#보호-링)(user mode)에서 실행된다. 각 사용자 모드 프로세스는 커널로부터 자신만의 독립적 가상 주소 공간을 할당받으므로, 한 프로세스에서 충돌이 발생하여도 타 프로세스는 아무런 영향을 받지 않는다. 그리고 직접적 하드웨어 상호작용과 같은 민감한 코드로부터 접근할 수 없다는 점에서 커널 모드와 상당히 대조적인 성질을 갖는다.

마이크로커널에서 언급한 매우 필수적인 기능들은 다음과 같다:

* 기초적 [프로세스 간 통신](https://ko.wikipedia.org/wiki/프로세스_간_통신)(inter-process communication; IPC)
* 기초적 스케쥴러 혹은 스케줄링 요소
* 기초적 메모리 핸들링
* 기초적 입출력 요소

그 외의 고급 커널 서비스와 같은 나머지는 사용자 모드로 노출되어 있는데, 마이크로커널에서는 이들을 서비스를 제공하는 *서버(server)*라고 칭한다. 단순히 서버를 실행하는 것으로 운영체제에 해당 서비스를 동작시키는 모듈성이 반영된다.

마이크로커널의 설계는 모놀리식 커널이 마주하는 단점들을 해결하고자 고안되었다: (1) 방대한 크기로부터 어려워진 커널 코드 관리를 필요한 기능들만으로 축소시켜 수월하게 하며 (2) 서버 혹은 드라이버로부터 문제가 발생하여도 커널에는 영향이 없기 때문에 문제가 발생한 서비스만 재실행하는 것으로 시스템 전체에 치명적 영향이 발생하는 것을 막을 수 있다. 이러한 설계 덕분에 기존 모놀리식 커널에서는 서비스 업데이트를 하려면 커널을 재부팅해야 하였으나, 마이크로커널에서는 해당 서비스를 제공하는 서버만 패치를 적용하면 되어 개발 시간 단축에 기여한다.

이론적으로는 마이크로커널 자체만으로는 크기가 매우 작은 프로그램이지만, 커널 서비스와 관련된 보조 코드까지 모두 합하면 모놀리식 커널보다 용량이 크다. 게다가 운영체제를 사용자와 커널 공간으로 영역을 나눈 설계는 하드웨어 접근성 등에서 시스템 효율에 손실을 있다는 지적이 있다. 그러나 마이크로커널의 가장 큰 문제점은 별개의 소프트웨어인 서버 간 통신에서 발생하는 시스템 성능 저하 그리고 복잡한 프로세스 관리이다.

### 하이브리드 커널
[하이브리드 커널](https://ko.wikipedia.org/wiki/하이브리드_커널)(hybrid kernel)은 기존 마이크로커널에서 일부 모놀리식 커널의 성질을 적용한 복합적 커널 설계이다. 마이크로커널과 달리 매우 기초적인 필수 서비스 이외에도 성능 향상을 위해 일부 서버를 커널 모드에서 처리하는 모놀리식 커널의 성질을 보여준다. 즉, 하이브리드 커널은 모놀리식 커널의 "빠른 속도와 심플한 설계"와 마이크로커널의 "모듈성과 안전성"을 모두 취하려는 접근에서 비롯된 설계이다. 마이크로소프트의 [윈도우 NT](/docs/ko.Windows)와 애플의 macOS 등의 대부분 상업용 운영체제에서 사용하고 있다.

## 커널 모듈
[커널 모듈](https://ko.wikipedia.org/wiki/적재_가능_커널_모듈)(kernel module)은 운영체제 런타임 도중에 커널에 로드되어 기능성을 확장시키는 객체 파일이다. 모듈(module)이란 명칭에서 알 수 있듯이, 커널 모듈은 언제든지 커널에 삽입 및 제거될 수 있으므로 사용하지 않는 리소스에 의한 메모리 소모를 줄일 수 있다. 새로운 기능성을 시스템 리부트 필요없이 바로 커널에 적용할 수 있어 개발에 편의성을 제공하여 [디바이스 드라이버](#리눅스-드라이버)(device driver)를 커널 모듈로 흔히 제작한다.

필자는 프로그래밍 관점에서 커널 모듈을 "리소스 관리에 신경써야 하는 [객체](/docs/ko.Cpp#클래스)(object)"로 간주한다: 필요할 때마다 모듈의 기능성을 호출하는 점은 객체의 메소드와 부합하기 때문이다. 또한 모듈을 커널에 삽입 및 제거할 때 함수를 호출하는 것이 마치 객체의 [생성자](/docs/ko.Cpp#생성자)(constructor)와 [소멸자](/docs/ko.Cpp#소멸자)(destructor) 메소드를 연상시킨다. 단, 모듈을 커널로부터 제거하는 과정에서 초기화 때 할당받은 리소스들을 개발자가 직접 해제해야 하는 번거로움이 있다. 이를 간과하면 시스템 종료때까지 커널 메모리에 잔여하여 [메모리 누수](/docs/ko.Memory#메모리-덤프)(memory leak)의 원인이 된다.

### 모듈 병행처리
멀티태스킹이 가능한 운영체제는 여러 프로세스를 한꺼번에 실행할 수 있는데, 이들은 동시에 하나의 커널 모듈을 접근하려 할 수 있다. 특히 [대칭형 멀티프로세서](/docs/ko.Process#다중-프로세서)(symmetric multiprocessor; SMP) 시스템에서는 커널 모듈이 하나 이상의 CPU 프로세서에서 병행될 수 있으며, 심지어 단일 프로세서 시스템에서도 [선점형 스케줄링](/docs/ko.Process#프로세스-스케줄링)(preemptive scheduling)에 의한 빈번한 문맥 교환으로 인해 멀티프로세서 시스템과 동일한 병행처리 문제가 발생할 수 있다. 그러므로 커널 모듈을 설계는 매우 까다로우며 병행처리를 고려하여 신중한 접근이 요구된다.

## 보호 링
[보호 링](https://ko.wikipedia.org/wiki/보호_링)(protection ring)은 데이터와 기능을 결함과 위협적인 행위로부터 보호하는 메커니즘이다.

![x86 아키텍처의 보호 링<sub><i>출처: <a href="https://commons.wikimedia.org/wiki/File:Priv_rings.svg">위키미디어</a></i></sub>](/images/docs/shared/cpu_protection_ring.svg)

보호 링은 시스템 운영체제의 [권한](https://en.wikipedia.org/wiki/Privilege_(computing))(privilege) 구조를 이루는 계층으로써, CPU 아키텍처가 하드웨어적으로 어떤 [모드](https://en.wikipedia.org/wiki/CPU_modes)에 있는지에 따라 권한에 의해 제한된 일부 명령어들 활용 가능여부가 결정된다. 해당 명령어들은 CPU 및 메모리와 같은 하드웨어를 직접적으로 상호작용하므로 자칫 잘못하면 시스템에 치명적인 문제를 야기한다. 일반적으로 보호 링은 최소 두 계층, 다시 말해 두 개의 CPU 모드를 사용하는데 이들을 커널 그리고 사용자 모드라고 부른다.

* **[커널 모드](https://ko.wikipedia.org/wiki/보호_링#수퍼바이저_모드)(kernel mode)**
    : *일명 수퍼바이저 모드(supervisor mode)는 시스템에 민감한 영향을 줄 수 있는 입출력 동작이나 메모리 접근에 아무런 제약을 받지 않고 아키텍처의 모든 작업을 수행할 수 있다. 커널 모드의 작업은 메모리 주소 공간 중 커널 공간(kernel space)에서 이루어진다. 대표적인 예시로 디바이스 드라이버(device driver)와 같은 커널 모듈(kernel module)이 커널 모드에서 동작한다.*

* **사용자 모드(user mode)**
    : *사용할 수 있는 CPU 작업이 제한되어 있으며, 일반적으로 어플리케이션이 사용자 모드에서 동작한다. 만일 커널 동작이 요구되면 시스템 호출(system call)을 통해 커널에 요청을 해야 한다. 사용자 모드의 작업은 메모리 주소 공간 중 사용자 공간(user space)에서 이루어진다. 사용자 공간에서 각 어플리케이션 프로세스마다 개별 [가상 주소 공간](/docs/ko.Memory#가상-주소-공간)(virtual address space)이 할당된다.*

이렇게 보호 링이 분류된 이유는 "더 많은 제어에는 더 큰 책임이 뒤따른다"는 관점에서 비롯된다. 커널 모드의 프로그램 오동작은 시스템 전체에 충돌을 일으킬 수 있기 때문에 문제가 절대로 발생하지 않도록 신뢰될 수 있어야 한다.

# 드라이버
> *참조: [Linux Device Drivers, Third Edition [LWN.net]](https://lwn.net/Kernel/LDD3/)*

[디바이스 드라이버](https://ko.wikipedia.org/wiki/장치_드라이버)(device driver; 일명 장치 드라이버)는 특정 하드웨어와 상호작용하기 위해 짜여진 프로그래밍 인터페이스이다. 비록 운영체제나 어플리케이션이 구체적으로 하드웨어가 어떻게 동작하는지 몰라도 해당 하드웨어 특성을 파악하고 있는 드라이버를 통해 간편하게 사용할 수 있다. 시스템 부팅 이후에도 [커널](#커널)(kernel)은 하드웨어를 사용해야 할 때마다 디바이스 드라이버를 언제든지 불러올 수 있는데, 이러한 모듈성(modularity) 덕분에 드라이버 개발은 비교적 쉬워진다.

프로그래밍 설계 원칙에 앞서 매커니즘(mechanism)과 정책(policy)에 대한 소개가 필요하다:

| 프로그램 설계 | 의미                           | 해석                     |
|:-------:|------------------------------|------------------------|
| 매커니즘    | 시스템의 동작 허가 및 리소스 할당을 제어하는 부분 | "어떠한 기능성이 제공되어야 하는가?"  |
| 정책      | 시스템의 동작 허가 및 리소스 할당을 선택하는 부분 | "기능성들이 어떻게 활용될 수 있는가?" |

> 그래픽 드라이버(graphic driver)는 [그래픽 카드](https://ko.wikipedia.org/wiki/그래픽_카드)의 [병렬 컴퓨팅](https://ko.wikipedia.org/wiki/병렬_컴퓨팅) 매커니즘을 통해 고화질 해상도를 화면에 출력하는 정책을 선보인다. 그러나 동일한 매커니즘을 통해 3D 렌더링 및 기계학습 또는 가상화폐 채굴 등의 다양한 정책에도 활용된다.

컴퓨터 과학에서는 [매커니즘과 정책을 분리](https://en.wikipedia.org/wiki/Separation_of_mechanism_and_policy)하는 설계 원칙이 있으며, 이는 매커니즘이 정책을 구속하거나 과하게 제한해서는 안된다는 점을 서술한다. 다시 말해, 기능성을 제공하는 코드(매커니즘)와 제공된 기능성을 활용하는 코드(정책)를 별개로 처리할 수 있으면 소프트웨어 패키지 개발은 훨씬 수월해지고 필요에 따른 접목이 가능해진다.

드라이버 설계에서도 매커니즘과 정책의 분리 원칙은 반영되어야 한다. 하드웨어가 어떻게 활용되는지는 사용자마다 가지각색이므로 특정 정책을 염두하기보다 다양한 용도에서 지원할 수 있도록 매커니즘을 최대한으로 제공하는 것에 집중한다. 이러한 무(無)정책 드라이버는 다음과 같은 일반적인 특징들을 갖는다:

* 동기 및 비동기식 동작 지원
* 동시에 드라이버 다중 접근 가능
* 하드웨어의 기능성을 최대한으로 이용 가능
* 기능성 제공을 위한 별도의 소프트웨어 부재

이러한 특징들을 갖춘 드라이버는 사용자들에게 유용하게 사용될 뿐만 아니라 드라이버 개발과 관리가 매우 간편해진다.

## 드라이버 종류
리눅스는 디바이스의 종류, 일명 클래스(class)를 크게 세 가지로 분류하며 자세한 내용은 차후에 설명할 예정이다.

| 클래스     | 설명                     | 예시                                           |
|:-------:|------------------------|----------------------------------------------|
| 문자 장치   | 일련의 바이트로 장치 접근 및 처리    | 직렬 포트 (키보드, 마우스, 그래픽카드 등)                    |
| 블록 장치   | 블록이란 바이트 묶음의 장치 입출력 처리 | 대용량 저장장치 (하드디스크, CD/DVD, 플래시 메모리 등)          |
| 네트워크 장치 | 패킷 단위의 데이터를 송수신        | 네트워크 인터페이스 제어장치 (LAN, 무선인터넷, Bluetooth 카드 등) |
