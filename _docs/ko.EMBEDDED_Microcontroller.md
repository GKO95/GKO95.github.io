---
layout: docs
category: 임베디드
title: 마이크로컨트롤러
slug: ko.Microcontroller
order: null
---
# 소개
> 본 문서는 [8051](http://www.8052mcu.com/) 계열 마이크로프로세서를 기준으로 설명한다.

마이크로컨트롤러(microcontroller unit; MCU)는 하나의 반도체 칩에 있는 초소형 컴퓨터이다. 기본적으로 내부에 처리장치 및 메모리가 들어있으며 입출력 핀을 프로그래밍으로 설정할 수 있다. 임베디드 시스템 동작에 핵심이 되는 반도체이므로 본 문서는 MCU에 대한 간단히 소개한다.

![마이크로컨트롤러; (상) DIP 및 (하) QFP 패키징](/images/docs/mcu/mcu_chip_variants.png)

## MCS-51
본 문서에서 마이크로컨트롤러를 설명하는데 기준이 되는 [인텔 MCS-51](https://ko.wikipedia.org/wiki/인텔_8051), 일명 "8051" 계열은 1980년에 개발된 임베디드 시스템을 위한 8비트 단일칩 MCU이다. 인텔은 2007년부로 MCS-51 계열 생산을 중단하였으나 워낙 유명한 동시에 활용도가 높아 Dallas나 Texas Instruments 등 여러 다른 제조사에서 개선된 8051 제품을 현재까지도 생산하고 있다.

다음은 8051 MCU 아키텍처 구조를 개략적으로 보여준다. 자세한 내용은 차후 설명할 예정이므로 아래의 그림은 간단히 훑어보도록 한다.

![인텔 MCS-51 마이크로컨트롤러 아키텍처 구조](/images/docs/mcu/8051_architecture.png)

### 비트
비트(bit; binary digit)는 디지털 회로에서 가장 작은 정보 단위이다. 0 혹은 1만으로 표현할 수 있는 이진수이며, 여덟 개의 비트가 모여 하나의 바이트(byte)를 구성한다. 프로그래밍에서 비트와 바이트는 각각 `0b` 및 `0x`를 통해 표현한다.

```csharp
byte A = 0b11100100;    // 십진수: 228
byte B = 0xE4;          // 십진수: 228
```

일반 프로그래밍에서는 자료형들이 최소 한 바이트 이상의 크기를 가지지만, 임베디드 시스템에서는 비트 단위를 중심으로 MCU를 제어하기 때문에 비트 데이터 및 연산자에 대하여 반드시 이해해야 한다.

# 처리장치
[중앙 처리 장치](https://en.wikipedia.org/wiki/중앙_처리_장치)(central processing unit; CPU)는 시스템에게 주어진 명령어(instruction)를 입력받아 대응하는 동작을 수행하도록 하는 컴퓨터에서 가장 핵심되는 부품 중 하나이다. 아래는 단일 프로세서를 가지는 CPU의 대략적인 구성 및 신호 흐름도이다. 

![단일 프로세서 중앙 처리 장치](/images/docs/mcu/mcu_cpu_diagram.gif)

> "단일 프로세서"를 강조한 이유는 CPU는 실질적인 연산을 담당하는 프로세서(혹은 코어)가 일반적으로 한 개 이상이 들어있다: 2개면 듀얼 코어, 4개면 쿼드 코어, 그리고 6개면 헥사 코어라 부른다. 

MCS-51 MCU는 내부에 8비트 연산 CPU를 가지지만, *인텔 MCS-51 마이크로컨트롤러 아키텍처* 그림에서는 CPU가 정확히 어디에 있는지 명시되어 있지 않다. 이는 CPU 구성 장치들이 다른 장치들과 함께 복합적으로 연결되어 있어 한 군데를 지적해 CPU라고 단정지을 수 없기 때문이다.

## 명령어
[명령어](https://ko.wikipedia.org/wiki/명령어_집합)(instruction)는 비트, 숫자 혹은 문자로 구성된 일련의 패턴이며, 프로그램을 통해 장치를 구동할 수 있도록 하는 소프트웨어와 하드웨어 간의 약속된 데이터이다. 명령어는 일반적으로 어떠한 연산을 처리할 것인지를 나타내는 명령 코드(opcode)와 해당 명령 코드에 의해 연산될 피연산자(operand)로 구성되어 있다. 아래는 32비트 MIPS 명령어 중 하나인 "Add Imediate", 즉 덧셈에 대한 이진 패턴이다.

![MIPS "Add Immediate" 명령어](/images/docs/mcu/mips_cpu_instruction.svg)

여기서 MIPS는 RISC 기반의 명령어 집합(instruction set) 중 하나이며, MCS-51의 경우에는 독자적인 CISC 기반의 명령어 집합를 가지며 [여기](https://www.win.tue.nl/~aeb/comp/8051/set8051.html)에서 확인할 수 있다. 그리고 명령어 집합이 바로 시스템의 아키텍처(architecture)를 나타낸다.

> 가장 대표적인 x86 아키텍처 또한 인텔 8086 마이크로프로세서에서의 명령어 집합을 사용하는 시스템을 가리킨다. ([명령어 목록](https://en.wikipedia.org/wiki/X86_instruction_listings))

8051 아키텍처는 명령어는 반드시 1바이트의 명령 코드를 시작으로 최대 2바이트 크기의 피연산자로 구성되어 있다; 즉, 명령어는 총 1~3바이트 크기를 가진다. 그렇지만 8051 아키텍처는 8비트 마이크로컨트롤러임은 변함이 없으며, 다음 8051 아키텍처의 하드웨어 규격을 통해 확인할 수 있다.

* 8비트 크기 프로세서 및 레지스터
* 8비트 크기 데이터 통신 버스 
* 16비트 크기 메모리 주소

아무리 8비트 마이크로컨트롤러라 하더라도 최소한 16비트 길이의 메모리 주소를 가진다. 8비트 주소를 사용할 시 오로지 256 바이트라는 터무니 없이 적은 용량의 메모리밖에 사용할 수 없는 문제가 발생하기 때문이다. 반면 16비트 메모리를 사용하면 최대 64 kB 용량이 확보된다.

## 제어 장치
[제어 장치](https://ko.wikipedia.org/wiki/제어 장치)(control unit)는 CPU 구성요소 중 하나이며, CPU에서 수신받은 명령어를 해독하여 이에 따른 동작을 실행하도록 CPU를 지휘하는 역할을 담당한다. 8051 아키텍처 구조에서 `Timing and Control` 블록이 제어 장치이며, 바로 옆에 있는 `Instruction Register` (명령 레지스터; IR) 메모리에서 제어 장치의 명령어 해독 및 실행이 진행된다.

명령어 해독을 마치고 이에 대응하는 동작을 실행하는 데에는 여러 번의 데이터 이동 및 연산 과정을 거쳐야 한다. 이러한 명령어 오퍼레이션을 구성하는 최소 단위의 데이터 처리 동작을 [마이크로 오퍼레이션](https://ko.wikipedia.org/wiki/마이크로_오퍼레이션)(micro-operation)이라고 부른다. 제어 장치가 CPU를 지휘한다는 표현도 마이크로 오퍼레이션 실행에 직접적으로 관여하기 때문인데, 바로 `OSC`에서 입력받는 클럭 신호의 한 주기마다 하나의 마이크로 오퍼레이션을 실행한다. 

> `OSC` 블록은 [발진기](https://ko.wikipedia.org/wiki/결정_진동자)(oscillator)를 의미하며, 일정한 주기(혹은 주파수)를 가지는 클럭 신호(clock signal)를 발생시킨다. 일정한 주파수를 가지고 있기 때문에 클럭 신호는 디지털 회로의 동작 기준이 되는 메트로놈 역할을 한다. 일반적으로 수정 발진기(crystal oscillator)를 사용하며, 인텔 MCS-51 마이크로컨트롤러의 경우 클럭 신호는 11.059 MHz 주파수를 가진다. 

## 레지스터
[레지스터](https://ko.wikipedia.org/wiki/프로세서_레지스터)(register)는 CPU 및 MCU 내에 존재하는 메모리 장치이며, 대체로 프로세서의 비트 크기만큼의 작은 저장공간 용량을 가진다. 그럼에도 불구하고 RAM이나 ROM과 같은 주기억장치 대신 레지스터를 사용하는 이유는 데이터 접근 속도가 훨씬 더 빠르기 때문이다. 한 클럭 주기 혹은 마이크로 오퍼레이션만에 레지스터 데이터를 불러올 수 있지만, 주기억장치의 경우는 몇 번의 클럭 주기를 거쳐야 한다.

다음은 8051 아키텍처에서 매우 중요한 여섯 가지의 레지스터에 대한 설명이다.

* **누산기** (어셈블리: `AX`)
    : 산술 및 논리 연산의 결과물을 저장하는 8비트 레지스터이다.

    ```armasm
    MOV AX, #1        ; 누산기로 정수 1 이동
    ADD AX, #3        ; 누산기로 정수 3 덧셈
    ; 결과: AX = 4
    ```

* **B 레지스터**
    : 곱셈 및 나눗셈 계산 전용 8비트 레지스터이다.

* **R 레지스터** (어셈블리: `R0`~`R7`)
    : `R0`부터 `R7`까지의 8비트 레지스터 집합(일명, 뱅크 레지스터; bank register)은 보조 메모리 역할을 하는 레지스터이다. 예를 들어, R 레지스터는 누산기 하나만으로 계산이 불가능한 복잡한 산술 계산 도움을 줄 수 있다.

* **데이터 포인터** (약칭. `DPTR`)
    : 8051 마이크로컨트롤러에서 외부 메모리를 접근하는데 사용되는 사용자 접속이 가능한 16비트 레지스터이다. 여기서 외부 메모리란, MCU에 내장되지 않은 주기억장치를 말한다.

* **프로그램 카운터** (약칭. `PC`)
    : CPU의 제어 장치가 처리해야 할 다음 명령어가 주기억장치의 어느 주소에 있는지 알려주는 사용자 접속이 불가한 16비트 레지스터이다. 프로그램 카운터는 항상 `0x0000` 주소부터 시작하여 8비트마다 +1만큼 순차적으로 증가시켜 다음 명령어를 준비한다.

* **스택 포인터** (약칭. `SP`)
    : 마이크로컨트롤러에 내장되어 있는 256바이트 RAM을 스택 메모리로 사용하도록 하는 8비트 레지스터이다. 스택 포인터는 기본적으로 `0x07`로 초기화되어 있으며, 이는 뱅크 레지스터를 고려한 내장 RAM의 메모리 주소이다. 스택 메모리에 데이터가 푸쉬되면 SP의 값이 +1 증가하며 `0x08` 주소를 가리키며, 데이터가 팝이 되면 SP의 값은 -1 감소하여 다시 `0x07`을 가리키게 되는 전형적인 선형적 FILO(first-in last out)를 구현한다.

* **프로그램 상태 워드** (약칭. `PSW`)
    : 아래와 같은 중요한 플래그 비트 상태를 저장하는 8비트 상태 레지스터이다. 
    
    | 비트  |  기호  |         플래그         | 설명                                                  |
    | :--: | :------: | :------------------: | ------------------------------------------------------------ |
    |  7   |    CY    |      캐리 플래그      | 부호 없는 숫자의 연산 결과가 비트 범위를 넘어섰을 때 (일명 캐리; carry) 참이 된다. |
    |  6   |    AC    | 보조 캐리 플래그 | 인진화 십진법의 연산 결과가 비트 범위를 넘어섰을 때 (일명 캐리; carry) 참이 된다. |
    |  5   |    F0    |        플래그 0        | -                                                            |
    | 4, 3 | RS1, RS0 |   레지스터 선택    | 0에서부터 3 사이의 R 레지스터 뱅크를 선택한다.                           |
    |  2   |    OV    |    오버플로우 플래그    | 부호 있는 숫자의 연산 결과가 비트 범위를 넘어섰을 때 (일명 오버플로우; overflow) 참이 된다.            |
    |  1   |    UD    |     사용자 정의     | -                                                            |
    |  0   |    P     |        패리티 플래그       | 연산 결과물의 비트 값 1의 개수가 짝수이면 참이 된다.       |

이 외에도 프로그램 카운터에서 알려준 명령어 주소를 주기억장치로부터 호출하는 16비트 메모리 주소 레지스터(Memory address register; `MAR`), 그리고 해당 주기억장치 주소의 명령어를 받아오는 8비트 메모리 버퍼 레지스터(Memory buffer register; `MBR`)이 존재한다.

## 산술 논리 장치
[산술 논리 장치](https://ko.wikipedia.org/wiki/산술_논리_장치)(arithmetic logic unit; `ALU`)는 CPU의 핵심으로 정수형 산술 계산과 이진수 비트 논리 연산을 처리한다.

![산술 논리 장치의 기호](/images/docs/mcu/mcu_cpu_alu.gif)

| 신호         | 설명                                                  |
| --------------- | ------------------------------------------------------------ |
| 입력 데이터: `A`, `B`    | 연산 처리되어야 할 정수 (일명 피연산자)                |
| 출력 데이터: `Y`   | 연산 처리 이후의 정수 (일명 결과)                 |
| 명령 코드: `Opcode`          | ALU의 연산 선택; 4비트의 길이로 총 16가지의 연산을 수행할 수 있으나, 이는 명령어의 명령 코드와 별개이다. |
| 상태 입력 | *캐리*와 같은 산술 연산에 필요한 부가적 정보를 수신받는다.  |
| 상태 출력 | *캐리*, *패리티*, *오버플로우* 등의 산술 연산 결과물의 부가적 정보를 제공한다. |

### 부동소수점 장치
[부동소수점 장치](https://ko.wikipedia.org/wiki/부동소수점_장치)(floating-point unit; FPU)는 부동소수점 산술 계산에 특화된 장치이다.

# 메모리
메모리는 데이터와 프로그램, 그리고 명령어를 저장하는 하드웨어 장치이다. 메모리는 두 가지의 분류로 나뉘어진다:

* **주기억장치**
    : 데이터를 임시로 저장하는 휘발성 메모리이며, 전력 공급이 중단되면 저장된 모든 데이터를 손실한다. 내부 데이터 통신 버스를 사용하기 때문에 프로세서가 직접 접근할 수 있는 메모리 장치이다. 대표적으로 [랜덤 엑세스 메모리](https://ko.wikipedia.org/wiki/랜덤_액세스_메모리)(random-access memory; RAM)이 있다.

* **보조기억장치**
    : 데이터를 장기간 저장하는 비휘발성 메모리이며, 전력 공급이 중단되어도 모든 데이터가 유지된다. 외부 직력 ATA(일명 SATA) 케이블을 통해 데이터 전송이 되므로 프로세서가 직접 접근할 수 없는 메모리 장치이다. 임베디드에서는 [플래시 메모리](https://ko.wikipedia.org/wiki/플래시_메모리)와 [EEPROM](https://ko.wikipedia.org/wiki/EEPROM)이 보조기억장치에 해당한다.

주기억장치가 프로세서로부터 직접 접근이 가능한 점에서 보조기억장치보다 훨씬 빠른 점도 있지만, 휘발성이 가지는 특성 또한 메모리 접근 속도에 영향을 미친다. RAM 용량이 크다는 것은 더 많은 데이터와 명령어를 불러올 수 있으므로 CPU 성능을 높이는데 기여한다. 

## 내장 메모리
MCS-51 마이크로컨트롤러에는 256바이트의 RAM이 내장되어 있다. 하지만 내장 메모리 중에서도 일부 주소에 따라 사용되는 목적이 상이하며, 하단 128바이트(`0x00`~`0x7F`)는 IRAM이라고 칭하고 상단 128바이트(`0x80`~`0xFF`)는 SFR이라고 부른다.

> 여기서부터 비트와 바이트 단위가 복합적으로 사용되므로 주의하도록 한다.

![MCS-51의 내장 메모리](/images/docs/mcu/8051_memory_internal.gif)

IRAM은 128바이트 전체가 RAM으로 사용되지 않으며, 안에는 (1) 레지스터 뱅크("R" 레지스터 집합)와 (2) 비트 주소 메모리가 포함되어 있다. 기본적으로 `R0`~`R7`이 하나의 레지스터 뱅크를 구성하여 총 네 개의 뱅크가 `0x00`~`0x1F` 주소를 차지하고 있다. 원한다면 `0x00`~`0x07` 범위의 레지스터 뱅크 0 하나만을 사용할 수 있다. 비트 주소 메모리는 총 16바이트, 즉 128비트의 공간을 차지하여 각 비트가 IRAM의 128바이트 주소를 나타내는데 사용되나 선택사항이다. 만일 IRAM 내에 네 개의 레지스터 뱅크와 비트 주소 메모리가 포함되어 있다면 실질적으로 RAM으로 활용할 수 있는 공간은 `0x30`~`0x7F`이다.

### 특수 목적 레지스터
[특수 목적 레지스터](https://en.wikipedia.org/wiki/Special_function_register), 일명 SFR(Special Function Register)은 MCU의 특정 기능들을 제어하기 위해 사용된다. 대표적인 예로 직렬 포트 제어, 전송 속도 설정, 타이머 제어 및 접근 등이 있다. SFR 안에는 다른 레지스터들을 포함하고 있다: 스택 포인터(`0x81`), 데이터 포인터(`0x82`~`0x83`), PSW(`0xD0`), 누산기(`0xE0`), 그리고 B 레지스터(`0xF0`)가 이에 해당한다. 비록 SFR은 내장 메모리의 반을 차지하지만 오직 21바이트만 사용하고 있다. 나머지 주소는 IRAM과 같이 RAM처럼 사용된다.

![MCS-51의 특수 목적 레지스터](/images/docs/mcu/8051_sfr_address.gif)

|                            색상                             | 설명                                                  |
| :----------------------------------------------------------: | ------------------------------------------------------------ |
| <span style="background-color:skyblue; color: black; font-weight: bold;">파란색</span> | 양방향 입출력 포트.          |
| <span style="background-color: yellow; color:black; font-weight: bold;">노란색</span> | 제어 SFR: 마이크로컨트롤러가 어떻게 동작하는지 설정. |
| <span style="background-color:lightgreen; color:black; font-weight: bold;">초록색</span> | 보조 SFR: 마이크로컨트롤러 설정에 기여하지 않지만 동작에 있어서 필요. |

## 프로그램 메모리
프로그램 메모리(PMEM), 일명 코드 메모리는 최소 16비트 플래시 메모리 혹은 EEPROM 보조기억장치로 임베디드 시스템의 프로그램 코드를 저장한다. 일반적으로 프로그램 메모리는 MCU 칩에 내장된 동시에 ISP를 지원하여 손쉽게 프로그램을 설치할 수 있다.

### ISP
[ISP](https://ko.wikipedia.org/wiki/인_시스템_프로그래밍)(in-system programming), 혹은 ICSP(in-circuit serial programming)은 마이크로컨트롤러 및 임베디드 시스템 장치를 별도로 분리할 필요없이 탑재된 상태에서 바로 프로그램을 EEPROM 혹은 플래시 메모리에 설치하도록 한다. 명칭으로부터 알 수 있듯이 ISP는 직렬 통신으로 프로그램을 설치하는데 (1) [JTAG](https://ko.wikipedia.org/wiki/JTAG) 혹은 유사한 구조의 (2) [데이지 체인](https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Daisy_chain_configuration) SPI가 사용된다. 또한 ISP로 프로그램을 설치하는데 각 MCU 계열마다 ISP 전용 프로토콜이 있으며, 일부는 서로 호환되지 않을 수 있다.

# 직렬 통신
[직렬 통신](https://ko.wikipedia.org/wiki/직렬_통신)(serial communication)은 송신 데이터를 하나의 통신 채널에서 한 비트마다 순서대로 전송하는 통신 방법이다.

> 이와 반대되는 개념인 [병렬 통신](https://ko.wikipedia.org/wiki/병렬_통신)(parallel communication)은 여러 통신 채널을 통해 송신 데이터를 구성하는 비트들을 한꺼번에 전송하는 통신 방법이다. 

![병렬 통신(상)과 직렬 통신(하)](/images/docs/mcu/comm_serial_parallel.gif)

케이블 비용과 동기화 문제로 인해 병렬 통신을 활용하기 어려운 장거리 통신 및 컴퓨터 네트워크에서 직렬 통신이 주로 사용된다. 그러나 기술적 발전으로 현재는 단거리 통신에서도 직렬 통신이 병렬 통신보다 훨씬 큰 이점을 가진다. 컴퓨터 시스템과 장치 간에 [PCI](https://ko.wikipedia.org/wiki/PCI_버스) 병렬 통신에서 [PCIe](https://ko.wikipedia.org/wiki/PCI_익스프레스) 직렬 통신으로 변경된 점도 이러한 특성이 반영된 것이다. 본 문서는 MCU에서 흔히 접하게 될 직렬 통신에 대하여 소개한다.

## SPI
> *출처: [Basics of SPI Communication Protocol (영문)](https://www.circuitbasics.com/basics-of-the-spi-communication-protocol/)*

직렬 주변기기 인터페이스(serial peripheral interface; SPI)은 단일마스터 다중슬레이브(single-master, multiple-slave) 구조를 가진 가장 간단한 직렬 통신 프로토콜이다. 여기서 마스터(master)는 제어 장치이며, 슬레이브(slave)란 마스터로부터 제어되는 장치이다.

![단일마스터 다중슬레이브 구조의 SPI](/images/docs/mcu/comm_serial_spi.png)

| 포트      | 의미             | 설명                                                          |
|:-------:|----------------|-------------------------------------------------------------|
| `MOSI`  | 마스터 출력/슬레이브 입력 | 마스터에서 슬레이브로 데이터를 전송하는 통신 포트이다. 전송 데이터의 MSB가 슬레이브로 먼저 전송된다.  |
| `MISO`  | 마스터 입력/슬레이브 출력 | 슬레이브에서 마스터로 데이터를 전송하는 통신 포트이다. 전송 데이터의 LSB가 마스터로 먼저 전송된다.   |
| `SCLK`  | 동기화 클럭         | 통신 동기화를 위해 마스터에서 슬레이브로 일정 주기를 가진 클럭 신호를 제공한다.               |
| `SS/CS` | 슬레이브 혹은 칩 선택   | 마스터로부터 데이터를 수신할 슬레이브를 선택한다. `SS/CS`를 LOW로 설정하여 슬레이브를 활성화한다. |

SPI 직렬 통신은 데이터를 클럭 신호에 따라 송수신하므로 데이터의 시작점과 종단점을 알리는 전송 프로토콜을 필요하지 않다. 다시 말해, 하나의 클럭 신호를 통해 마스터와 슬레이브가 동일한 시간 주기로 동시에 동작한다. 이러한 이유로 클럭 신호를 공유하는 직렬 통신을 동기화 직렬 통신(synchronous serial communication)이라고 부른다.

SPI 직렬 통신의 장단점을 요약하면 다음과 같다:

* *장점*
    * 전송 프로토콜을 필요로 하지 않아 간섭(interruption)없이 데이터를 연속으로 빠르게 전송할 수 있다.
    * `SS/CS` 포트로 슬레이브를 간단히 선택할 수 있다.
    * 송신과 수신을 동시에 할 수 있다.

* *단점*
    * 네 개의 통신 채널이 필요하다.
    * 전송 오류를 확인할 수 없다.
    * 하나의 마스터만 허용된다.

## UART
> *출처: [Basics of UART Communication (영문)](https://www.circuitbasics.com/basics-uart-communication/)*

범용 비동기화 송수신기(universal asynchronous receiver-transmitter; UART)는 직렬 통신 프로토콜이 아니라 통신 회로나 IC의 분류에 해당한다. UART는 마스터와 슬레이브 간의 송신부 `Tx`와 수신부 `Rx`를 연결하므로써 직렬 통신을 하여 단일마스터 단일슬레이브 구조를 가진다.

![단일마스터 단일슬레이브 구조의 UART](/images/docs/mcu/comm_serial_uart.png)

UART의 송신부 `Tx`는 데이터 버스로부터 송신할 데이터를 병렬로 받아 일련의 직렬 데이터로 재구성한다. 직렬 데이터는 LSB부터 차례대로 수신부 `Rx`로 전송되는데, 수신이 완료되면 병렬 데이터로 되돌려 버스로 반환한다. 이때 SPI와 달리, UART는 패킷(packet)이란 데이터 묶음으로 전송한다.

![UART 통신의 패킷 구조](/images/docs/mcu/comm_serial_packet.png)

패킷은 데이터의 시작과 종단을 알리는 비트가 있어 어디까지가 실제 전송 데이터인지 클럭 신호 없이도 알아낼 수 있다. 그래서 UART는 클럭 신호를 사용하지 않으며 통신의 동기화가 필요없기 때문에 "비동기화"란 용어가 이름에 붙는다.

UART의 통신부는 상시 5V 전압의 HIGH로 유지한다. 데이터를 전송하면 패킷은 0V 전압의 LOW 상태를 갖는 시작 비트는 앞장세우는데, 수신부는 HIGH에서 LOW로의 전이를 감지하여 데이터를 수신받기 시작한다. 수신부가 데이터를 읽어내는 속도는 보 레이트(baud rate)로 결정되며, 송신부도 마찬가지로 이와 동일한 보 레이트로 데이터를 송신해야 한다. 그러나 송신부와 수신부의 보 레이트를 동일화시키지 못하여 10% 허용 범위를 초과하면 전송 오류가 발생한다. 오류 발생 여부는 [패리티 비트](https://ko.wikipedia.org/wiki/패리티_비트)로 검사하는데, 패리티 비트가 각각 LOW와 HIGH를 갖으면 데이터 비트의 HIGH 개수가 홀수와 짝수를 갖는다는 의미이다. 만일 실질적인 내용을 담는 데이터 프레임(data frame) 내의 HIGH 비트 개수가 패리티 비트에 부합하지 않으면 UART는 해당 데이터를 무시한다.

UART 통신의 장단점을 요약하면 다음과 같다:

* *장점*
    * 두 개의 통신 채널만 사용한다.
    * 클럭 신호가 전혀 필요하지 않다.
    * 전송 오류를 검사하는 패리티 비트를 갖는다.
    * 가장 흔히 사용되고 있는 직렬 통신 중 하나이다.

* *단점*
    * 단일마스터 단일슬레이브 구조로 한정된다.
    * (10% 오차율 이내로) 보 레이트를 통일시켜야 한다.
    * 한 번에 전송할 수 있는 데이터 비트가 제한되어 있다.

### 보 레이트
[보 레이트](https://en.wikipedia.org/wiki/Symbol_rate)(baud rate), 혹은 심볼율(symbol rate)란 데이터 통신에서 초당 심볼 변화(혹은 심볼 전송 개수)를 의미하며 보(baud; Bd)라는 단위를 사용한다. 여기서 심볼(symbol)은 디지털 통신 분야에서 인코딩된 신호가 가질 수 있는 값을 말한다. 즉, 8비트 데이터를 주고받는 MCS-51 마이크로프로세서는 0과 1의 이진수로 인코딩된 여덟 비트 길이의 바이트가 하나의 심볼이 된다. 예를 들어, 9600 Bd는 초당 9600 심볼 속도로 데이터를 전송한다.

## I2C
> *출처: [Basics of the I2C Communication Protocol (영문)](https://www.circuitbasics.com/basics-of-the-i2c-communication-protocol/)*

직접회로간(Inter-Integrated Circuit; $\mathsf{I^2C}$ 혹은 IIC), 흔히 "아이스퀘어드씨"라고 부르며 다중마스터 다중슬레이브(multiple-master, multiple-slave) 구조를 구현할 수 있는 직렬 통신 프로토콜이다. 본 직렬 통신 프로토콜은 SPI와 UART의 장점들을 골고루 가진다.

![다중마스터 다중슬레이브 구조의 I2C](/images/docs/mcu/comm_serial_i2c.png)

| 포트    | 의미        | 설명                                  |
|:-----:|-----------|-------------------------------------|
| `SDA` | 직렬 전송 데이터 | 마스터와 슬레이브 간을 연결하는 양방향성 데이터 전송 채널이다. |
| `SCL` | 직렬 클럭 신호  | 클럭 신호, 즉 통신 동기화 신호가 입/출력되는 포트이다.    |

$\mathsf{I^2C}$ 프로토콜이 비록 두 개의 채널만을 가지지만 SPI처럼 여러 개의 슬레이브와 통신할 수 있는 이유는 바로 메시지(message) 데이터 묶음에 있다. 메시지 안에는 슬레이브를 선택하는 주소 프레임(address frame)과 실질적인 내용을 담는 데이터 프레임(data frame) 그리고 시작 및 종단 비트 등을 가진다.

![I2C 통신 프로토콜의 메시지 구조](/images/docs/mcu/comm_serial_message.png)

UART와 유사한 방식으로 슬레이브는 시작 비트가 HIGH에서 LOW로 전이된 것을 감지하면 메시지를 읽기 시작한다. 단, $\mathsf{I^2C}$에서는 추가 조건이 있으며 시작 비트의 전이가 `SCL` 클럭 신호가 HIGH에서 LOW로 전이되기 전에 발생해야 한다. 반대로 메시지가 끝났음을 알리기 위해서는 `SCL` 클럭 신호가 LOW에서 HIGH로의 전이 이후에 종단 비트에서 LOW로부터 HIGH 전이가 발생해야 한다. 

메시지 안에는 주소 프레임이 있어 어느 슬레이브 장치와 통신할 것인지 선택할 수 있다. 슬레이브 장치는 일반적으로 7~10 비트 크기의 주소를 갖으며, 슬레이브는 자신의 주소와 일치한 메시지만을 수신한다. 그리고 이에 대한 응답으로 마스터에게 `ACK` 확인 신호를 의미하는 LOW를 전송한다. 주소가 일치하지 않는 나머지 장치는 `NACK` 신호로 HIGH를 유지하여 마치 아무런 메시지를 받지 않은 것처럼 행동한다. 허나 하나의 마스터는 동일한 주소를 갖는 두 개 이상의 슬레이브와 통신할 수 없다는 것을 의미하기도 한다.

또한 ISP에서 MISO 및 MOSI 포트도 메시지의 `READ`/`WRITE` 비트 하나로 해결한다: (1) 마스터에서 슬레이브에게 요청하는 목적의 `READ` (LOW 비트), 그리고 (2) 마스터에서 슬레이브에게 일방적으로 전달하는 `WRITE` (HIGH 비트)로 분류된다.

$\mathsf{I^2C}$ 통신 프로토콜은 다음 절차를 통해 데이터를 송수신한다:

1. `SDA`의 시작 비트를 `SCL`가 하강 에지(falling edge)에 진입하기 전에 HIGH에서 LOW로 전이시킨다.
2. 메시지는 마스터에 연결된 모든 슬레이브 장치에 전달하여 주소 프레임과 일치하는 슬레이브를 찾는다.
3. 일치하는 주소를 갖는 슬레이브 장치는 `ACK` 신호를 응답하며, 나머지는 `NACK`를 유지한다.
4. 마스터는 해당 슬레이브에게 데이터 프레임을 전송하고, 이상 없이 수신하면 `ACK`로 매번 응답한다.
5. 메시지 종료 시, `SDA`의 종단 비트를 `SCL`가 상승 에지(rising edge)에 진입한 이후에 LOW에서 HIGH로 전이시킨다.

$\mathsf{I^2C}$ 직렬 통신의 장단점을 요약하면 다음과 같다:

* *장점*
    * 두 개의 통신 채널만 사용한다.
    * 여러 개의 마스터와 슬레이브 구조를 지원한다.
    * `ACK`/`NACK` 비트로 수신 이상 유무를 확인할 수 있다.
    * 하드웨어적인 면에서 UART보다 간단하다.
    * 가장 흔히 사용되고 있는 직렬 통신 중 하나이다.

* *단점*
    * SPI보다 느린 전송률을 갖는다.
    * 하드웨어적인 면에서 SPI보다 복잡하다.
    * 한 번에 전송할 수 있는 데이터 비트가 제한되어 있다.

# 타이머
타이머(timer)는 시간을 다루는 장치로 크게 두 가지의 기능을 가진다: (1) 시간 측정 및 (2) 이벤트 카운터이다. 타이머는 단 하나의 명령 주기만으로 실행되는 매우 간단한 동작이며, 인텔 8051 마이크로컨트롤러의 명령 주기는 12 클럭 펄스를 갖는다.

> [명령 주기](https://ko.wikipedia.org/wiki/명령_주기)(instruction cycle; machine cycle)란, 하나의 명령을 실행하기 위해 필요한 최소한의 클럭 펄스 주기이다. 하나의 클럭 신호를 입력받을 때마다 마이크로 오퍼레이션이 실행되고, 여러 마이크로 오퍼레이션이 모여 하나의 명령어에 의한 오퍼레이션을 구성한다. 그러나 일반적으로 명령어들은 이보다 더 많은 주기를 필요로 하다.
    
본 문서는 MCU에서의 타이머 사용에 대하여 설명한다.

## 시간 측정
마이크로컨트롤러 명령 주기와 클럭 주파수를 사용하여 초당 실행되는 명령어 개수를 구할 수 있다. MCS-51의 경우, 12 클럭 주기가 하나의 명령 주기를 이루며 클럭 주파수는 1.105 MHz이므로 다음과 같이 계산된다.

$$
\frac{\mathsf{clock \ frequency}}{\mathsf{instruction \ cycle}}
= \frac{11,059,000 \ \mathsf{cycles}/\mathsf{second}} {12 \ \mathsf{cycles}/\mathsf{instruction}}
= 921,583 \ \mathsf{instructions}/\mathsf{second}
$$

즉, 타이머에서 921,583 명령 주기를 측정하면 1초가 지났음을 의미한다. 하지만 16비트는 정수 65,535까지만 표현할 수 있는 한계를 가지기 때문에 1초를 측정하는 것은 불가능하다. 그러나 만일 0.05초에 대하여 계산한다면 이야기는 달라진다.

$$
0.05 \ \mathsf{seconds} \times 921,583 \ \mathsf{instructions}/\mathsf{second} = 46,079.15 \ \mathsf{instructions}
$$

타이머에서 46,079 명령 주기를 측정하여 `0xB3FF` 값을 갖으면 0.049999873 초가 지났음을 나타낸다. 비록 정확히 0.05초가 아니지만, 0.001%보다 적은 오차율은 2개월마다 단 1초만의 시간 오차를 갖으므로 0.05초 타이머 역할로써는 큰 문제가 되지 않는다.

## 이벤트 카운터
[이벤트](https://ko.wikipedia.org/wiki/이벤트_(컴퓨팅))(event)란 마이크로 오퍼레이션이나 명령어를 지칭하는 게 아닌, 어떠한 상호작용으로 발생하는 사건을 가리키는 용어이다. 컴퓨터에서 이벤트라면 마우스 및 키보드 버튼 클릭 등이 있다. 마찬가지로 임베디드 시스템에 대한 예시로는 외부 센서의 물체 감지 등이 있다. 그리고 이벤트 카운터 역할을 바로 타이머가 수행할 수 있다.

SFR의 `TMOD.2`와 `TMOD.6` 비트는 `C/T` 이름을 가지는 것을 확인할 수 있다. 해당 비트가 0이면 명령 주기를 카운트하는 타이머로 동작하지만, 1의 값을 가지면 이벤트 카운터 역할을 한다. 이벤트 카운터는 HIGH 펄스를 감지할 때마다 +1 증가하는데, 어느 신호의 펄스를 감지할 것인지는 소프트웨어 측에서 지정해야 한다.

# 인터럽트
[인터럽트](https://ko.wikipedia.org/wiki/인터럽트)(interrupt)는 최상위 작업순위를 가지는 이벤트이다. 가장 우선적으로 처리해야 하기 때문에 현재 진행 중인 일반 프로그램 실행을 잠시 중단시키고 인터럽트를 우선적으로 처리한다. 임베디드 시스템에서 인터럽트의 존재는 매우 중요한 이유는 바로 멀티태스킹에 필요한 [스레드](https://ko.wikipedia.org/wiki/스레드_(컴퓨팅))(thread) 작업이 불가능하기 때문이다.

MCS-51에는 다섯 개의 인터럽트가 존재하며, 이에 대한 설명은 다음과 같다.

| 인터럽트  |   플래그   | 벡터 주소  | 처리순서    | 설명  |
| :--- | :------: | ---- |:---:| ------------------- |
| 외부 0 | `IE0` | `0x0003` | 1 | 외부에서 유입된 인터럽트 신호 0 |
| 타이머 0 |   `TF0` | `0x000B` | 2 | 타이머 0 오버플로우 |
| 외부 1 |   `IE1`    | `0x0013` | 3 | 외부에서 유입된 인터럽트 신호 1 |
| 타이머 1 |   `TF1`    | `0x001B` | 4 | 타이머 1 오버플로우 |
| 직렬 |   `RI/TI`    | `0x0023` | 5 | UART 데이터 송수신 |

인터럽트의 플래그가 참이 되면 주요 프로그램 실행이 일시적으로 중지되고 해당하는 인터럽트 처리가 실행된다. 인터럽트 처리자 코드는 프로그램 메모리의 고정된 주소에 위치하는데 이를 벡터 주소(vector address)라고 부른다.

## 우선순위
인터럽트 내에서도 고우선순위 및 저우선순위를 SFR의 `IP`에서 지정할 수 있다. 비트 값이 1이면 해당 인터럽트는 고우선순위로 처리된다.

| 비트      | 이름    | 설명               |
|:-------:|:-----:|------------------|
| 7, 6, 5 | -     | 미지정              |
| 4       | `PS`  | 직렬 인터럽트 우선순위     |
| 3       | `PT1` | 타이머 1 인터럽트 우선순위 |
| 2       | `PX1` | 외부 1 인터럽트 우선순위   |
| 1       | `PT0` | 타이머 0 인터럽트 우선순위  |
| 0       | `PX0` | 외부 0 인터럽트 우선순위   |

다음은 인터럽트의 우선순위에 따른 처리 방식에 대하여 설명한다:

* 저우선순위 인터럽트가 고우선순위 인터럽트를 중단시킬 수 없다.
* 동일한 우선순위의 인터럽트를 중단시킬 수 없다.
* 저우선순위 인터럽트는 다른 실행 중인 인터럽트가 없을 때만 처리된다.
* 두 인터럽트가 동시에 발생하였으면 고우선순위가 먼저 처리된다. 만일 우선순위가 동일하면 처리순서에 따라 결정된다.

## 처리 절차
인터럽트가 발생되면 마이크로컨트롤러에 의해 다음 동작들이 자동적으로 진행된다:

1. 현재 프로그램 카운터가 스택에 저장된다.
2. 동일 우선순의 혹은 낮은 우선순위의 인터럽트를 차단한다.
3. 타이머 및 외부 인터럽트의 경우, 1로 설정된 해당 플래그를 0으로 리셋한다.
4. 해당하는 인터럽트 처리자의 벡터 주소로 이동 및 코드를 실행한다.
