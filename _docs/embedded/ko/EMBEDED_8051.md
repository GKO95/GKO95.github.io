---
name: MCS-51
lang: ko
layout: docs
author: GKO95
category: Embedded
title: "임베디드 | MCS-51"
logo: "/assets/img/res/logo-8051.png"
order: 0x20
---
# **MCS-51: 소개**
> *참조: http://www.8052mcu.com/*

[인텔 MCS-51](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%85%94_8051), 일명 "8051"이라 불리는 반도체 칩은 1980년에 개발된 임베디드 시스템을 위한 8비트 단일칩 마이크로컨트롤러(micr-controller unit; MCU)이다. 기존 8051에서 내장 RAM 메모리가 확장된 "8052", 혹은 내장 ROM 메모리가 없는 "8031" 등의 파생 모델들을 MCS-51 패밀리라고 부른다. 인텔은 2007년부로 MCS-51 패밀리 생산을 중단하였으나, 임베디드에서는 워낙 유명한 동시에 활용도가 높아 Dallas나 Texas Instruments 등 여러 다른 제조사에서 개선된 8051 제품을 현재까지도 생산하고 있다.

## MCS-51 구조
다음은 인텔 MCS-51 마이크로컨트롤러 아키텍처 구조를 개략적으로 보여준다. 자세한 내용은 다음 장에서부터 설명할 예정이므로 아래의 그림은 간단히 훑어보도록 한다.

![그림1. 인텔 MCS-51 마이크로컨트롤러 아키텍처](/assets/img/docs/embedded/8051/8051_architecture.png)

위의 그림 중에서 일부 블록은 여덟 개의 화살표가 뻗어나가는 것을 볼 수 있다. 각 화살표마다 데이터는 비트 단위로 전송 및 수신되며, 여덟 개의 화살표가 모여 하나의 바이트를 이루는 것이다.

### 비트
비트(bit; binary digit)는 디지털 회로에서 가장 작은 정보의 단위를 가리킨다. 비트는 0 혹은 1만을 가지는 이진수이며, 여덟 개의 비트가 모여 하나의 바이트(byte)를 구성한다. 프로그래밍에서 비트와 바이트는 각각 `0b` 및 `0x`를 통해 표현한다.

```csharp
byte A = 0b11100100;    // 십진수: 228
byte B = 0xE4;          // 십진수: 228
```

일반적으로 프로그래밍에서 자료형들은 바이트 단위로 정의되었으나, 임베디드 시스템에서는 비트 단위를 중심으로 데이터 송수신이 이루어지거나 메모리 할당 등이 이루어지므로 반드시 이해하도록 한다.

# **MCS-51: CPU**
중앙 처리 장치(central processing unit; CPU)는 시스템에게 주어진 명령어(instruction)를 입력받아 대응하는 동작을 수행하도록 하는 컴퓨터에서 가장 핵심되는 부품 중 하나이다. 아래는 단일 프로세서를 가지는 CPU의 대략적인 구성 및 신호 흐름도이다. 

![그림#. 단일 프로세서 중앙 처리 장치](/assets/img/docs/embedded/8051/8051_cpu.gif)

여기서 "단일 프로세서"를 강조한 이유는 현재 사용되고 있는 대부분의 CPU는 한 개 이상의 프로세서 혹은 코어(core)를 가지기 때문이다. CPU 분류 중에서 콰드 코어나 헥사 코어 등이 바로 CPU 내에 몇 개의 프로세서가 들어있는지를 알려준다.

MCS-51 MCU는 내부에 8비트 연산 CPU를 가지지만, *그림1. 인텔 MCS-51 마이크로컨트롤러 아키텍처*에서는 CPU가 정확히 어디에 있는지 명시되어 있지 않다. 이는 CPU 구성 장치들이 다른 장치들과 함께 복합적으로 연결되어 있어 한 군데를 지적해 CPU라고 단정지을 수 없기 때문이다.

## 명령어
명령어(instruction)는 비트, 숫자 혹은 문자로 구성된 일련의 패턴이며, 프로그램을 통해 장치를 구동할 수 있도록 하는 소프트웨어와 하드웨어 간의 약속된 데이터이다. 명령어는 일반적으로 어떠한 연산을 처리할 것인지를 나타내는 명령 코드(opcode)와 해당 명령 코드에 의해 연산될 피연산자(operand)로 구성되어 있다. 아래는 32비트 MIPS 명령어 중 하나인 "Add Imediate", 즉 덧셈에 대한 이진 패턴이다.

![Figure #. MIPS "Add Immediate" 명령어](/assets/img/docs/embedded/8051/8051_cpu_instruction.svg)

여기서 MIPS는 RISC 기반의 명령어 집합(instruction set) 중 하나이며, MCS-51의 경우에는 독자적인 CISC 기반의 명령어 집합를 가지며 [여기](https://www.win.tue.nl/~aeb/comp/8051/set8051.html)에서 확인할 수 있다. 그리고 명령어 집합이 바로 시스템의 아키텍처(architecture)를 나타낸다.

> 가장 대표적인 x86 아키텍처 또한 인텔 8086 마이크로프로세서에서의 명령어 집합을 사용하는 시스템을 가리킨다. [*(명령어 목록)*](https://en.wikipedia.org/wiki/X86_instruction_listings)

8051 아키텍처는 명령어는 반드시 1바이트의 명령 코드를 시작으로 최대 2바이트 크기의 피연산자로 구성되어 있다; 즉, 명령어는 총 1~3바이트 크기를 가진다. 그렇지만 8051 아키텍처는 8비트 마이크로컨트롤러임은 변함이 없으며, 다음 8051 아키텍처의 하드웨어 규격을 통해 확인할 수 있다.

* 8비트 크기 프로세서 및 레지스터
* 8비트 크기 데이터 통신 버스 
* 16비트 크기 메모리 주소

아무리 8비트 마이크로컨트롤러라 하더라도 최소한 16비트 길이의 메모리 주소를 가진다. 8비트 주소를 사용할 시 오로지 256 바이트라는 터무니 없이 적은 용량의 메모리밖에 사용할 수 없는 문제가 발생하기 때문이다. 반면 16비트 메모리를 사용하면 최대 64 kB 용량이 확보된다.

## 제어 장치
제어 장치(control unit)는 CPU 구성요소 중 하나이며, CPU에서 수신받은 명령어를 해독하여 이에 따른 동작을 실행하도록 CPU를 지휘하는 역할을 담당한다. 8051 아키텍처 구조에서 `Timing and Control` 블록이 제어 장치이며, 바로 옆에 있는 `Instruction Register` (명령 레지스터; IR) 메모리에서 제어 장치의 명령어 해독 및 실행이 진행된다.

> 여기서 "Timing"이란 단어는 아래측에 연결된 `OSC`, 일명 발진기(oscillator)와 직접적인 연관이 있다. 발진기는 일정한 주기(혹은 주파수)를 가지는 클럭 신호(clock signal)를 발생한다. 일반적으로 수정 발진기(crystal oscillator)를 사용한다.
>
> 제어 장치에서 명령어를 처리하는 데에는 여러 단계의 마이크로 오퍼레이션(micro-operation)을 거치며, 각각의 레지스터 간 데이터 이동 및 산술 연산 등이 하나의 마이크로 오퍼레이션이다. 제어 장치는 하나의 클럭 펄스 신호를 입력받을 때마다 하나의 마이크로 오퍼레이션을 실행한다.

## 레지스터
레지스터(register)는 CPU 및 MCU 내에 존재하는 메모리 장치이며, 대체로 프로세서의 비트 크기만큼의 작은 저장공간 용량을 가진다. 그럼에도 불구하고 RAM이나 ROM과 같은 주기억장치 대신 레지스터를 사용하는 이유는 데이터 접근 속도가 훨씬 더 빠르기 때문이다. 한 클럭 주기 혹은 마이크로 오퍼레이션만에 레지스터 데이터를 불러올 수 있지만, 주기억장치의 경우는 몇 번의 클럭 주기를 거쳐야 한다.

다음은 8051 아키텍처에서 매우 중요한 여섯 가지의 레지스터에 대한 설명이다.

* **누산기** (어셈블리: `AX`)
    : 산술 및 논리 연산의 결과물을 저장하는 8비트 레지스터이다.

    ```armasm
    MOV AX, #1        ; 누산기로 정수 1 이동
    ADD AX, #3        ; 누산기로 정수 3 덧셈
    ; 결과: AX = 4
    ```

* **B 레지스터**
    : 곱셈 및 나눗셈 계산 전용 8비트 레지스터이다.

* **R 레지스터** (어셈블리: `R0`~`R7`)
    : `R0`부터 `R7`까지의 8비트 레지스터 집합(일명, 뱅크 레지스터; bank register)은 보조 메모리 역할을 하는 레지스터이다. 예를 들어, R 레지스터는 누산기 하나만으로 계산이 불가능한 복잡한 산술 계산 도움을 줄 수 있다.

* **데이터 포인터** (약칭. `DPTR`)
    : 8051 마이크로컨트롤러에서 외부 메모리를 접근하는데 사용되는 사용자 접속이 가능한 16비트 레지스터이다. 여기서 외부 메모리란, MCU에 내장되지 않은 주기억장치를 말한다.

* **프로그램 카운터** (약칭. `PC`)
    : CPU의 제어 장치가 처리해야 할 다음 명령어가 주기억장치의 어느 주소에 있는지 알려주는 사용자 접속이 불가한 16비트 레지스터이다. 프로그램 카운터는 항상 `0x0000` 주소부터 시작하여 8비트마다 +1만큼 순차적으로 증가시켜 다음 명령어를 준비한다.

* **스택 포인터** (약칭. `SP`)
    : 마이크로컨트롤러에 내장되어 있는 256바이트 RAM을 스택 메모리로 사용하도록 하는 8비트 레지스터이다. 스택 포인터는 기본으로 `0x07`으로 초기화되며, 이는 RAM의 메모리 주소를 의미한다. 스택 메모리에 데이터가 푸쉬되면 SP의 값이 +1 증가하며 `0x08` 주소를 가리키며, 데이터가 팝이 되면 SP의 값은 -1 감소하여 다시 `0x07`을 가리키게 되는 전형적인 선형적 FILO(first-in last out)를 구현한다.

* **프로그램 상태 워드** (약칭. `PSW`)
    : 아래와 같은 중요한 플래그 비트 상태를 저장하는 8비트 상태 레지스터이다. 
    
    | 비트  |  기호  |         플래그         | 설명                                                  |
    | :--: | :------: | :------------------: | ------------------------------------------------------------ |
    |  7   |    CY    |      캐리 플래그      | 부호 없는 숫자의 연산 결과가 비트 범위를 넘어섰을 때 (일명 캐리; carry) 참이 된다. |
    |  6   |    AC    | 보조 캐리 플래그 | 인진화 십진법의 연산 결과가 비트 범위를 넘어섰을 때 (일명 캐리; carry) 참이 된다. |
    |  5   |    F0    |        플래그 0        | -                                                            |
    | 4, 3 | RS1, RS0 |   레지스터 선택    | 0에서부터 3 사이의 R 레지스터 뱅크를 선택한다.                           |
    |  2   |    OV    |    오버플로우 플래그    | 부호 있는 숫자의 연산 결과가 비트 범위를 넘어섰을 때 (일명 오버플로우; overflow) 참이 된다.            |
    |  1   |    UD    |     사용자 정의     | -                                                            |
    |  0   |    P     |        패리티 플래그       | 연산 결과물의 비트 값 1의 개수가 짝수이면 참이 된다.       |

이 외에도 프로그램 카운터에서 알려준 명령어 주소를 주기억장치로부터 호출하는 16비트 메모리 주소 레지스터(Memory address register; `MAR`), 그리고 해당 주기억장치 주소의 명령어를 받아오는 8비트 메모리 버퍼 레지스터(Memory buffer register; `MBR`)이 존재한다.

## 산술 논리 장치
산술 논리 장치(arithmetic logic unit; `ALU`)는 CPU 및 GPU의 핵심으로 십진수 정수 산술 계산과 이진수 비트 논리 연산을 처리한다.

![그림#. 산술 논리 장치의 기호](/assets/img/docs/embedded/8051/8051_cpu_alu.gif)

| 신호         | 설명                                                  |
| --------------- | ------------------------------------------------------------ |
| 입력 데이터: `A`, `B`    | 연산 처리되어야 할 정수 (일명 피연산자)                |
| 출력 데이터: `Y`   | 연산 처리 이후의 정수 (일명 결과)                 |
| 명령 코드: `Opcode`          | ALU의 연산 선택; 4비트의 길이로 총 16가지의 연산을 수행할 수 있으나, 이는 명령어의 명령 코드와 별개이다. |
| 상태 입력 | *캐리*와 같은 산술 연산에 필요한 부가적 정보를 수신받는다.  |
| 상태 출력 | *캐리*, *패리티*, *오버플로우* 등의 산술 연산 결과물의 부가적 정보를 제공한다. |


# **MCS-51: 메모리**

# **MCS-51: Keil C51**



