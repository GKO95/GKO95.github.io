---
layout: docs
language: ko
category: 프로그래밍
title: 파이썬
icon: icon-python.png
meta: Python
order: 0x00
---
# 파이썬: 소개
파이썬(Python)은 웹 프로그래밍, 과학연구, 인공지능을 포함한 수많은 영역에서 응용 가능한 고급 프로그래밍 언어이다. 파이썬은 다른 프로그래밍 언어에 비해 매우 간단하고 폭넓은 커뮤니티 덕분에 파이썬 개발에 용이한 많은 종류의 소프트웨어(예. 라이브러리, 프레임워크 등)들이 존재한다. 이러한 이유로 파이썬은 프로그래밍 입문자로써 시작하기 매우 좋은 언어이다.

## 인터프리트 언어
> 파이썬은 인터프리트 언어이며, 아래는 컴파일 언어와 인터프리트 언어에 대한 설명이다.

프로그래밍 언어는 크게 두 종류로 나뉘어진다: 바로 컴파일 언어와 인터프리트 언어이다. 컴퓨터에서 동작하는 모든 프로그램은 0과 1로만 구성된 이진코드와 같은 기계언어로 되어 있다. 하지만 프로그램이 어떻게 동작하는지 설계하는 소스 코드(source code)는 모두 영어로 작성된다. 그러기 때문에 프로그램을 실행시키기 위해서는 컴퓨터가 이해하지 못하는 영문 코드를 기계언어로 변환시켜야 한다.

아래는 대표적인 컴파일 언어인 [C](../ko.PRGMING_C)/[C++](../ko.PRGMING_Cpp) 소스 코드(`.CPP`)와 그로부터 생성된 실행 프로그램(`.EXE`) 내부를 보여준다.

![그림 1. 컴파일 언어의 소스 코드와 실행 파일](/images/docs/shared/programming_lang_compile.png)

왼쪽의 프로그램 소스 코드에는 인간이 사용하는 공용어인 영어를 사용한 것을 볼 수 있다. 하지만 오른쪽의 컴퓨터에서 동작하는 프로그램 실행 파일 내부는 전혀 이해할 수 없는 숫자와 알파벳의 조합으로 되어 있다. 이는 이진코드를 16진수로 표현하였을 뿐, 이진코드로 구성되었다는 점은 변함없다. 그리고 이렇게 영문 소스 코드에서 이진코드 실행 파일로 변환하는 작업을 컴파일(compile)이라고 부르며, 컴파일을 처리하는 프로그램을 컴파일러(compiler)라고 부른다.

컴파일 언어는 컴퓨터가 이해할 수 있는 언어로 최적화되어 프로그램을 실행하기 때문에 매우 빠르다는 장점을 가진다. 그러나 "최적화"로 인하여 다른 운영체제(윈도우, macOS, 리눅스 등)와 아키텍처(x86, x64, ARM 등)를 가진 컴퓨터에는 거의 실행할 수 없다. 다른 시스템에서도 동작하게 하려면 프로그램 실행 대상 시스템을 설정하여 새로이 컴파일해야 한다.

그 다음은 대표적인 인터프리터 언어인 파이썬 파일(`.PY`)에 대한 예시를 보여준다.

![그림 2. 인터프리터 언어의 소스 코드와 실행 파일](/images/docs/shared/programming_lang_interpret.png)

왼쪽의 파일 탐색기에는 파이썬 파일이 있는데, 이는 소스 코드인 동시에 실행 파일이다. 오른쪽의 상단은 파일을 코드 편집기로 열었을 때, 그리고 하단은 동일한 파일을 실행 파일로써 열었을 때이다. 이것이 가능한 이유는 바로 인터프리트 언어인 파이썬은 인터프리터(interpreter)라는 언어 통역가가 영문 소스 코드를 이진코드로 곧바로 통역(interpret)하여 컴퓨터에게 전달하기 때문이다.

인터프리트 언어는 인터프리터만 설치되어 있으면 어느 컴퓨터라도 동일한 파일로 프로그램을 실행할 수 있는 장점을 가졌으며, 이를 크로스 플랫폼(cross platform)이라 부른다. 단, 프로그램을 실행할 때마다 인터프리터가 영문 소스 코드를 기계어로 통역해야 하기 때문에 실행 속도가 컴파일된 프로그램보다 상대적으로 느리다.

### C파이썬 인터프리터
파이썬의 가장 첫 인터프리터는 C 프로그래밍 언어로 개발되었으며, 이를 C파이썬(CPython)이라고 부른다. C파이썬은 현재 가장 널리 사용되는 인터프리터이다. 그 외에도 다른 프로그래밍 언어로 개발된 Jython(자바로 구현된 인터프리터), IronPython([.NET](../ko.PRGMING_Csharp#net)으로 구현된 인터프리터), 그리고 PyPy(순수 파이썬으로 구현된 인터프리터) 등이 있다.

파이썬은 인터프리트 언어로 소개하였으나, 기술적으로는 인터프리터와 컴파일러 둘 다 사용한다. 우선 C파이썬이 파이썬 코드를 바이트코드(bytecode)로 컴파일한 다음 C파이썬 인터프리터에 의해 실행된다. 파이썬이 크로스 플랫폼 성질을 가질 수 있는 것은 바이트코드 덕분이다.

# 파이썬: 설치
파이썬을 실행하기 위해서는 두 가지의 프로그램이 필요하다: 바로 인터프리터와 통합 개발 환경(integrated development environment; IDE)이다. 리눅스와 macOS는 기본적으로 파이썬 2와 3 인터프리터가 설치되어 있으나, 다른 특정 버전을 원하면 새로 설치해야 한다. 본 장에서는 파이썬 인터프리터와 IDE의 설치 및 연동을 통해 파이썬과 같은 인터프리터 언어가 어떻게 동작하는지 이해를 돕는다.

## 인터프리터 선택
파이썬 코드를 실행하기 위해서 가장 필수적인 인터프리터는 파이썬 공식 웹사이트에서 [다운로드](https://www.python.org/downloads/)한다. 웹사이트에는 여러 버전의 파이썬이 존재하는데, 그 중에서 파이썬 3는 `3.x.y` 버전 번호를 가진다. 여기서 `x`는 하위버전을 의미하며, 들어가는 숫자에 따라 인터프리터 기능에 차이가 날 수 있다. 그리고 `y`는 소소한 버그를 수정하는 등의 개정판을 의미하므로, 숫자가 클수록 더 안정된 인터프리터라고 볼 수 있다. 그러므로 인터프리터 버전은 `3.x`까지만 확인해도 충분하다.

> 파이썬 3을 실행하는 인터프리터 버전 3.7.4 및 3.6.4로 예를 들어본다. 만일 버전 3.6에서 3.7로 인터프리터가 업그레이드 되면서 변경된 기능이 있을 시, 두 인터프리터는 동일한 코드를 달리 실행하는 호환성 문제가 발생할 수 있다. 반면, 인터프리터 3.7.1과 3.7.4는 사실상 동일한 인터프리터로 보면 되지만, 오히려 3.7.4 버전이 더 많은 개선이 이루어졌기에 더욱 안정적이다.

개발자는 여러 파이썬 인터프리터 중에서 자신이 필요한 버전을 신중히 선택해야 한다. 이는 다른 라이브러리나 소프트웨어 연동에 큰 영향을 미치기 때문이다. 그러나 단순히 파이썬 프로그래밍 언어 공부를 목적으로 하면 가장 최신 버전을 다운로드 및 설치한다. 단, 인터프리터는 개발 환경 관리를 위해 버전 업데이트 기능이 결여되어 있다; 최신 버전이 새로 출시되었으면 해당 인터프리터를 따로 설치해야 한다.

> 파이썬 중에서 버전 번호가 `2.x.y`로 되어 있는 파이썬을 파이썬 2(Python 2)라고 부른다. 일부 파이썬 강좌나 게시글에서는 파이썬 2를 사용하는 경우가 있으나, 버전 2는 2020년 1월 1일부로 서비스가 종료되었다. 참고로 파이썬 1이라는 것도 존재하나, 가장 최신 버전 1.6.1이 2000년에 출시된 점을 고려하면 현재로써 사용하기에 호환성과 실용성이 매우 떨어진다.
>
> 많은 파이썬 관련 소프트웨어도 버전 3을 위주로 개발되고 있으므로 파이썬 3을 사용하도록 한다.

## 인터프리터 다운로드
다운로드 할 인터프리터를 결정하였으면 설치 방법을 선택해야 한다. 대체로 아래와 같은 설치 항목이 존재한다.

![그림 3. 파이썬 3 공식 웹사이트 인터프리터 다운로드 목록](/images/docs/python/python_interpreter_download.png)

윈도우 OS(예. 윈도우 10, 윈도우 8.1, 윈도우 7 등)에서는 64비트와 32비트 인터프리터를 제공한다. 해당 컴퓨터의 운영체제 및 아키텍처는 아래의 파일 탐색기 주소를 통해 확인할 수 있다.

```
Control Panel\System and Security\System
```

32비트 시스템이면 `Windows installer (32-bit)` 인터프리터를, 64비트면 `Windows installer (64-bit)` 인터프리터를 설치한다.

> 64비트 시스템은 32비트 프로그램과 호환성이 보장되어 `Windows installer (32-bit)` 인터프리터 또한 설치할 수 있다. 하지만 이러한 경우는 대다수 64비트 컴퓨터에서 32비트 프로그램을 개발하던가 연동되는 소프트웨어가 32비트로 제한된 경우이다. 그러므로 아키텍처와 일치하는 인터프리터 설치를 권장한다.

파이썬 인터프리터 설치 방법에는 두 가지가 있다:

1. 압축파일 (embeddable zip file): 파이썬 인터프리터를 구성하는 파일 전체가 압축된 상태로 존재한다.
2. 설치 프로그램 (executable installer): 인터프리터를 설치하는 `.EXE` 확장자 프로그램이다.

> 파이썬 3.7까지 윈도우 32비트 및 64비트 인터프리터는 각각 `x86-64` 및 `x86`으로 표시되어 있다. 그러나 `x86`은 인텔 CPU라는 특정 아키텍처를 가리키기 때문에 ARM CPU를 사용하는 컴퓨터에서는 파이썬 설치가 불가하다. 버전 3.8 이상부터 `x86` 표시가 없어졌으며 인텔 및 ARM CPU 모두 지원한다고 설명되어 있다.

## 인터프리터 설치
다운로드가 완료된 설치 프로그램을 실행하면 아래와 같은 화면이 나타난다.

![그림 4. 파이썬 3 설치 프로그램 실행 화면](/images/docs/python/python_interpreter_install.png)

설치 화면에 있는 "Add Python 3.x to PATH" 옵션은 환경 변수 설정 여부를 의미하며, 윈도우 명령 프롬프트에서 파이썬을 실행할 수 있도록 한다. 다음 그림은 윈도우 명령 프롬프트에서 파이썬을 실행하였을 시의 모습이다.

![그림 5. 윈도우 명령 프롬프트에서 실행된 파이썬 3](/images/docs/python/python_interpreter_cmd.png)

환경 변수 설정은 순수히 파이썬만 사용할 경우 필요가 없으나, 외부 소프트웨어 및 라이브러리와 연동할 경우에는 반드시 필요한 설정이다. 그러므로 본 문서는 환경 변수 설정을 적극 권장한다. 비록 설치 당시에 해당 옵션을 선택하지 않아도, 재설치 없이 설정이 가능하다.

설치 화면의 "Install Now"를 누르면 인터프리터 설치가 진행되며, 설치 완료 시 파이썬을 실행할 수 있게 된다.

### 사용자 지정 설치
파이썬을 다른 경로에 설치하거나 오로지 인터프리터만 설치하고 싶다면 "Customize installation", 즉 사용자 지정 설치 버튼을 클릭하여 설치 내용을 선택할 수 있다. 우선 "Optional Features"는 인터프리터 동작에 영향을 주지 않는 부가적 설치 사항이다.

![그림 6. 파이썬 3 설치 프로그램 추가 설치 사항](/images/docs/python/python_interpreter_optional.png)

| 옵션                  | 설명                                |
|---------------------|-----------------------------------|
| `Documentation`     | 파이썬 문서 파일                      |
| [`pip`](#pip)       | 파이썬 패키지 관리 소프트웨어 |
| `tcl/tk and IDLE`   | 파이썬으로 프로그램 GUI 제작도구와 코드 편집기  |
| `Python test suite` | 파이썬 프로그램 동작을 시험하는 프레임워크      |
| `py launcher`       | 파이썬 인터프리터 관리 프로그램       |

필자의 경우 `pip`와 `py launcher`만은 반드시 체크한다. 나머지 옵션들은 사용하지 않으며, 사용자 인터페이스를 가진 프로그램을 만든다 하더라도 대표적인 GUI 프레임워크 중 하나인 [PySide2](../ko.LIBRARY_Qt)를 사용하기 때문에 `tcl/tk`가 필요하지 않다. 코드 편집기 또한 IDLE보다 편한 것을 곧 소개할 예정이다.

그 다음에 나타나는 "Advanced Options" 선택 사항들은 실질적으로 인터프리터 동작에 영향을 미칠 수 있는 고급 옵션들이다.

![그림 7. 파이썬 3 설치 프로그램 고급 설정](/images/docs/python/python_interpreter_advanced.png)

여기서 `Download debug binaries (requires VS 2015 or later)`를 특히 주목할 필요가 있다. 해당 옵션을 번역하면 "디버깅 라이브러리 다운로드" 여부를 묻는데, 이를 필요로 할 때가 대표적으로 [OpenCV](../ko.LIBRARY_OpenCV) 라이브러리를 생성할 때이다. 만일 파이썬을 프로그래밍 입문 언어로 배우는 초급자이면 신경쓰지 않아도 된다.

## 통합 개발 환경
통합 개발 환경(IDE)은 최소한 프로그래밍 언어의 소스 코드 편집, 프로그램 빌드, 그리고 디버깅 기능을 제공하는 소프트웨어 개발 프로그램이다. 인터프리터는 파이썬 언어를 읽는 소프트웨어이지만, 파이썬 코드 편집기가 아니다. 그러므로 파이썬 코드를 편집하고, 바로 프로그램으로 실행하여 문제가 발생하면 검토할 수 있는 IDE가 절대적으로 필요하다.

### 비주얼 스튜디오 코드
[비주얼 스튜디오 코드](https://code.visualstudio.com/download)(Visual Studio Code; VS Code)는 마이크로소프트에서 개발한 무료 소스 코드 편집기이다. 기술적으로 IDE는 아니지만, 편집기 설정을 통해 IDE 역할을 수행할 수 있다. 파이썬 프로그래밍 언어의 경우에는 파이썬 확장도구 설치 및 인터프리터를 불러오기만 하면 된다.

![그림 8. VS Code에서 파이썬 확장도구 설치](/images/docs/python/python_vscode_extension.png)

파이썬 확장도구는 VS Code를 파이썬 IDE로 사용할 수 있도록 한다. 즉, 소스 코드 편집 이외에도 프로그램 실행 및 디버깅도 가능하다는 의미이다. 확장도구 설치 방법은 다음과 같다: `F1` 키를 눌러 `Extensions: Install Extensions`을 입력하고, 왼쪽에 나타난 검색창에 `Python`을 검색한다. 그러면 위의 그림과 같은 화면이 나타나며, 초록색 `Install` 버튼을 눌러 설치한다.

확장도구 설치 이후, VS Code에서 사용할 파이썬 인터프리터를 선정해야 한다. `F1` 키를 눌러 `Python: Select Interpreter`을 입력하면 이전 단계에서 설치한 파이썬 인터프리터가 자동적으로 검색된다. 원하는 인터프리터를 선택하였으면, 파이썬 프로그래밍 준비는 끝난다.

VS Code에서 파이썬을 실행하는 방법에는 두 가지가 존재한다: 디버그 모드(`F5`)와 일반 실행 모드(`Ctrl+F5`)이다. 프로그램에 문제가 발생하여 하나씩 짚어보아야 할 경우 디버깅 모드를 사용하지만, 그렇지 않은 경우에는 일반 실행 모드를 사용할 것을 권장한다.

# 파이썬: 기초
각 프로그래밍 언어마다 준수되어야 할 규칙과 기반이 되는 데이터들이 존재한다. 이를 어길 시에는 프로그램에 오류가 발생하거나 정상적인 동작을 보장할 수 없다. 실질적인 프로그래밍에 있어, 본 장에서는 파이썬 프로그램 코딩에 기초적인 정보 제공을 목표로 한다.

## 주석
주석(comment)은 프로그래밍에 있어 실행되지 않는 부분이며, 흔히 어떠한 정보를 간략히 스크립트 내에 입력하는데 사용된다. 파이썬에는 두 가지의 주석이 존재하며, 이들은 각각 "한줄 주석"과 "블록 주석"이라 부른다.

* **한줄 주석**
  : 코드 한 줄을 차지하는 주석이며, 해시 기호(`#`)로 표시된다.
* **블록 주석** (일명. **독스트링**)
  : 코드 여러 줄을 차지하는 주석이며, 세 쌍의 작은 따옴표(`''' '''`) 혹은 큰 따옴표(`""" """`)로 표시된다. 그 중에서 큰 따옴표로 구성된 독스크링(docstrings)은 프로그램 실행 도중에도 볼 수 있다.

```python
"""
블록 주석:
코드 여러 줄을 차지하는 주석이며, 프로그램 실행 중에서도 볼 수 있다.
"""
# 한줄 주석: 코드 한 줄을 차지하는 주석이다.
```

## 입력 & 출력
파이썬은 다음과 같은 텍스트 기반의 입력 및 출력 함수를 가진다.

* **입력 함수 `input()`**: 입력 함수가 실행될 시, `input()`의 소괄호(`()`) 안에 있는 텍스트가 터미널에 나타나며 Enter/Return을 누를 때까지 대기한다.
* **출력 함수 `print()`**: 출력 함수가 실행될 시, `print()`의 소괄호(`()`) 안에 있는 데이터가 터미널에 나타난다.

```python
variable = input("입력: ")
print("출력:", variable)
# 동일: print("출력:", input("입력: "))
```

```
입력: Hello World!
출력: Hello World!
```

하나의 `print()` 함수에서 두 가지 이상의 데이터를 한꺼번에 출력하는 데 세 가지의 방법이 존재한다.

1. 쉼표(`,`)를 사용하여 연속적으로 데이터를 나열할 수 있으나, 쉼표에는 항상 공백이 놓여진다.

   ```python
   A = 10.0
   B = "파이썬"
   
   # 문자열과 정수의 혼합된 데이터를 쉼표(,)를 사용해 나열한다.
   print("A는", A , ", \n그리고 B는", B, "이다.")
   ```

   ```
   A는 10.0 ,
   그리고 B는 파이썬 이다.
   ```

2. 더하기 기호(`+`)를 문자열 연결에 사용하면 사이에 공백이 생기지 않는다. 그러나 문자열 자료형이 아닌 데이터는 우선 문자열로 변환해야 한다.

   ```python
   A = 10.0
   B = "파이썬"
   
   # 문자열과 정수의 혼합된 데이터를 문자열 변환 이후 더하기 기호(+)를 사용해 나열한다.
   print("A는", str(A) + ", \n그리고 B는", B + "이다.")
   ```

   ```
   A는 10.0,
   그리고 B는 파이썬이다.
   ```

3. 문자열 따옴표 앞에 `f` 접두사를 붙이면 중괄호(`{}`) 안에 입력된 데이터가 문자열에 그대로 반영된다. 데이터를 문자열로 변환할 필요가 없다.

   ```python
   A = 10.0
   B = "파이썬"
   
   # 문자열에 'f' 접두사를 붙여 지정된 위치에 데이터를 문자열에 그대로 반영시킨다.
   print(f"A는 {A}\n그리고 B는 {B}이다.")
   ```

   ```
   A는 10.0,
   그리고 B는 파이썬이다.
   ```

## 식별자
식별자(identifier)는 프로그래밍을 구성하는 데이터들을 구별하기 위해 사용되는 명칭이다. 간단히 말해, 식별자는 개발자가 데이터에 직접 붙여준 이름이다. 파이썬에서 식별자를 선정하는데 아래의 규칙을 지켜야 한다.

* 오직 영문, 숫자, 밑줄(`_`)만 허용된다.
* 첫 문자는 숫자로 시작할 수 없다.
* 공백은 허용되지 않는다.

## 변수
변수(variable)는 할당 기호(`=`)를 사용하여 데이터를 할당할 수 있는 저장공간이다. 변수 또한 이름을 가지는데, 아래의 예시에서 변수는 `variable`이란 식별자를 가지며 `1`이란 값을 할당받는다.

```python
variable = 1
```

거의 모든 프로그래밍 언어는 할당 연산자를 기준으로 왼쪽에는 피할당자(변수), 오른쪽에는 할당자(데이터 혹은 변수)를 놓는다. 반대로 위치시키면 오류가 발생하거나 원치 않는 결과가 도출될 수 있다.

파이썬의 변수는 데이터 종류와 상관없이 새로운 데이터를 언제든지 할당받을 수 있다.

```python
variable = 1
variable = "Hello World!"
print(variable)
```

### 초기화
초기화(initialization)란, 변수의 첫 데이터 할당(assignment)을 가리킨다.

```python
# variable 변수가 할당받은 값 1이 최초의 저장값이면, 변수는 1로 "초기화"되었다고 한다.
variable = 1
```

### 지역 변수 & 전역 변수
파이썬은 크게 두 종류의 변수로 나뉘어진다.

* **지역 변수(local variable)**는 함수(function)나 클래스(class)와 같은 코드 블록 내부에서 정의된 변수이다. 단, 이는 조건문이나 반복문, `with` 문 등 일부 경우에는 적용되지 않을 수 있다. 지역 변수에 저장된 데이터는 코드 블록 밖에서는 소멸되므로 외부에서 사용할 수 없다. 그러므로 지역 변수는 외부에서 정의된 변수의 이름을 가질 수 있다.

* **전역 변수(global variable)**는 스크립트 내에서 어떠한 코드 블록에도 속하지 않은 외부에 정의된 변수이다. 코드 블록 내부에 있는 지역 변수와 함께 사용하기 위해서는 `global` 키워드를 사용한다.

### 상수
상수(constant)는 한 번 데이터를 할당한 후 변경할 수 없는 특별한 변수이다. 그러나 파이썬에는 상수란 존재하지 않는다. 파이썬 개발자는 변수에 할당된 데이터를 실수로 변경하지 않도록 주의할 수 밖에 없다. 파이썬에서는 상수를 통상적으로 전부 대문자로 표기한다.

```python
CONSTANT_VARIABLE = "Hello World!"
```

### `del` 키워드
`del` 키워드는 변수를 삭제 할 때 사용한다. 삭제된 변수 이름은 나중에 다시 사용될 수 있다.

```python
# 변수의 정의
variable = "파이썬"
print(variable)

# 변수 "variable" 삭제
del variable
print(variable)
```

```
파이썬
NameError: name 'variable' is not defined
```

## 자료형
파이썬은 기본적으로 세 가지의 데이터 유형이 존재한다: 숫자, 논리, 그리고 문자열 자료형(data type)으로 구분된다. 한편, 데이터 처리 및 방식을 연산(operation)이라 부르며, 아래의 세 데이터는 연산 기능을 가진다.

* **연산자(operator)**
  : 사칙 연산자(예. `+`, `-`, `*`, `/`)와 같이 피연산자의 값을 조작하는 데 사용되는 코드이다. 간단히 피연산자의 접두부, 접미부 혹은 두 피연산자 사이에 배치하여 사용한다.
* **함수(function)**
  : 실행하고자 하는 기능을 이름으로 호출하여 재사용이 가능한 코드 조각이다. 함수는 `function()`과 같이 이름 접미사에 소괄호(`()`)를 가지므로써 연산자와 구별할 수 있다.
* **메소드(method)**
  : 특정 데이터에 종속되어 있는 함수이다. 메소드 또한 `object.method()`와 같이 이름 접미사에 소괄호(`()`)가 있지만 항상 앞에 `.`이 있어 종속된 데이터와 함께 표기되어야 한다.

비록 [함수](#파이썬-함수)와 [메소드](#파이썬-객체-및-클래스)는 후반부에 소개될 예정이지만, 이 세 가지의 주요 차이점을 인지하는 것은 프로그래밍 언어의 개념을 전반적으로 이해하는 데 있어서 혼동을 줄이는 데 도움을 준다.

### 숫자 자료형
숫자 자료형(numeric data type)은 숫자로 구성된 데이터로 세 가지의 분류로 나뉘어진다.

| 키워드    | 자료형                | 설명                                                         |
|:---------:|:---------------------:| ------------------------------------------------------------ |
| `int`     | 정수               | 32 비트 정밀 정수 |
| `float`   | 부동소수점수 | 소수점을 포함한 실수 |
| `complex` | 복소수        | 부동 소수와 허수의 합 |

가장 흔히 사용되는 숫자 자료형으로는 `float`가 있으며 `complex` 외에 분수를 표현할 수 있는 가장 작은 자료형이다. `float`는 다음과 같은 특징을 가진다.

* 소수점 끝에 있는 추가 숫자 0은 무시된다.
* 다음 계산은 자동적으로 `float` 자료형을 반환한다:
  * `float`를 하나라도 포함한 연산
  * `int`의 나눗셈 연산

```python
print(9.8765000)
print(4 ** 2.0)
print(4 + 1.0)
```

```
9.8765
16.0
5.0
```

파이썬에는 다음과 같은 숫자 자료형의 산술 연산이 존재한다. 

| 이름                           | 연산자 | 설명                                                         |
| :------------------------------: | :----: | ------------------------------------------------------------ |
| 덧셈                       |  `+`   | -                                                            |
| 뺄셈                    |  `-`   | 파이썬은 뺄셈이 없다. 그 대신, 해당 기호는 음수를 의미하며, 수학적으로도 음수를 더하는 것은 뺄셈과 동일하다. |
| 곱셈                 |  `*`   | -                                                            |
| 제곱                    |  `**`  | -                                                            |
| 나눗셈                       |  `/`   | 나눗셈을 할 시, 값은 자동적으로 `float` 자료형으로 변환된다. |
| 몫 |  `//`  | 나눗셈에서 나머지를 제외한 몫만 도출한다.    |
| 나머지                      |  `%`   | 나눗셈에서 몫을 제외한 나머지만 도출한다.                         |

산술 연산을 쉽게 읽을 수 있도록 숫자 사이에 공백을 넣어도 된다. 이 공백은 숫자나 수학 연산에 아무런 영향을 주지 않는다.

숫자 자료형에 국한된 함수 및 메소드를 사용하여 추가적인 연산을 수행할 수 있다. 아래의 대부분 연산은 *리스트(list)*라는 [이터러블](#파이썬-이터러블)(iterable) 객체가 필요하며, 해당 객체는 이후에 소개될 예정이다.

| 함수      | 예시                | 설명                                                         |
|:---------:| ------------------- | ------------------------------------------------------------ |
| `abs()`   | `abs(-21)`          | 숫자의 절댓값을 구한다.                       |
| `round()` | `round(164.2597,2)` | 기본적으로 한 자릿수로 숫자를 반올림하거나 뒤의 소수 자릿수로 반올림한다. |
| `max()`   | `max([0,1,2,3,4])`  | 리스트 객체 내에서 가장 큰 숫자를 반환한다.                              |
| `sum()`   | `sum([0,1,2,3,4])`  | 리스트 객체 내에에서 숫자를 모두 더한다.                             |

```python
# "round()" 함수의 예시
print(round(164.259763145))
print(round(164.259763145,2))
```

```
164
164.26
```

할당 연산자는 산술 기호와 할당 기호(`=`)의 조합으로, 숫자 계산 코드를 보다 간결하게 작성할 수 있도록 한다.

| 연산자 | 예시     | 동일                                          |
| :----: |--------| --------------------------------------------- |
|  `=`   | `x = y`  | `x = y`; `x` 변수에 `y` 변수의 값을 할당한다. |
|  `+=`  | `x += y` | `x = x + y`                                   |
|  `-=`  | `x -= y` | `x = x - y`                                   |
|  `*=`  | `x *= y` | `x = x * y`                                   |
|  `/=`  | `x /= y` | `x = x / y`                                   |
|  `%=`  | `x %= y` | `x = x % y`                                   |

파이썬 프로그래밍 언어에는 증감 연산자(`++` 그리고 `--`)가 존재하지 않는다.

### 논리 자료형
논리 자료형(Boolean data type)은 문장이 참인지 거짓인지 판별하는 논리 조건에 사용되는 데이터 유형이다.

| 값             | 이름            | 설명                          |
|:--------------:|:---------------:| ----------------------------- |
| `True`  | 논리적 참  | 논리가 참일 때 반환된다.  |
| `False` | 논리적 거짓 | 논리가 거짓일 때 반환된다. |

논리값은 숫자 자료형으로도 표현이 가능하며, 정수형 1과 0은 각각 논리형 `True`와 `False`로 대체된다. 그러나 그 외의 정수는 어떠한 논리형 값으로도 표현되지 않는다.

비교 연산자는 두 개의 데이터 관계를 비교하는데 사용되며, 조건이 참인지 거짓인지 여부에 따라 해당하는 논리값을 반환한다.

| 미만 | 이하 | 동일 | 상이 | 이상 | 초과 |
|:----:|:----:|:----:|:----:|:----:|:----:|
| `<`  | `<=` | `==` | `!=` | `>=` | `>`  |

한편, 논리 자료형은 논리합, 논리곱, 및 보수 연산이 가능하다.

| 연산자 | 이름           | 설명                                                    |
| :----: |:--------------:| ------------------------------------------------------- |
|  `is`  | 동등    | 두 데이터 사이의 논리 판단자이며, `==`와 유사하다.  |
| `and`  | 논리곱 | 모든 인수가 `True`이면 `True`이고, 그렇지 않으면 `False`이다.      |
|  `or`  | 논리합  | 하나 이상의 인수가 `True`이면 `True`이고, 그렇지 않으면 `False`이다.   |
| `not`  | 보수     | `True`를 `False`로 변경 혹은 `False`를 `True`로 변경한다.     |

### 문자열 자료형
문자열 자료형(string data type)은 한 쌍의 작은 따옴표(`''`) 또는 큰 따옴표(`""`)로 구별되는 텍스트 데이터이다. 문자열 자료형 데이터는 일반적으로 *문자열 객체*라고 부른다. 문자열 데이터에 따옴표를 넣을 시, 해당 따옴표 앞에 백슬래시(`\`)를 배치하여 문자열이 도중이 끊기는 문제를 방지한다.

```python
# 문자열 작성의 부적절한 예시와 적절한 예시의 비교.
print('Where's my "Cat in the Hat" book?')
print('Where\'s my "Cat in the Hat" book?')
```

```
Where
Where's my "Cat in the Hat" book?
```

세 쌍의 작은 따옴표 혹은 큰 따옴표는 다중 문자열(multi-line string) 객체를 생성하는데, 이는 단순히 Enter/Return 키를 눌러 줄바꿈이 가능한 문자열이다. 이를 사용하지 않을 시, 줄바꿈은 `\n`을 직접 삽입해야 한다.

```python
# 다중 문자열 객체로 여러 줄의 텍스트 작성 및 출력.
print("Hello\nWorld!")
print("""Hello
World!""")
```

```
Hello
World!   
Hello
World!
```

파이썬의 문자열 객체는 숫자 자료형처럼 덧셈과 곱셈이 가능하다.

| 연산자 | 이름           | 설명                                                         |
|:--------:|:----------------:|---------------------------------------------------------------------|
| `+`      | 연결  | 서로 다른 두 문자열을 하나의 문자열에 병합한다 (따옴표 유형은 중요하지 않다).  |
| `*`      | 곱셈 | 문자열을 정수 값만큼 곱한다 (`float` 사용 불가). |

```python
print("파이" + '썬3')
print(4 * "2")
```

```
파이썬3
2222
```

문자열은 변수와 함수가 하나의 데이터로 통합된 독립적 존재, 즉 "객체(object)"이다. 그러므로 이전 두 자료형에는 소개되지 않은 고유의 메소드 연산을 가진다.

| 메소드            | 예시                        | 설명                                                                                                                   |
|:--------------:|---------------------------|----------------------------------------------------------------------------------------------------------------------|
| `format()`     | `text.format(value)`     | 문자열 또는 비문자열 `value`를 지정된 `{}` 공간에 위치별 혹은 이름별로 할당한다.                                                                  |
| `join()`       | `text.join(str_list)`     | 문자열로 이루어진 리스트 객체인 `str_list` 내의 문자열들 사이에 `text` 문자열을 삽입하여 하나의 문자열로 결합한다.                                             |
| `split()`      | `text.split()`            | 괄호 안에 문자열이 없는 경우, 공백에 따라 `text` 문자열을 구분하여 리스트 객체로 변환한다.<br/>*[선택사항: 괄호 안에 `str1`이 존재하면 `text`는 `str1`을 기준으로 나뉘어진다.]* |
| `replace()`    | `text.replace(str1,str2)` | `text` 문자열 내에서 `str1`을 `str2`로 바꾼다.                                                                                  |
| `startswith()` | `text.startswith()`       | `text` 문자열 시작 부분의 동등성을 확인한다.                                                                                         |
| `endswith()`   | `text.endswith()`         | `text` 문자열 끝 부분의 동등성을 확인한다.                                                                                          |
| `upper()`      | `text.upper()`            | `text` 문자열의 모든 영문을 대문자로 변환한다.                                                                                        |
| `lower()`      | `text.lower()`            | `text` 문자열의 모든 영문을 소문자로 변환한다.                                                                                        |

```python
# 문자열 형식: [1] 위치별 및 [2] 이름별 할당.
print("{2} {0} {1}".format(value1, value3, value2))
print("{x} {y} {z}".format(x = value1, y = value3, z = value2))

# 문자열 연결 및 분리
print(" ! ".join([str1, str2, str3]))
print("str1 ! str2 ! str3".split(" ! "))

# 문자열 확인
print("This is a sentence.".startswith("this"))
print("This is a sentence.".endswith("sentence."))

# ALPHABET UPPER/LOWERCASE
print("This is a SENTENCE.".upper())
print("This is a SENTENCE.".lower())
```

```
value2 value1 value3
value1 value3 value2

str1 ! str2 ! str3
[str1, str2, str3]

False       # 대문자 "T"와 소문자 "t"는 다른 존재이므로 거짓이다.
True        # 맨 마지막에 온점을 포함하여 참이다.

THIS IS A SENTENCE.
this is a sentence.
```

### 자료형 변환
데이터는 다른 자료형으로 변환될 수 있으며, 아래의 세 가지 함수를 사용한다.

| 함수      | 이름              | 설명                                                         |
|:---------:|:-----------------:| ------------------------------------------------------------ |
| `int()`   | 정수 변환         | `float`: 분수는 제거되고 정수만 반환.<br />`string`: 숫자만 변환 및 반환 가능. |
| `float()` | 부동소수점수 변환 | `int`: 제약없음.<br />`string`: 숫자만 변환 및 반환 가능. |
| `str()`   | 문자열 변환       | `int`: 제약없음.<br />`float`: 제약없음.                     |

## 탈출 문자
탈출 문자(escape character)는 백슬래시 기호(`\`)를 사용하며, 문자열로부터 탈출하여 텍스트 데이터 내에서 특정 연산을 수행하도록 한다. 문자열 자료형을 소개할 때 문자열 줄바꿈을 위해 `\n` 탈출 문자를 사용하였다.

```python
print("Hello\nWorld!")
```
```
Hello
World!
```

| 줄바꿈 | 탭 | 백슬래시 | 백스페이스 | 작은 따옴표 | 큰 따옴표 |
|:----:|:----:|:----:|:---:|:----:|:----:|
| `\n` | `\t` | `\\` | `\b` | `\'` | `\"` |

문자열에서 탈출하여 연산을 수행하는 이외에도, 탈출 문자는 하나의 긴 문장을 연속의 다수 짧은 문장으로 재구성하는 데 사용할 수 있다.

## `None` 키워드
자료형에 관계없이 아무런 값이 없는 데이터이다. 비록 논리 조건에서는 `None`을 `False`으로 사용할 수 있지만, 개념적으로는 `None`과 `False`는 완전히 다른 존재이다.

```python
# 조건부 확인: 논리 조건에서 None을 False로 간주할 수 있는가?
if not(None and True):
    print(None)
```

```
None                    # 이는 논리 조건에서 None을 False로 사용할 수 있음을 보여준다.
```

# 파이썬: 조건 및 루프
조건문 및 반복문(혹은 루프문)은 프로그래밍에 가장 흔히 사용되는 코드 문장(statement) 중 하나이다. 여기서 문장이란, 실질적으로 무언가를 실행하는 코드를 의미한다. 본 장에서는 파이썬 프로그래밍의 조건에 따라 실행하는 조건문(conditional statement)과 반복적으로 실행하는 반복문(loop statement)을 소개한다.

## 들여쓰기
들여쓰기(indentation)는 문장이나 함수, 클래스 등에 사용되며, 해당되는 코드 블록의 경계를 표시하는 데 사용된다. 즉, 본 장에서 들여쓰기는 코드가 어느 조건문 혹은 반복문에 속하는지 구분한다. 들여쓰기는 콜론(`:`)이 시작되는 이후부터 삽입된다.

들여쓰기의 여부에 따라 코드의 내용이 완전히 변경될 수 있으므로 주의해야 한다.

```python
# 두 번째 "print()" 함수에 들여쓰기 된 경우.
if False:
    print("본 문장은 거짓이다.") 
    print("조건문 종료.")
print("끝!") 

# 두 번째 "print()" 함수에 들여쓰기가 되지 않은 경우.
if False:
    print("본 문장은 거짓이다.") 
print("조건문 종료.")
print("끝!") 
```

```
끝!

조건문 종료.
끝!
```

## `if` 조건문
`if` 조건문은 조건이 참일 경우 코드를 실행한다. 조건이 `True`일 때 문장이 수행되지만 그렇지 않으면 무시된다.

```python
if condition:
    statements
```

### `else` 조건문
`else` 조건문은 단독으로 사용될 수 없으며 반드시 `if` 조건문 이후에 사용되어야 한다. 실행문에는 조건부가 `False`로 평가되었을 경우 호출되는 코드가 포함되어 있다.

```python
if condition:
    True_statement
else:
    False_statement
```

`if` 조건문과 `else` 조건문을 다음과 같이 조건의 연속을 연쇄적으로 사용할 수 있다:

```python
if condition1: 
    statements
else:
    if condition2:
        statements
    else:
        statements
```

### `elif` 조건문
`elif` 조건문은 `else`와 `if` 조건문의 조합으로 첫 번째 조건이 거짓일 경우, 첫 번째 조건과 다른 새로운 조건을 제시한다.

```python
if condition1: 
    statements
elif condition2:
    statements
else:
    statements
```

하지만 우선 소개된 `else`-`if` 연쇄 조건문은 두 조건부가 함께 사용되는 점과 비교해 `elif` 조건문은 여전히 하나의 조건부에서 처리되므로, 이 둘은 구체적으로 서로 다른 조건문임을 명시해야 한다.

### 조건 연산자
조건문은 아래와 같이 조건 연산자(ternary operator)를 사용하여 간략히 표현될 수 있다.

```python
True_return if condition else False_return
```

조건 연산자는 영어로 *ternary operator*로, 이는 세 가지 인수를 사용하는 것을 의미한다. 조건 연산자는 가독성을 감소시키므로 과용해서는 안되지만 변수 할당에는 유용하다.

## `while` 반복문
`while` 반복문은 조건이 유지되는 한 내부 코드를 반복적으로 실행한다. 조건이 `False`임이 판정되면 반복문을 종료한다.

```python
while condition:
    statements
```

`else` 조건문은 `while` 반복문 뒤에 따라올 수 있으며, 이는 반복문이 조건부에 의해 정상적으로 종료되었을 때만 실행된다.

```python
# 루프 종료: 반복 완료
while var < 10:
    var += 1
    if var is 100:
        break
    else:
        print("첫 번째 반복문...완료!")

# 루프 종료: 탈출문으로 강제 처리
while var < 10:
    var += 1
    if var is 5:
        break
    else:
        print("두 번째 반복문...완료!")
```

```
첫 번째 반복문...완료!
```

### `break` 문
`break` 문(일명 탈출문)은 반복이 완료되기 전에 루프를 조기 종료하는데 사용된다. 루프 내부에서 탈출문을 마주치는 즉시 현재 루프에서 탈출하지만 그 바깥 루프로부터는 탈출하지 않는다.

```python 
while single_loop_condition:
    statement1
    statement2
    break
    statement3
```

```
statement1
statement2
```

### `continue` 문
`continue` 문은 반복문 내에서 나머지 실행문을 전부 건너뛰고 다시 조건 판정부분으로 돌아가게 한다. 이는 반복문을 종료하는 `break` 문과 달리 반복문의 루프를 유지한다.

```python 
while var < 5:
    statement1
    statement2
    continue
    statement3
```

```
statement1
statement2
statement1
statement2
statement1
statement2
...
```

## `for` 반복문
`for` 반복문은 유효한 범위에 있는 한 내부 코드를 반복적으로 실행한다. 범위 내의 모든 값이 반복되면 반복문을 종료한다.

```python
for index in iterable:
    statements
```

여기서 지역 변수 `index`는 `iterable`에서 값을 얻고, 내부의 실행문은 더이상 불러올 값이 없을 때까지 하나씩 반복한다. 흔히 반복문에 사용되는 `iterable` 데이터는 다음과 같다.

1. 범위 객체: 숫자를 순서대로 담고있는 객체이다 (*파이썬: 이터러블 객체 § 범위 객체* 참고)
2. 리스트 객체: 자료형과 순서에 상관없이 데이터를 담고있는 객체이다 (*파이썬: 이터러블 객체 § 리스트 객체* 참고).
3. 문자열 객체: 문자열을 구성하는 문자를 반환한다.

```python
for index in range(3):
    print("Hello World" , index)
```

```
Hello World 0
Hello World 1
Hello World 2
```

`while` 반복문과 마찬가지로, 코드를 반복적으로 실행하는 `for` 문에서도 `break`와 `continue` 문을 사용할 수 있다.

`else` 조건문은 `for` 반복문 뒤에 따라올 수 있으며, 이는 반복문이 범위 내에서 더 이상 호출할 값이 없음에 의해 정상적으로 종료되었을 때만 실행된다.

```python
# 루프 종료: 반복 완료
for index in range(10):
    if index is 100:
        break
    else:
        print("첫 번째 반복문...완료!")

# 루프 종료: 탈출문으로 강제 처리
while index in range(10):
    if index is 5:
        break
    else:
        print("두 번째 반복문...완료!")
```

```
첫 번째 반복문...완료!
```

## `pass` 키워드
`pass` 혹은 `...` 키워드는 실행될 때 아무 작업도 수행하지 않는다. 코드 블록이 아직 작성하지 않은 상태에서 임시 코드로 사용된다.

# 파이썬: 이터러블
파이썬의 유용함은 단순함 이외에도 다른 프로그래밍 언어에서 볼 수 없는 강력하고 유연한 이터러블 객첵에서 비롯된다. 본 장에서는 파이썬이 가지는 네 개의 다른 특성의 이터러블 객체를 소개한다.

## 이터러블 객첵
이터러블(iterable; 반복 가능한) 객체는 여러 데이터를 한꺼번에 저장하는데 사용되며, 반복자(iterator) 객체를 반환하는 `__iter__` 메소드를 보유하는 객체로 정의된다. 반복자 데이터의 다음 요소를 자동으로 호출하는 객체로, 이터러블 객체 내의 모든 데이터를 순차적으로 불러올 수 있도록 한다.

## 시퀀스 객체
시퀀스(sequence) 객체는 추가 기능이 활성화된 이터러블 객체이며, 대표적으로 구간을 나누는 슬라이싱(slicing) 기능이 있다. 시퀀스는 하나는 대괄호(`[]`)을 사용하여 저장된 데이터 불러오거나 수정이 가능하다. *파이썬: 기초 § 문자열 자료형*에 도입된 문자열 객체도 시퀀스 객체 중 하나이다.

```python
variable = "Hello World!" 
print(variable[1])
```

```
e
```

### 시퀀스 슬라이싱
슬라이싱(slicing; 자르다)은 시퀀스 객체를 처리하는 데 있어 다른 프로그래밍 언어보다 뛰어난 파이썬의 강점 중 하나이다. 시퀀스 객체의 슬라이싱을 통해 원본으로부터 원하는 부분만을 추출할 수 있다.

| 구문    | 예시                            |
|:---------:|------------------------------------|
| `[ : : ]` | `sequence[start : end : interval]` |

슬라이싱은 `start`에서부터 `end` 이전까지이며, `interval`만큼의 간격으로 데이터를 추출한다. 시퀀스 슬라이싱을 위해 위의 세 인수를 전부 채울 필요는 없다.

```python
variable = "Hello World!"
print(variable[2:8])     # >> 출력: "llo Wo"

# 시작 혹은 끝만 지정한 리시트 슬라이싱
print(variable[2: ])     # >> 출력: "llo World!"
print(variable[ :8])     # >> 출력: "Hello Wo"

# 간격을 통해 일부 데이터를 뛰어넘어 슬라이싱
print(variable[ : :2])   # >> 출력: "HloWrd"
print(variable[2:8:2])   # >> 출력: "oW"

# 역방향 슬라이싱
print(variable[8:2:-1])  # >> 출력: "roW ol"
```

## 범위 객체
범위(range) 시퀀스 객체는 시작할 숫자(포함), 끝을 맺을 숫자(제외) 그리고 순서 간격을 지정하여 일련의 숫자들을 순서에 맞게 저장하는 객체이다. 범위 객체는 `range()` 함수를 사용하여 생성된다.

| 함수        | 예시                          | 설명                                                          |
|-----------|-----------------------------|-------------------------------------------------------------|
| `range()` | `range(start,end,interval)` | 정수 `start`에서부터 `end` 이전까지 `interval`만큼의 간견으로 순서대로 숫자를 나열한 범위 객체를 생성한다. |

```python
rng = range(3, 10, 2)

rng[0]        # >> 출력: 3
rng[1]        # >> 출력: 5
rng[2]        # >> 출력: 7
rng[3]        # >> 출력: 9
```

## 리스트 객체
리스트(list) 시퀀스 객체는 데이터 유형과 관계없이 인덱스(index) 위치에 따라 데이터를 저장한다. 리스트의 데이터 할당은 대괄호(`[]`) 내에 항목을 순서대로 쉼표로 나누어 나열한다. 또한 대괄호는 인덱스 위치의 요소(element)를 호출하는 데에도 사용된다.

```python
lst = [value1, value2, value3, value4, ...]

print(lst)           # >> 출력: [value1, value2, value3, value4, ...]
print(lst[0])        # >> 출력: value1
```

개별 요소를 재할당하여 데이터를 변경할 수 있다. 리스트 범위를 벗어난 요소를 호출할 수 없으므로, 이러한 경우 오류가 발생한다.

```python
lst = [value1, value2, value3]

lst[1] = value4        # >> 결과: lst = [value1, value4, value3]
lst[3] = value5        # IndexError: list assignment index out of range
```

리스트 객체는 **리스트 컴프리헨션(list comprehension)**라는 프로그램적 규칙을 따르는 일련화 방법으로 생성될 수 있다. 이를 위해서 `for` 반복문과 선택사항인 `if` 조건문을 사용하여 구현할 수 있다.

| 구문          | 예시                                          |
|:-----------------:|--------------------------------------------------|
| `[ for in if ]` | `[element for variable in sequence if condition]` |

리스트 객체를 구성하는 `element`는 `sequence` 객체 내에서 `condition` 조건에 부합한 항목을 넘겨받은 `variable`의 값을 할당받는다. `if` 조건문은 리스트 컴프리헨션에 있어 선택사항이다.

```python
lst = [var**2 for variable in range(5)]
lst = [var**2 for variable in range(5) if (variable ** 2) % 2 == 0]
```

```
[0, 1, 4, 9, 16]
[0, 4, 16]
```

### 리스트 연산
리스트는 고유의 연산을 통해 항목을 추가하거나 곱할 수가 있다. 아래의 연산들은 리스트 객체에만 제한되지 않으며, 차후에 소개될 다른 시퀀스 객체에도 적용이 가능하다.

| 연산자 | 이름           | 설명                                                         |
|:------:|:--------------:| ------------------------------------------------------------ |
| `+`    | 덧셈    | 서로 다른 두 리스트 객체를 하나의 리스트로 통합한다.          |
| `*`    | 곱셈    | 리스트 항목을 정수만큼 반복한다 (`float` 사용 불가). |
| `in`   | 포함       | 해당 항목이 리스트에 있는지 확인한다.                               |

```python
lst = [value1, value2, value3]

# + 연산자
print(lst + [value3, value4])      # >> 출력: [value1, value2, value3, value3, value4]

# * 연산자
print(lst * 2)                     # >> 출력: [value1, value2, value3, value1, value2, value3]

# in 연산자
print(value1 in lst)               # >> 출력: True
print(value2 not in lst)           # >> 출력: False
```

다음은 리스트 객체(광범위적으로 시퀀스 객체)에 관한 특정 기능을 수행하는 함수들이다:

| 함수          | 예시                                | 설명                                                         |
|:-------------:| ----------------------------------- | ------------------------------------------------------------ |
| `len()`       | `len(lst)`                     | 리스트 `lst` 내의 요소 개수(혹은 리스트 길이)를 확인한다. |
| `all()`       | `all([condition for var in lst])` | 리스트 `lst`의 모든 요소가 `condition` 조건에 부합하면 `True`를 반환한다. |
| `any()`       | `any([condition for var in lst])` | `lst`의 최소 한 요소가 `condition` 조건에 부합하면 `True`를 반환한다. |
| `enumerate()` | `enumerate(lst)` | `lst` 내의 데이터를 해당 인덱스 번호와 함께 나열한다. |
| `list()`      | `list(iterable)`             | 문자열이나 범위와 같은 `iterable` 객체를 리스트 객체로 변환한다; 만일 `iterable`이 없을 시 빈 리스트 객체를 생성한다. |

```python
lst = [10, 9, 8, 7, 6]

# "all()" 함수
if all( [variable > 5 for variable in lst] ):
    print("숫자는 모두 5보다 크다.")           # >> 출력: 숫자는 모두 5보다 크다.

# "any()" 함수
if any( [variable % 2 ==  0 for variable in lst] ):
    print("최소 하나의 숫자는 짝수이다.")       # >> 출력: 최소 하나의 숫자는 짝수이다.
    
# "enumerate()" 함수
for variable in enumerate(lst):
    print(variable)                           # >> 출력: (0,10)
                                              # >>       (1,9)
                                              # >>       (2,8)
                                              # >>       (3,7)
                                              # >>       (4,6)
```

리스트는 (시퀀스) 객체이므로 특정 기능을 수행하는 메소드 또한 가지고 있다.

| 메소드     | 예시                        | 설명                                                       |
|:----------:| -------------------------- | ---------------------------------------------------------- |
| `append()` | `lst.append(value)`        | `value`를 `lst`의 맨 끝에 추가한다.                          |
| `insert()` | `lst.insert(index, value)` | `value`를 `lst`의 `index` 위치에 추가한다.                   |
| `index()`  | `lst.index(value)`         | `value`가 위치하는 가장 작은 인덱스 값을 반환한다.             |

## 튜플 객체
튜플(tuple) 시퀀스 객체는 리스트와 마찬가지로 항목을 순서대로 저장하는 데이터이나, 초기화 후에는 값을 변경할 수 없다. 이러한 시퀀스 객체의 속성을 불변(immutable)이라고 한다. 튜플을 초기화 할 때 소괄호(`()`)를 사용하거나 괄호 없이 사용할 수도 있다.

```python
tpl = (value1, value2, value3)
print(tpl)           # >> 출력: (value1, value2, value3)
print(tpl[0])        # >> 출력: value1

# 대안: 소괄호 없이 초기화된 튜플
tpl = value1, value2, value3
print(tpl)           # >> 출력: (value1, value2, value3)
print(tpl[0])        # >> 출력: value1
```

튜플은 리스트 객체의 상수 버전이므로 내부 항목은 변경이 불가능하다. 이를 시도할 경우 오류가 발생한다.

```python
tpl = (value1, value2, value3)
tpl[1] = value4
```

```
TypeError: 'tpl' object does not support item assignment
```

튜플의 연산은 *파이썬: 이터러블 § 리스트 연산*에서 언급된 연산자, 함수, 그리고 메소드를 참고한다. 

### 튜플 언패킹
튜플을 언패킹한다는 것은 튜플의 각 요소를 변수나 또다른 튜플에 할당하는 것을 의미한다. 변수 접두부에 별표(`*`)을 넣으면 남은 요소들을 할당도 함께 받아 리스트 객체가 된다. 이에 대한 보조설명은 *파이썬: 함수형 프로그래밍 § 매개변수 및 전달인자*에서 확인할 수 있다.

```python
var1, var2, *var3, var3 = [value1, value2, value3, value4, value5]

print(var1)        # >> 출력: value1
print(var2)        # >> 출력: value2
print(var3)        # >> 출력: [value3, value4]
print(var3)        # >> 출력: value5
```

## 딕셔너리 객체
딕셔너리는 인덱싱 키(key) 데이터와 값(value) 데이터를 단일 요소로 쌍을 이루는 (시퀀스가 아닌) 이터러블 객체이다. 딕셔너리의 값은 해당하는 키를 통해 호출한다. 딕셔너리는 중괄호(`{}`)를 사용하여 초기화된다.

```python
dictionary = {key1: value1, key2: value2, key3: value3}

print(dictionary[key1])        # >> 출력: value1
print(dictionary[key2])        # >> 출력: value2
print(dictionary[key4])        # KeyError: key4
```

리스트와 딕셔너리와 같이 재할당이 가능한 이터러블 객체는 딕셔너리의 키로 사용될 수 없다. 하지만 해당 객체들은 여전히 딕셔너리의 값으로 사용될 수 있다.

```python
dictionary = {lst1: value1, key2: value2}
```

```
TypeError: unhashable type: 'list'
```

딕셔너리 내의 키에 할당된 값을 변경할 수 있다. 리스트 객체와 달리 새로운 키를 생성하고 값를 할당하는 것도 함수나 메소드 도움 없이 가능하다.

```python
dictionary = {key1: value1, key2: value2, key3: value3}
dictionary[key1] = value4
dictionary[key5] = value5
```

```
{key1: value1, key2: value2, key3: value3, key5: value5}
```

딕셔너리의 연산은 시퀀스 객체의 연산과 유사하나 약간의 차이점이 있다.

| 연산자 | 이름           | 설명                                                         |
|:------:|:--------------:| ------------------------------------------------------------ |
| `+`    | 덧셈           | 서로 다른 두 딕셔너리 객체를 하나의 딕셔너리로 통합한다.     |
| `in`   | 포함 (키 제외) | 해당 키가 딕셔너리에 있는지 확인한다. 하지만 딕셔너리의 값은 확인하지 않는다. |

```python
dictionary = {key1: value1, key2: value2}

print(key1 in dictionary)            # >> 출력: True
print(value2 in dictionary)          # >> 출력: False
print(key3 not in dictionary)        # >> 출력: True
```

딕셔너리는 특정 함수와 메소드를 통해 딕셔너리 전용 연산을 수행할 수 있다.

|   연산   | 예시                         | 설명                                                         |
| :------: | ---------------------------- | ------------------------------------------------------------ |
| `get()`  | `dictionary.get(key,[desc])` | `key` 키를 찾아 해당 값을 호출한다. `key`를 찾지 못할 시, 덧붙인 `desc` 설명이 반환된다 (기본값: `None`). |
| `dict()` | `dictionary=dict()`          | 빈 딕셔너리 객체를 생성한다.                                 |

```python
dictionary = {key1: value1, key2: value2}

print(dictionary.get(key0))                            # >> 출력: 데이터1
print(dictionary.get(key2))                            # >> 출력: None
print(dictionary.get(key3, "딕셔너리 내에 없음"))       # >> 출력: 딕셔너리 내에 없음
```

## 집합 객체
집합(set) 객체는 요소의 고유성을 보장하는 (시퀀스가 아닌) 이터러블 객체로, 객체 내의 중복 요소를 허용하지 않는다. 딕셔너리와 마찬가지로 집합 초기화에는 중괄호(`{}`)를 사용하지만 `키:값` 형태가 아니다. 이러한 이유로 집합은 리스트보다 요소를 더 빠른 시간 내에 확인할 수 있다.

```python
st = {value1, value2, value3}
print(st)
```

```
{value1, value2, value3}
```

집합의 연산자는 수학에서의 집합에서 사용되는 연산과 동일한 역할을 한다. 

| 연산자 | 이름   | 설명                                                       |
|:------:|:------:| ---------------------------------------------------------- |
| `|`    | 합집합 | 두 집합의 합을 반환한다.                                   |
| `&`    | 교집합 | 두 집합에 존재하는 요소만 반환한다.                        |
| `-`    | 여집합 | 피감수 집합에만 존재하며 감수 집합에 없는 요소를 반환한다. |
| `^`    | 대칭차 | 한 집합에는 존재하나 둘 다 속하지 않는 요소를 반환한다.    |

```python
set1 = {1, 2, 3, 4, 5, 6}
set2 = {4, 5, 6, 7, 8, 9}

print(set1 | set2)        # >> 출력: {1, 2, 3, 4, 5, 6, 7, 8, 9}

print(set1 & set2)        # >> 출력: {4, 5, 6}

print(set1 - set2)        # >> 출력: {1, 2, 3}
print(set1 - set2)        # >> 출력: {7, 8, 9}

print(set1 ^ set2)        # >> 출력: {1, 2, 3, 7, 8, 9}
```

집합은 특정 함수와 메소드를 통해 집합 전용 연산을 수행할 수 있다.

|  함수   | 예시            | 설명                                                         |
| :-----: | --------------- | ------------------------------------------------------------ |
| `set()` | `set(iterable)` | `iterable`로부터 집합을 생성하는 함수이다. 리스트와 튜플은 변환할 수 있으나, 딕셔너리는 불가하다. |

빈 집합 객체는 위의 함수로 통해서 생성되어야 하며, 이는 중괄호(`{}`)가 딕셔너리를 생성하기 때문이다. 한편, 집합 객체가 사용할 수 있는 메소드는 다음과 같다.

| 메소드     | 예시                  | 설명                                         |
|:----------:| --------------------- | -------------------------------------------- |
| `add()`    | `st.add(value)` | 집합에서 `value` 요소를 끝에 추가한다. |
| `remove()` | `st.remove(value)` | 집합에서 `value` 요소를 제거한다.     |
| `pop()`    | `st.pop()`          | 무작위로 선택된 요소를 집합 내에서 제거한다. |

```python
st = set([value1, value2, value3, value1])
print(st)                # >> 출력: {value1, value2, value3}

st.add(value4)
st.remove(value1)
print(st)                # >> 출력: {value2, value3, value4}

print(st.pop())          # >> 출력: value2 (무작위로 제거)
print(st)                # >> 출력: {value3, value4}
```

## 제너레이터 객체
제너레이터(generator)는 `yield` 키워드와 `for` 반복문으로 직접 생성할 수 있는 이터러블 객체이다. 제너레이터 객체는 메모리 제한이 없는 점에서 무한한 개수의 데이터를 담을 수 있는 이점을 가진다.

```python
# 제네레이터 생성
def generator_function():
    variable = 0
    while variable < 5
        yield var
        var += 1

# 제너레이터 반복으로 각 요소 반환
for variable in generator_function():
    print(variable)

# 리스트 객체로 변환
lst = list(generator_function())
print(lst)
```

```
0
1
2
3
4
[0, 1, 2, 3, 4]
```

### `yield` 키워드
제너레이터를 생성하는 데 필요한 키워드이며, `for` 반복문을 실행하면 키워드에 할당된 데이터를 반환한다.

# 파이썬: 함수
언제든지 재사용이 가능한 함수를 제작하여 프로그램을 코딩하는 기법을 *함수형 프로그래밍(functional programming)*이라고 부른다. 본 장은 파이썬에서 함수형 프로그래밍을 구현하기 위한 사용자 정의 함수의 생성 및 사용 방법에 대하여 소개한다.

## 함수
함수(function)는 독립적인 코드 블록으로써 데이터를 처리하며, 재사용이 가능하고 호출 시 처리된 데이터를 보여주어 유동적인 프로그램 코딩을 가능하게 한다. 함수는 이름 뒤에 소괄호가 있는 `function()` 형식으로 구별된다.

```python
variable = [0, 3, 5, 9]
print(len(variable))
# "print()" 함수, 그리고 리스트 객체를 인자로 받아 리스트 길이를 반환하는 "len()" 함수
```

```
4
```

비록 함수는 변수와 다르지만 동일하게 취급할 수 있다. 이에 대한 내용은 아래의 예제를 참고하여 확인할 수 있다.

```python
# 본래 함수
function(arg1, arg1)

# 변수로 함수를 할당 및 실행
variable = function
print(variable(arg1, arg2))
```

함수는 변수로 할당될 수 있을 뿐만 아니라, 다른 함수의 인자로 전달될 수 있다. 그러므로 이미 정의된 다른 함수를 사용하여 또 다른 함수를 정의할 수 있다.

### 순수 함수 
순수 함수(pure function)는 하나의 전달인자에 항상 동일한 반환값이 도출되며, 또한 정적변수 및 전역변수와 같은 외부적 영향인 부작용(side effect)이 없는 함수이다. 예를 들어, 코사인 함수 `cos(x)`의 반환값은 오로지 `x` 전달인자에만 의존하며 동일한 숫자가 입력되면 항상 같은 결과값이 나온다. 그러므로 코사인 함수는 순수 함수이다.

### 고차 함수
고차 함수(higher-order function)는 다른 함수를 전달인자로 사용하거나 함수를 반환하는 함수이다.

## `def` 키워드
`def` 키워드는 사용자 지정 함수를 만들기 위해 사용된다. 새로 생성한 함수를 정의하기도 전에 호출할 시, 순차적으로 실행되는 파이썬에서는 존재하지 않는 함수를 호출하는 것으로 간주하여 오류가 발생한다.

```python
def function(arg1, arg2):
    print(arg1 * arg2)
    return arg2

function("Hello",3)
print(function("World",2))
```

```
HelloHelloHello
WorldWorld
2
```

함수를 정의할 때, 어떠한 전달인자가 없을지언정 소괄호(`()`)가 반드시 필요하다.

### `return` 반환문
`return` 반환문은 함수로부터 데이터를 반환하는 함수 전용 문장이다. 반환문이 실행되면 코드가 남아 있음에도 불구하고 함수는 즉시 종료된다. 함수는 반환문을 반드시 필요로 하지 않으며, 이러한 경우에는 `None` 값이 반환되어 변수에 전달되거나 콘솔창에 출력되어 나타난다. 

```python
def function():
    print("Hello World!")
    
print(function())
```

```
Hello World!
None
```

### 매개변수 & 전달인자
다음은 함수에 대해 논의할 때 중요하게 언급되는 매개변수와 전달인자의 차이에 대하여 설명한다.

* **전달인자 (argument)**
    : 간략하게 "인자"라고도 부르며, 함수로 전달되는 데이터이다.
* **매개변수 (parameter)**
    : 전달인자를 할당받는 함수 내의 지역 변수이다. 그러므로 매개변수는 함수 외부에서 호출이 불가능하다.

매개변수와 전달인자는 개념적으로 다른 존재이지만, 동일한 데이터를 가지고 있는 관계로 흔히 두 용어는 혼용되어 사용하는 경우가 많다.

| 연산자 |    구문    | 설명                                                 |
| :------: | :----------: | ------------------------------------------------------------ |
|   `*`    |   `*args`    | 여러 개의 전달인자들을 한 번에 허용한다.<br />함수 내에서는 별표 없이 `args`로 호출하며 튜플을 반환한다. 반드시 일반 매개변수 뒤에 위치해야 한다. |
|   `**`   |  `**kwargs`  | 정의되지 않은 매개변수를 미리 사용할 수 있도록 한다.<br />함수 내에서는 별표 없이 `kwargs`로 호출하며 전달인자 이름과 해당 값으로 구성된 딕셔너리를 반환한다. 반드시 일반 매개변수 뒤에 위치해야 한다. |
|   `=`    | `arg=value` | 매개변수에 전달인자가 없으면 기본값 `value`가 대신 반환된다. 반드시 일반 매개변수 뒤에 위치해야 한다. |

아래의 예제는 함수의 매개변수와 전달인자가 어떻게 동작하는지 보여준다.

```python
# 매개변수 *args는 하나 이상의 인자를 전달할 수 있다.
def function(arg1, *args):
    print(arg1)
    print(args)
    print(args[0])
    
function(1, 2, 3, 4)
```

```
1
(2, 3, 4)
2
```

----

```python
# 매개변수 **kwargs는 함수 내에서 정의되지 않은 매개변수를 수용할 수 있다.
def function(arg1, **kwargs):
    print(kwargs)
    
function(1, key1 = value1, key2 = value2)
```

```
{key1∶ value1, key2∶ value2}
```

----

```python
# 매개변수 arg2의 기본값 초기화
def function(arg1, arg2 = "Hello"):
    print(arg2)
    
function(1)
function(2, "World!")
```

```
Hello
World!
```

## 익명 함수
익명함수(anonymous function), 일명 *람다 함수(lambda function)* 혹은 *람다식(lambda expression)*은 정의가 이름이 없는 (즉, 익명) 함수로, 데이터를 저장하지 않고 단일 표현식으로만 값을 반환한다. 익명 함수는 일반적으로 일회용 함수로 사용되거나 고차 함수의 전달인자로 사용한다.

|                             구문                             |
| :----------------------------------------------------------: |
|               `lambda arg1, arg2 ∶ expression`               |
| 익명 함수는 매개변수 `arg`와 이를 반환하는 표현식 `expression`으로 구성된다. |

비록 익명 함수가 한 번만 사용되는 이름없는 함수이지만, 익명 함수는 변수에 할당하여 호출할 수 있다.

```python
# 이름이 있는 함수
def function(arg1, arg2):
    return 2 * arg1 + arg2

# 익명 함수
(lambda arg1, arg2: 2 * arg1 + arg2)(2, 3)

# 변수에 할당된 익명 함수
variable = lambda arg1, arg2: 2 * arg1 + arg2
variable(2,3)
```

```
7
```

## `map()` 함수
`map()` 함수는 이터러블 객체와 매개변수를 갖는 함수를 인자로 가지는 내장 함수이다. `map()` 함수는 이터러블 객체를 인자로 갖는 매개변수 함수의 반환값으로 구성된, 즉 함수로 맵핑(mapping)된 리스트를 반환한다.

|                             구문                             |
| :----------------------------------------------------------: |
|          `map(function, iterable1, iterable2, ...)`          |
| 고차 `map()` 함수에서 이터러블 객체 `iterable1`와 `iterable2`가 `function`의 인자로 전달된다. |

`SyntaxError`와 같은 오류를 방지하려면 리스트나 튜플과 같은 이터러블 객체로 변환해야 한다.

```python 
lst1 = [1, 2, 3, 4, 5]
lst2 = [0, 9, 8, 7, 6, 5]

variable1 = map(lambda arg1, arg2: arg1 ** 2 + arg2, lst1, lst2)
variable2 = map(lambda arg2, arg1: arg1 ** 2 + arg2, lst2, lst1)

print(list(variable1))
print(list(variable2))
```

```
[1, 13, 17, 23, 31]
[1, 83, 67, 53, 41]
```

## `filter()` 함수
`filter()` 함수는 이터러블 객체와 조건 함수(일명 술어; predicate)를 인자로 갖는 내장 함수이며, 술어의 조건에 만족하는 데이터만 필터링되어 구성된 이터러블 객체를 반환한다.

|                             구문                             |
| :----------------------------------------------------------: |
|                `filter(predicate, iterable)`                 |
| 고차 `filter()` 함수에서 이터러블 객체 `iterable`는 `predicate`의 인자로 전달된다. |

`SyntaxError`와 같은 오류를 방지하려면 리스트나 튜플과 같은 이터러블 객체로 변환해야 한다.

```python
lst = [1, 2, 3, 4, 5]

variable = filter(lambda arg: arg % 2 is 0, lst)

print(list(variable))
```

```
[2, 4]
```

## 재귀 함수 
재귀 함수(recursive function)는 스스로를 호출하는 함수이다. 수학에서의 펙토리얼이 재귀 함수 구현의 대표적인 예제이다.

```python
# 예제: 펙토리얼 "!"
def factorial(arg):
    # 기저 조건: 재귀로부터 탈출하는 조건
    if arg == 1: 
        return 1
    else:
        return arg * factorial(arg-1)

print(factorial(5))
```

```
120
```

여러 함수가 서로를 호출하는 간접적 재귀도 가능하다.

### 기저 조건
기저 조건(base case)는 더 이상 스스로를 호출하지 않는 재귀 조건을 말하며, 출구 조건으로 간주할 수 있다. 기저 조건이 없을 시, 재귀는 무한히 발생하여 메모리 부족으로 충돌한다.

```
RuntimeError: maximum recursion depth exceeded
```

## 데코레이터
데코레이터(decorator)는 함수의 기능을 수정하는 역할을 하며, 값을 반환하기 보다는 수정된 함수 자체를 반환하는 함수이다. 그러므로 데코레이터를 통해 처리된 후에 제대로 동작하기 위해서는 변수로의 할당이 필요하며, 함수 호출 또한 변수를 통해 이루어진다.

```python
# 본래 함수
def function():
    statements

# 데코레이터 생성
def decorator(func):
    def modified_function():
        """
        func() 함수를 포함한 문
        """
    return modified_function

# 함수 수정하기(데코레이팅)
variable = decorator(function) 
variable()                  # 실제로는 "variable"라는 이름의 변수에 할당된 함수이다.
                
# 함수 수정하기(데코레이팅): 함수 이름 유지
function = decorator(function)
function()
```

위의 데코레이터는 `함수()`를 수정하고 변수 `variable()` 및  `function()`에 할당하였으며, 후자의 경우는 함수명을 유지하였다.

데코레이터의 인자로 함수를 전달할 때  `function()`처럼 소괄호를 사용하지 않는다. 소괄호가 있으면 함수의 반환값을 전달하기 때문이며, 함수 자체를 전달하기 위해서는 괄호를 사용하지 않는다.

### `@` 기호
데코레이터의 `@` 기호는 적용될 데코레이터 이름과 함께 수정될 함수 앞에 놓여 사용된다.

| 연산자 |  예시   | 설명                                              |
| :------: | ------------ | --------------------------------------------------------- |
|   `@`    | `@decorator` | `@decorator` 는 `function = decorator(function)`를 대체한다. |

```python
# 데코레이터 생성
def decorator(func):
    def modified_function():
        """
        func() 함수를 포함한 문
        """
    return modified_function

# 함수 수정하기: @ 기호 사용
@decorator
def function():        # "function()"의 본래 함수
    statements

# 함수 이름은 그대로 유지된다.
function()
```

추가적으로, 수정될 함수에는 하나 이상의 데코레이터를 적용 할 수 있다.

```python
@decorator1
@decorator2
def function():
    statements
```

수정될 함수에 가장 가까운 데코레이터가 우선적으로 적용된다. 그러므로, `function()` 는 먼저 `@decorator2` 다음 `@decorator1` 순서대로 적용된다.

# 파이썬: 객체 및 클래스
본 문서에서 현재까지 절차적 및 함수형 프로그래밍에 대하여 소개하였다. 세 번째 프로그래밍 방법인 객체지향 프로그래밍(object-oriennted programming; OOP)은 함수 대신 클래스와 객체 사용을 기반으로 한다. 본 장은 파이썬에서 객체지향 프로그래밍을 구현하기 위한 사용자 정의 클래스의 생성 및 사용 방법에 대하여 소개한다.

## 객체
이전 챕터에서는 (데이터를 저장할 수 있는) 변수와 (데이터를 처리 할 수 있는) 함수를 소개하였다. 객체(object 혹은 instance)는 이러한 변수와 함수를 하나의 데이터로 캡슐화한 데이터이다.

사용자 정의 객체 중심으로 한 프로그래밍을 *객체지향 프로그래밍*이라고 한다.

```python
variable = [0, 3, 5, 9]
print(variable.index(5))
# variable이란 이름을 가진 리스트 객체의 "index()" 메소드를 사용하여 값 5에 대한 위치를 반환한다
```

```
2
```

## 캡슐화
캡슐화(encapsulation)는 객체의 핵심으로 아래의 특성을 가진다.

1. 변수와 함수를 하나의 객체로 결합한다.
2. 우연치 않은 수정을 방지하기 위해 이러한 변수 및 함수에 대한 직접적인 접근을 외부로부터 제한할 수 있다.

### 속성 & 메소드
속성(attribute)과 메소드(method)는 객체에 캡슐화된 변수와 함수를 의미하며 아래와 같은 방법으로 접근한다.

| 객체 구성요소 | 구문                 |
| :-----------: | -------------------- |
|     속성      | `instance.attribute` |
|    메소드     | `instnace.method()`  |

## 클래스
클래스(class)는 객체를 생성하는 데 사용된다. 클래스는 `class` 키워드를 사용하여 정의되며, 내부는 객체 속성과 메소드가 되는 변수와 함수를 정의한다. 아래는 `class` 키워드를 사용하여 제작한 사용자 정의 클래스의 간단한 예시 중 하나이며, 변수 및 함수와의 유사성을 확인할 수 있다.

```python
# 클래스 생성하기
class CLASS:
    # 인스턴스 초기화 (= 생성자)
    def __init__(self, arg1, arg2):
        # 속성 (변수와 비슷함)
        self.attr1 = arg1
        self.attr2 = arg2
        
    # 메소드 (함수와 비슷함)
    def method(self, arg3):
        self.attr3 = arg3
        return self.attr1 + self.attr2 - self.attr3

# 객체화
instance = CLASS(value1, value2)    # 클래스로부터 객체 생성

# 그러므로...
print(instance.attr3)
print(instance.method(value3))
```

```
value3
value1 + value2 - value3
```

### `self` 변수
`self` 변수는 객체 자체를 나타내는 일반적인 변수 이름이다. 변수 또는 함수에 `self`를 두면 객체에 종속되어 속성 및 메소드로 정의된다. 이러한 속성과 메소드는 객체로만 접근이 가능하다. `self`가 없는 변수 및 함수는 객체 내부의 지역 변수 및 함수이며 외부에서 접근 할 수 없으며, 접근 시 "AttributeError"가 발생한다.

```python
# 클래스 생성
class CLASS:
    def __init__(self, arg1, arg2):
        self.attr1 = arg1
        self.attr2 = None        # 속성값을 초기화해주지 않으면 에러가 발생한다.
        attr3 = arg2             # 지역 변수


# 객체화
instance = CLASS(1, 2)
''' 동일: 
CLASS.__init__(self = instance, arg1 = 1, arg2 = 2)
'''

# 그러므로
instance.attr1        # >> 출력: 1
instance.attr2        # >> 출력: None
instance.attr3        # AttributeError: 'CLASS' object has no attribute 'attr3'
```

### `__init__` 메소드
`__init__` 메소드는 객체를 생성하는 데 필요한 가장 중요한 메소드이다. 이름에서 알 수 있듯이 ("초기화"의 *initialization* 약어), 해당 메소드는 클래스에서 객체를 만들 때 자동으로 호출되며 객체 초기화에 필요한 인수의 수를 결정한다.

## 객체 속성 & 메소드
객체 속성(instance attribute) 및 객체 메소드(instance method)는 클래스 내에서 `self`와 함께 정의된 모든 속성과 메소드를 의미하며, 객체를 통해 접근할 수 있는 속성과 메소드이다. 단, 객체 속성은 객체 메소드 내에서만 정의될 수 있다.

```python
# 클래스 생성
class CLASS:
    def __init__(self, arg1, arg2):
        # 객체 속성
        self.attr1 = arg1
        self.attr2 = arg2
        self.attr3 = None

    # 객체 메소드
    def method(self, arg3):
        self.attr3 = arg3
```

## 클래스 속성 & 메소드
클래스 속성(class attribute) 및 클래스 메소드(class method)는 클래스를 통해 접근할 수 있는 속성과 메소드이다. 클래스 속성은 객체 메소드가 아닌 클래스 내에 정의된 속성이다. 그리고 클래스 메소드를 선언하기 위해서는 아래의 데코레이터를 필요로 하다. 

|     구문     |설명                              |
| :------------: | ---------------------------------------- |
| `@classmethod` | 클래스 메소드를 선언하는 데 사용되는 데코레이터이다. |

클래스 메소드 또한 객체 클래스의 `self` 변수와 같이 클래스 스스로를 가리키는 변수가 필요하며, 일반적으로 `cls`라는 식별자를 사용한다.

```python
# 클래스 생성
class CLASS:
    # 클래스 속성
    attribute = value
    
    def __init__(self, arg1, arg2):
        self.attr1 = arg1
        self.attr2 = arg2
        self.attr3 = None

    def method1(self, arg3):
        self.attr3 = arg3
    
    # 클래스 메소드
    @classmethod
    def method2(cls, arg4):
        return arg4
    
    # 객체화를 위한 클래스 메소드
    @classmethod
    def method3(cls, arg5, arg6):
        return cls(arg5**2, arg6**2)
    
    
# 객체화
instance1 = CLASS(1, 2)
instance1.method1(4)

# 객체화: arg1 = 1**1, arg2 = 2**2
instance2 = CLASS.method3(1, 2)
instance2.method1(4)

# 그러므로...
CLASS.attribute         # >> 출력: value
CLASS.method2(3)        # >> 출력: 3

instance1.attribute     # >> 출력: value
instance1.attr1         # >> 출력: 1
instance1.attr2         # >> 출력: 2
instance1.attr3         # >> 출력: 4

instance2.attribute     # >> 출력: value
instance2.attr1         # >> 출력: 1 (= 1**2)
instance2.attr2         # >> 출력: 4 (= 2**2)
instance2.attr3         # >> 출력: 4
```

## 정적 메소드
정적 메소드(static method)는 객체화없이 호출할 수 있으며, `self`나 `cls` 같은 변수를 필요로 하지 않는다. 이러한 변수가 없으므로 정적 메소드는 클래스 및 객체 속성과 메소드를 접근할 수 없다. 다시 말해, 정적 메소드는 단순히 클래스에 속해있는 일반 함수와 동일하게 취급하면 된다. 정적 메소드를 선언하기 위해서는 아래의 데코레이터를 필요로 하다. 

| 구문         |설명                               |
|:---------------:| ----------------------------------------- |
| `@staticmethod` | 정적 메소드를 선언하는데 사용되는 데코레이터이다. |

```python
# 클래스 생성
class CLASS:
    def __init__(self, arg1, arg2):
        self.attr1 = arg1
        self.attr2 = arg2
        self.attr3 = None
        
    def method1(self, arg3)
        self.attr3 = arg3
        
    # 정적 메소드
    @staticmethod
    def method2(arg4):
        return True if arg4 is 4 else False


# 객체화
instance = CLASS(1, 2)
instance.method1(4)

# 그러므로...
instance.attr1            # >> 출력: 1
instance.attr2            # >> 출력: 2
instance.attr3            # >> 출력: 4

CLASS.method2(4)        # >> 출력: True
```

## 매직 메소드
매직 메소드(magic method)는 식별자 양쪽에 던더(dunder; double underscore)가 있는 특수한 메소드이다. 매직 메소드는 대부분 연산자를 나타내며 연산자 오버로딩으로 기능을 수정하는데 사용된다. 초기화에 사용된 `__init__` 메소드는 널리 사용되는 매직 메소드 중 하나이다. 아래 표에서 더 많은 것을 볼 수 있다:

| 연산자  | 이름       | 매직 메소드                   |
|:----:|:--------:|--------------------------|
| `+`  | 산술: 덧셈   | `__add__(self, arg)`     |
| `-`  | 산술: 뺄셈   | `__sub__(self, arg)`     |
| `*`  | 산술 : 곱셈  | `__mul__(self, arg)`     |
| `/`  | 산술 : 나눗셈 | `__truediv__(self, arg)` |
| `&`  | 논리: AND  | `__and__(self, arg)`     |
| `^`  | 논리: XOR  | `__xor__(self, arg)`     |
| `|`  | 논리: OR   | `__or__(self, arg)` |
| `()` | 인자호출    | `__call__(self, arg)`    |

### 연산자 오버로딩
연산자 오버로딩은 특정 클래스나 자료형이 가지는 연산자의 기능을 변경하는 것을 의미한다. 연산자 오버로드에는 매직 메소드가 사용되지만 오버로드 된 기능은 해당 특정 클래스에만 적용된다. 예를 들어,`x + y`는`x .__ add __ (y)`로 표현이 된다.

```python
# 클래스 생성
class CLASS:
    def __init__(self, arg1):
        self.attribute = arg1
        
    def __add__(self, arg2):
        return "\0".join([self.attribute, arg2.attribute])  # 두 문자열 객체 사이에 "\0" 추가

# 객체화
instance1 = CLASS("Hello")
instance2 = CLASS("World!")

instance1 + instance2        # >> 출력: "Hello World!"
```

## 상속
상속(inheritance)은 파생된 서브클래스(일명 자식 클래스)에 속성과 메소드를 제공하는 슈퍼클래스(일명 기반 클래스)의 동작이다. 슈퍼클래스와 서브클래스 둘 다에 동일한 이름의 속성과 메소드가 존재하는 경우, 슈퍼클래스의 속성과 메소드가 서브클래스에 의해 대체된다.

```python
# 슈퍼클래스 생성
class SUPERCLASS:
    attr1 = value1
    attr2 = value2

# 서브클래스 생성
class SUBCLASS(SUPERCLASS):
    attr2 = "Hello World!"
    attr3 = value3

# 객체화  
instance = SUBCLASS()

# 그러므로...
instance.attr1        # >> 출력: value1
instance.attr2        # >> 출력: "Hello World!"
instance.attr3        # >> 출력: value3
```

### 슈퍼 함수
`super ()` 함수는 슈퍼클래스의 속성과 메소드에 직접 접근할 수 있다. 이 함수는 주로 슈퍼클래스 속성과 메소드를 재정의하는 것을 피하기 위해 사용된다.

```python
# 슈퍼클래스 생성
class SUPERCLASS:
    def __init__(self, arg1):
        print("Hello World!")
        self.attribute = arg1

# 서브클래스 생성
class SUBCLASS(SUPERCLASS):
    def __init__(self, arg2):
        print("Goodbye World?")


# 객체화
instance = SUBCLASS(3)

# 그러므로...
print(instance.attribute)
```

```
"Goodbye World?"
AttributeError: '서브클래스' object has no attribute '속성'
```

`SUPERCLASS`의 `__init __()`메소드가 `SUBCLASS`로 상속되었으나 `SUBCLASS`는 이미 `__init __()` 메소드를 가지고 있어 오버로드로 인해 상속이 되지 않은 것처럼 보인다. 결국 `print(Hello World")`가 나타나지 않고 `self.attribute`이 상속에도 불구하고 오류를 일으키는 이유이다.

한편, 슈퍼 함수를 사용하여 `SUPERCLASS`의 `__init__()` 메소드를 다음과 같이 집적 불러올 수 있다.

```python
# 슈퍼클래스 생성
class SUPERCLASS:
    def __init__(self, arg1):
        print("Hello World!")
        self.attribute = arg1

# 서브클래스 생성
class SUBCLASS(SUPERCLASS):
    def __init__(self, arg2):
        # 슈퍼클래스로부터 "__init__()" 메소드 직접 상속
        super().__init__(arg2)
        print("Goodbye World?")


# 객체화
instance = SUPERCLASS(3)

# 그러므로...
print(instance.attribute)
```

```
"Hello World!"
"Goodbye World?"
3
```

## 데이터 숨기기
파이썬의 캡슐화는 데이터 숨기기(data hiding)가 완전히 보장되지 않는다. 여전히 외부 코드에서 클래스의 속성과 메소드 접근이 가능하다. 클래스에 가능한 한 숨겨져야 하는 속성과 메소드가 있는 경우 일반적으로 이름뒤섞기(name mangling)와 방법으로 데이터를 숨길 수 있다.

| 기호 | 예시       | 설명                                                 |
| :----: | ------------- | ------------------------------------------------------------ |
|  `_`   | `_attribute`  | 이름 뒤섞기란 기법이 아니지만, 클래스가 모듈로써 불러올 경우에 대하여 접근을 제한된다. |
|  `__`  | `__attribute` | 이름 뒤섞기: 모듈로써 접근과 클래스 외부에서의 접근을 제한한다. |

### 프로퍼티
프로퍼티(property)는 단일 메소드를 세 개의 개별 메소드 `getter`,`setter` 및`deleter`로 나누어 데이터 숨기기를 지원하는 데코레이터이다. 프로퍼티는 데코레이터 기호를 사용하여 선언되기 때문에 메소드에서만 사용할 수 있다.

| 메소드  | 구문            | 설명                                           |
|:-------:| ----------------- | ----------------------------------------------------- |
| Getter  | `@property`       | 프로퍼티 속성에서 값을 가져 오는 메소드. |
| Setter  | `@method.setter`  | 프로퍼티 속성 값을 설정하는 메소드.  |
| Deleter | `@method.deleter` | 프로퍼티 속성을 삭제하는 메소드.             |

```python
# 클래스 생성
class CLASS:
    def __init__(self, arg1):
        self.attribute = arg1
    
    # 정의: GETTER 메소드
    @property
    def method(self):
        return self.attribute
    
    # 정의: SETTER 메소드
    @method.setter
    def method(self, arg2):
        self.attribute = arg2
    
    # 정의: DELETER 메소드
    @method.deleter
    def method(self):
        del self.attribute
        
# 객체화
instance = CLASS(3)

# 그러므로
print(instance.method)   # 예시: GETTER 메소드

instance.method = 1      # 예시: SETTER 메소드
print(instance.method)

del instance.method      # 예시: DELETER 메소드
print(instance.method)
```

```
3
1
AttributeError: 'CLASS' object has no attribute 'attribute'
```

프로퍼티를 통해 메소드를 나누므로써 수정되지 말아야 하는 `setter` 및 `deleter`와 같은 민감한 코드를 숨기면서 `getter` 메소드만을 통해서 기능을 사용할 수 있다. 이를 통해 메소드를 `getter`로 통해 지속적으로 사용 가능하게 하면서 메소드 코딩 작업을 `setter`에서 진행하도록 한다.

비록 `getter` 메소드는 프로퍼티에서 필수적이지만, `setter`와 `deleter`는 선택사항이다. `getter` 메소드만 사용하면 읽기 전용 메소드가 된다.

# 파이썬: 예외 처리
예외(exception)는 잘못된 코딩이나 입력으로 인해 프로그램상 실행 불가능 코드 오류이다. 컴파일러에서 걸러지는 오류가 아니기에 정상적인 프로그램 빌드가 이루어질 수 있으나, 예외가 발생하면 프로그램이 즉시 중단된다. 예외 처리는 빌드된 프로그램이 중단이나 충돌 없이 안정적으로 실행되는 것을 주목표로 한다.

### `try`/`except` 문
`try`/`except` 쌍의 문은 예외를 감지하고 발생한 예외에 따라 특정 실행문을 호출하는 데 사용된다. 이 두 가지 이외에도 예외처리에 사용되는 추가 문들도 있다.

| 키워드    | 설명                                                         |
|:---------:| ------------------------------------------------------------ |
| `try`     | 예외가 있는지 확인하는 코드 블록을 제공한다.               |
| `except`  | 특정 예외가 발생하였을 때 실행된다.         |
| `else`    | [선택사항] 오류(예외)가 감지되지 않았을 시 실행된다. |
| `finally` | [선택사항] 오류 발생 여부를 떠나 반드시 실행되는 코드이다. |

```python
try:
    statements
except exception_type1:
    statements
except exception_type2:
    statements
except:            # 전조건 예외처리는 마지막에 위치한다.
    statements
finally:
    statements
```

`try`/`except` 문이 실행된 후에도 프로그램은 멈추지 않고 계속 진행된다.

### `raise` 문
`raise` 문은 의도적으로 예외를 직접 발생시키는 데 사용된다. 해당 문으로 오류를 발생시키면 프로그램이 즉시 중단되어 더 이상의 실행이 이루어지지 않는다.

```python
# 명시적 예외 발생: 위의 'except' 문 내에서도 단독으로 사용할 수 있음.
raise

# 명시적으로 발생된 예외에 대한 자세한 설명을 제공한다.
raise exception_description
```

### `assert` 문
`assert` 문은 표현식의 타당성(일명 진술)을 확인한다. 확인한 표현식이 유효하고 문제가 없으면 해당 진술은 `True`를 반환한다. 예외가 발생하였으면 해당 진술은 `False`를 반환한다.

```python
print(0)
assert TRUE_expression
print(1)
assert FALSE_expression, "예외유형 설명"
print(2)
```

```
0
1
AssertionError: 예외유형 설명
```

# 파이썬: 파이썬다운
본 장에서는 파이썬 개발자들이 프로그래밍을 할 때 추천하는 파이썬 코딩 스타일에 대하여 소개를 하며, 이를 영어로 pythonic("파이썬"스러운)이라고 부른다.

## 파이썬의 젠
파이썬의 젠(Zen of Python)은 파이썬에 내장되어 있는 파이썬 코딩 지침을 담고 있으며, 아래의 코드로 확인할 수 있다.

```python
import this
```

## PEP8
PEP8란, 여덟 가지의 파이썬 개선 제안(Python Enhancement Proposals)으로 경력있는 파이썬 개발자들이 조언하는 파이썬 프로그래밍 스타일이다.

1. 모듈 이름은 간결하고 소문자로만 구성되어야 한다.
2. 클래스 이름은 대문자로 시작하는 단어들로 구성되어야 한다 (일명 CapWords 스타일).
3. 대부분의 변수와 함수 이름은 소문자와 밑줄(띄어쓰기 대행)로만 구성되어야 한다.
4. 상수 변수는 대문자와 밑줄(띄어쓰기 대행)로만 구성되어야 한다.
5. 파이썬 키워드와 충돌이 일어날 수 있는 이름 접미부에 밑줄을 넣도록 한다.
6. 한 줄은 80자를 초과하지 않도록 한다.
7. `from module import *`는 되도록 사용하지 않는다.
8. 한 줄에는 하나의 문만 있어야 한다.

## 시작점
시작점(entry point)는 프로그램이 시작되는 부분을 의미하며, C/C++ 프로그래밍 언어의 경우 `main()` 함수에서부터 코드가 실행된다. 그러나 파이썬은 시작점이란 존재하지 않는다. 하지만 현재 어느 스크립트를 중심으로 실행되는지 판별하는 코드가 있으며 `__name__` 매직 메소드가 `"__main__"`과 일치 여부를 확인한다.

```python
# 시작점
if __name__ == "__main__":
    statements
```

파이썬에서는 이를 시작점이라고 부르며, 모듈로 가져온 스크립트에서는 시작점이 실행되지 않는다. 주의해야 할 점은 비교 연산자 `==`는 논리 연산자인 `is`로 대체하여서는 절대 안된다.

# 파이썬: 파일 관리
과학적 연구 혹은 인공지능 목적으로 작성된 심화된 파이썬 프로그램에서 입력 데이터를 터미널로 입력하기에 터무니 없이 비효율적일 수 있다. 이러한 문제를 해결하기 위해 데이터가 입력된 파일을 불러와 프로그램 상에서 처리할 수 있어야 한다.

## 파일 열기
파이썬에서는 파일을 처리하기 전에, 우선 파일을 열어야 한다. `open()` 함수를 통해 원하는 파일을 열 수 있다.

```python
open("파일이름.txt")
```

| 전달인자 | 설명                               |
|:--------:| ---------------------------------- |
| `r`      | 읽기 모드 (기본값)                 |
| `w`      | 덮어쓰기 모드 (새로 쓰기)              |
| `a`      | 덧붙이기 모드 (내용 추가)          |
| `rb`     | 바이너리 읽기 모드 (비텍스트 파일) |
| `wb`     | 바이너리 쓰기 모드 (비텍스트 파일) |

`close()` 메소드는 현재 열려있는 파일을 닫는다. 파일을 닫는 것은 리소스 낭비를 줄이는 데 매우 중요한 역할을 한다. 예외처리가 발생하여도 정상적으로 파일을 닫을 수 있도록 `try`/`except` 문 혹은 `with` 문을 함께 사용할 것을 권장한다.

```python
file = open("파일이름.txt", "r")
file.close()
```

### `with` 문
`with` 문은 해당 코드 블록 안에서만 사용할 수 있는 임시 변수를 생성한다. `with` 문으로 파일을 열었을 경우, 코드 블록이 종료되면 파일은 자동적으로 닫힌다.

```python
with open("파일이름.txt") as file:
    statements
```

### 컨텍스트 관리자
컨텍스트 관리자는 `with` 문을 지원하는 인터페이스이다. 함수나 메소드를 컨텍스트 관리자로 설정하는 방법은 두 가지가 있다:

1. `__enter__()`와 `__exit__()` 메소드

```python
# 컨텍스트 관리자 1
class CLASS:
    def __init__(self):
        pass
    
    # "with" 문 시작 시 실행
    def __enter__(self):
        self.var = expression
        return self.var
    
    # "with" 문 종료 시 실행
    def __exit__(self):
        statements
```

2. `contextlib` 모듈

```python
from contextlib import contextmanager

# 컨텍스트 관리자 2 
class CLASS:
    def __init__(self):
        pass
    
    # "with" 문 지원 함수 혹은 메소드
    @contextmanager
    def method(self):
        self.var = expression
        yield self.var
        statements
```

컨텍스트 관리자는 `with` 문을 사용할 시, 반환(`return`) 혹은 양도(`yield`)된 데이터는 `with` 문에서 처리할 수 있는 리소스가 된다. 이렇게 암시적으로 지정된 리소스는 다른 명칭을 사용하지 않는 이상 `as` 키워드의 사용이 불필요하다.

```python
# 객체화
instance = CLASS()

with instance.method():
    # "self.var"를 위주로 처리
    statements
```

대표적인 컨텍스트 관리자의 실제 적용 예시로는 [*텐서플로우: 텐서보드*](../ko.LIBRARY_TensorFlow#텐서보드)에서 확인할 수 있다.

### 절대주소 & 상대주소
파이썬에는 절대주소와 상대주소가 존재한다. 경로를 지정할 때에는 백슬래시 두 개(`\\`)로 폴더 및 파일을 구분해야 하며, 하나만 사용하면 탈출 문자가 되어 원치 않은 텍스트 연산이 수행될 수 있다.

```python
file = open("경로\\파일이름.txt")
```

## 파일 읽기
텍스트 기반 파일을 연 이후, 파이썬은 `read()` 메소드를 통해 파일 내용을 읽을 수 있다. 메소드의 인자로는 정수가 건네지며, 이는 읽을 바이트 수를 의미한다. 하나의 파일에서 `read()` 메소드는 여러 번 사용될 수 있으며, 마지막으로 읽은 부분에서부터 이어서 읽는다. 인자가 없을 시, 메소드는 나머지 내용 전체를 읽는다.

```python
with open("경로\\파일이름.txt") as file:
    print(file.read(16))    # 내용 시작 부분에서부터 16 바이트를 읽는다.
    print(file.read(4))     # 16 바이트 이후로부터 4 바이트를 읽는다.
    print(file.read())      # 4 바이트 이후로부터 나머지 바이트를 읽는다.
    print(file.read())      # 더이상 읽을 내용이 없어 아무런 텍스트를 반환하지 않는다.
```

`readlines()` 메소드는 각 줄의 내용을 담는 리스트 객체를 반환한다. 메소드의 인자로는 정수가 건네지며, 이는 읽을 바이트 수를 의미한다. 다만, 첫 줄만 읽는 `readline()` 메소드와 혼돈하지 않도록 주의해야 한다.

```
<파일이름.txt>
첫 번째 줄은 여기에.
두 번째 줄은 저기에.
마지막 줄은 어딘가에.
```

```python
with open("경로\\파일이름.txt") as file:
    print(file.readlines())
    print(file.readline())
```

```
['첫 번째 줄은 여기에.\n','두 번째 줄은 저기에.\n','마지막 줄은 어딘가에.']
첫 번째 줄은 여기에.
```

### 반복문을 이용한 내용 출력
각 줄의 텍스트 기반 파일 내용은 `for` 반복문을 다음과 같은 방법으로 사용해 출력할 수 있다.

```python
for variable in file:
    print(file)
```

## 파일 쓰기
파이썬에서 텍스트 파일은 `write()` 메소드를 통해 생성되거나 작성된다. 파일을 쓰는 모드에는 두 가지가 존재한다: (1) 덮어쓰기와 (2) 덧붙여 쓰기가 있다. 아래의 텍스트 파일이 있다고 가정한다.

```
<Sample.txt>
첫 번째 줄은 여기에.
두 번째 줄은 저기에.
마지막 줄은 어딘가에.
```

덮어쓰기(overwrite) 모드 `w`는 기존의 모든 내용들을 삭제하여 처음부터 새로 작성한다.

```python
with open("경로\\파일이름.txt", "w") as file:
    file.write("텍스트 덮어쓰기!")
```

```
<파일이름.txt>
텍스트 덮어쓰기!
```

덧붙여 쓰기(append) 모드 `a`는 기존의 모든 내용들을 유지하고 맨 끝 단락에서부터 작성한다.

```python
with open("경로\\파일이름.txt", "a") as file:
    file.write("텍스트 덧붙여 쓰기!")
```

```
<파일이름.txt>
첫 번째 줄은 여기에.
두 번째 줄은 저기에.
마지막 줄은 어딘가에.텍스트 덧붙여 쓰기!
```

성공적으로 쓰기를 완료하였을 시, `write()` 메소드는 작성된 내용의 바이트 수를 반환한다.

### 파일 생성
`write()` 메소드는 기존의 파일을 작성하는 것 이외에도 새로운 파일을 생성하는 데에도 쓰인다. 지정된 경로에 존재하지 않는 파일 이름으로 내용을 작성하면 해당 이름을 가진 새로운 파일이 생성된다. 

```python
with open("경로\\NEW-파일이름.txt", "w") as file:
    file.write("새 파일 생성!")
```

```
<NEW-파일이름.txt>
새 파일 생성!
```

# 파이썬: 패키지
파이썬에는 특정 목적을 수행하기 위한 여러 가지의 패키지들이 존재한다. 본 장에서는 패키지를 다운로드하여 사용하는 방법을 설명한다.

## 모듈
파이썬 모듈(module)은 추가 기능을 위해 불러온 `.py` 확장자의 일반 파이썬 소스 코드를 가리킨다. 개발자는 함수나 클래스를 담고 있는 파이썬 스크립트를 작성하고, 이를 `import` 키워드를 통해 다른 스크립트로 자료형, 연산, 객체 및 클래스를 불러올 수 있다. 아래는 `module.py`이란 파이썬 스크립트를 불러오는 예시이다.

```python
import module
module.function()
```

위의 방법은 `함수()`를 사용하기 위해 매번 모듈을 언급해야 한다. 이런 불편함을 해소하기 위해 `from` 키워드를 통해 암묵적으로 모듈을 언급하는 방법을 택한다.

```python
from module import function1, function2
from module import function as name
```

그러나 모듈이 암묵적으로 언급되었으므로, 동일한 함수 이름으로 생길 수 있는 충돌 문제가 잠재적으로 내포되어 있다. 함수 이름의 고유성이 확실히 보장되지 않는 이상, 모듈을 안전하게 불러오기 위해 전자의 방법을 권장한다.

## 패키지
패키지(package)는 관련 파이썬 모듈들을 담고 있는 하나의 폴더이다. 모든 파이썬 패키지 폴더 내에는 `__init__.py`라는 특수한 파이썬 파일이 존재하며, 안에는 아무런 내용이 없거나 해당 패키지의 파일경로가 담겨있기도 한다.

```python
import package.module
from package.module import function
```

## PyPI
[PyPI](https://pypi.org/)(Python Package Index; 파이썬 패키지 목록)은 온라인 패키지 저장소이다. 모듈 및 패키지를 설치하기 위해서는 pip라는 소프트웨어가 반드시 필요하다.

### pip
pip 소프트웨어는 파이썬 패키지 관리 시스템이다. 패키지 관리 소프트웨어는 기본적으로 파이썬 3 인터프리터와 함께 설치되지만, 온라인에서 개별적으로 설치할 수도 있다. 패키지의 설치 및 관리는 명령 프롬프트나 Powershell과 같은 터미널 유형 콘솔창에서 이루어진다. 

| 이름        | 설명               | 명령어                 |
| ----------- | ------------------ | ---------------------- |
| `install`   | 패키지 설치        | `pip install 패키지`   |
| `uninstall` | 패키지 제거        | `pip uninstall 패키지` |
| `list`      | 설치된 패키지 목록 | `pip list`             |

윈도우 OS에서 파이썬 pip를 사용할 경우, 단독적인 `pip`가 아닌 `python -m pip` 명령어를 사용하는 것을 권장한다(macOS 및 리눅스 제외).

```
python -m pip
```

특히 원도우 10 OS를 사용하는 경우 `python`을 입력하는 것만으로 마이크로소프트 스토어로 이동하게 되는데, 해결 방법은 두 가지가 있다.

1. `python`을 `py`로 대체 (Python Launcher 프로그램 사용).
2. 컴퓨터에서 `설정` → `앱` → `앱 및 기능` → `앱 실행 별칭 관리`에서 `python.exe` 및 `python3.exe`을 해제 (본질적 문제 해결).

위의 명령어는 컴퓨터 환경설정에서 지정된 파이썬 인터프리터의 pip를 접속한다는 것을 의미한다. 이를 통해 인터프리터 간의 패키지 관리에 혼돈을 줄일 수 있다. 만일 32비트 파이썬 3.8 인터프리터가 설치되었을 경우, 다음 명령어로 접근할 수 있다.  

```
py -3.8-32 -m pip
```

# 파이썬: 가상환경
파이썬에서 pip로 설치한 패키지들은 전부 인터프리터 경로에 설치된다. 이는 여러 파이썬 프로젝트를 진행할 시 치명적인 문제점이 될 수 있는데, 바로 인터프리터에는 하나의 패키지가 여러 개 존재할 수 없다는 것이다. 결국 두 프로젝트가 서로 다른 버전의 패키지를 요구되면 프로젝트를 작업할 때마다 모듈을 새로 설치하는 번거로움이 발생한다.

이러한 문제를 해결하기 위한 게 바로 가상환경(virtual environment)이다. 해당 프로젝트만을 위한 인터프리터를 복제하여 할당하면, 두 프로젝트 간의 패키지 충돌이 일어나지 않으며 패키지 관리도 훨씬 용이해진다.

## `venv` 패키지
파이썬 3에는 기본적으로 `venv`라는 가상환경 패키지가 포함되어 있다. 본 패키지는 간단한 가상환경을 지원해주며, 시스템 인터프리터와 분리되었으나 동일한 버전의 개별 인터프리터가 할당된다. 해당 인터프리터의 pip로 설치된 패키지는 가상환경에 설치된다.

### 가상환경 생성
원하는 파이썬 프로젝트에 `.venv` 이름의 가상환경을 생성하기 위해 아래의 명령어를 입력한다.

```
python -m venv D:\Workspace\Python\project\.venv
```

### 가상환경 실행
여기서 가상환경 "실행"이란 가상환경을 터미널을 통해 접속한다는 것을 의미한다. 파이썬 프로그램 실행에는 가상환경 실행을 요하지 않으나, 패키지를 설치하기 위해서는 가상환경 실행이 필요하다.

* 윈도우 OS:

    ```
    D:\Workspace\Python\project\.venv\Scripts\activate.bat
    ```

* 유닉스 (예. macOS 및 리눅스):

    ```
    source ~/Workspace/Python/project/.venv/bin/activate
    ```

### 가상환경 종료
터미널로부터 가상환경을 종료하기 위해 아래의 명령어를 입력한다.

```
deactivate
```

이는 <code style="word-break: break-all;">D:\Workspace\Python\.venv\Scripts\deactivate.bat</code> 명령어를 입력하는 것과 동일하다. 이러한 이유로, 가상환경 경로를 옮길 시 `deactivate` 명령어를 인식하지 못하여 직접 경로를 찾아서 `deactivate.bat` 파일을 실행해야 한다.

# 파이썬: 넘파이
넘파이는 다차원 배열을 지원하는 매우 강력하고 유용한 파이썬 전용 라이브러리이다. 특히 메모리 효율성이 일반 파이썬 리스트 객체보다 우월하여 규모가 큰 배열을 다룰 때에는 넘파이 라이브러리는 필수항목이 된다. 이러한 특징으로 인해 넘파이는 다른 라이브러리에 있어서도 독보적인 입지를 다지는데, Matplotlib 혹은 TensorFlow와 같은 라이브러리에서도 흔히 사용된다.

넘파이 라이브러리를 설치하기 위해, 아래의 명령어를 입력한다.

```
python -m pip install numpy
```

넘파이는 현재까지도 계속 업데이트되고 있는 라이브러리로, 본 장에서는 넘파이에 대한 대략적인 설명과 사용법 소개를 집중한다. 더 자세한 API 정보는 다음 URL을 참고한다: https://numpy.org/

## 넘파이 배열
넘파이 배열은 처리 속도가 파이썬의 리스트보다 빠른데, 이는 배열 데이터들이 메모리의 한 곳에 밀집되어 있기 때문이다. 그러나 이는 넘파이 배열의 유연성을 떨어트리는 단점을 지니고 있다. 그러므로 데이터 처리 방식과 규모에 따라 넘파이 배열과 파이썬 리스트를 적절히 사용하기도 한다.

넘파이 행렬의 정의은 다음과 같다.

```python
import numpy as np

# 넘파이 정의
var = np.ndarray(shape = (2, 3))
print(var)
```

```
[[800191312     32765 800196048]
 [    32765 870097920     32765]]
```

이는 넘파이 행렬을 크기를 기반하여 생성하지만, 요소 값은 무작위로 선정된다. 넘파이 행렬의 초기화는 다음과 같다.

```python
import numpy as np

# 넘파이 초기화 
var = np.array([[1, 2, 3], [4, 5, 6]])
print(var)
```

```
[[1 2 3]
 [4 5 6]]
```

넘파이 정의와 달리 주어진 값에 따라 넘파이 행렬이 생성되지만, 만일 차원의 크기가 방대해지면 이러한 방법은 오히려 비효율적이다.

아래의 목록은 넘파이 행렬을 더 편리하게 생성하는 그 외의 메소드를 소개한다.

| 넘파이 행렬         | 설명                                                     |
| ------------------- |--------------------------------------------------------|
| `np.full(shape, value)` | 값이 전부 `value`로 채워진 `shape`의 넘파이 행렬을 생성한다. |
| `np.zeros(shape)`    | 값이 전부 0으로 채워진 `shape`의 넘파이 행렬을 생성한다.  |
| `np.ones(shape)`     | 값이 전부 1로 채워진 `shape`의 넘파이 행렬을 생성한다.    |
| `np.eye(shape)`      | `shape`의 넘파이 단위 정방행렬을 생성한다.                |

### 넘파이 요소
넘파이 행렬의 요소를 접근하는 방식은 파이썬의 이터러블 객체와 비슷하나 약간의 차이점이 있다.

```python
import numpy as np
var = np.array([[1, 2, 3], [4, 5, 6]])

print(var[0])       # >> 출력: [1, 2, 3]
print(var[0, 1])    # >> 출력: 2
```

```
[1, 2, 3]
2
```

### 넘파이 크기
넘파이 크기는 파이썬의 일반 이터러블 객체 메소드인 `len()`에서 알아낼 수 없다. 그 대신, 넘파이 자체적으로 가지는 속성에서 각 차원의 크기를 확인할 수 있다.

```python
import numpy as np
var = np.array([[1, 2, 3], [4, 5, 6]])

var.shape        # >> 출력: (2, 3)
var.shape[0]     # >> 출력: 2
```

넘파이 크기 및 차원 개수를 변경하기 위해서는 아래의 `reshape()` 메소드를 사용한다.

```python
import numpy as np
var = np.array([[1, 2, 3], [4, 5, 6]])

print(var.reshape((3, 2, 1)))
```

```
[[[1]
  [2]]

 [[3]
  [4]]

 [[5]
  [6]]]
```

### 넘파이 변환
파이썬 리스트를 넘파이 배열로 변환하는 가장 간단한 방법은 배열 초기화에 사용한 `np.array()` 메소드를 사용하는 것이다.

```python
import numpy as np
lst = [[1, 2, 3], [4, 5, 6]]

var = np.array(lst)
print(var)
```

```
[[1 2 3]
 [4 5 6]]
```

### 넘파이 확장 
넘파이 배열을 확장하려면 `np.append()` API를 사용한다. 만일 매개변수 `axis=`에 아무런 값을 입력하지 않았던가 `None` 값이 건네지면 다차원 넘파이 배열을 입력하더라도 1차원 넘파이 배열이 출력된다. 배열 형태를 유지하려면 `axis=`에 몇 번째 차원 크기를 확장할 것인지를 반드시 지정해야 한다.

```python
import numpy as np
var = np.array([[1, 2, 3], [4, 5, 6]])

var = np.append(var, [[7, 8, 9]], axis = 0)
print(var)
```

```
[[1 2 3]
 [4 5 6]
 [7 8 9]]
```

하지만 유동적인 배열 크기 확장에는 오히려 파이썬 리스트가 넘파이 배열보다 훨씬 유리하게 작용할 수 있다. 리스트에서 데이터를 추가한 다음 넘파이 배열로 변환하는 방법도 권장한다.

```python
import numpy as np
lst = [[1, 2, 3], [4, 5, 6]]
lst.append([7,8,9])

var = np.array(lst)
print(var)
```

```
[[1 2 3]
 [4 5 6]
 [7 8 9]]
```

## 넘파이 인덱싱
인덱싱(indexing)이란 행렬의 특정 범위 내의 요소들을 추출하는 것이다. 각 차원의 추출 범위는 콜론(`:`)으로 지정하며, 쉼표(`,`)로 차원을 구별한다. 인덱싱 구문 규칙은 이터러블 객체의 슬라싱과 동일하다. 

* `n:m` : 차원의 `n`번째 인덱스 요소에서부터 `m`번째 이전의 요소까지 추출한다.
* `:` : 차원의 처음부터 끝까지를 추출한다.

```python
import numpy as np
var = np.array([[1, 2, 3], [4, 5, 6]])

print(var[:, 1:-1])
```

```
[[1 2]
 [4 5]]
```
