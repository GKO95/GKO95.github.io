---
layout: docs
language: ko
category: 운영체제
title: 프로세스
meta: Process
order: 0x40
---
# 프로세스: 소개
> *참조: [Microsoft Docs - Processes and Threads](https://docs.microsoft.com/en-us/windows/win32/procthread/processes-and-threads)*

비록 본문은 프로세스 및 스레드를 위주로 설명하지만, [메모리](../ko.COMPUTER_Memory)와 매우 밀접한 내용들이 있으므로 함께 보는 것을 권장한다.

## 어플리케이션
[어플리케이션은](https://ko.wikipedia.org/wiki/응용_소프트웨어)(application)은 [사용자 공간](https://ko.wikipedia.org/wiki/사용자_공간)에서 특정 작업을 수행하기 위해 설계된 [명령어](https://ko.wikipedia.org/기계어) 집합체, 일명 *실행 가능한 소프트웨어*이다. 프로그래밍 언어로 작성하여 컴파일된 `.EXE` 확장자를 갖는 실행 파일도 어플리케이션이다.

## 프로세스
[프로세스](https://ko.wikipedia.org/wiki/프로세스)(process)는 실행된 어플리케이션 안에 들어있는 명령들을 이행하기 위해 생성된 객체(instance)이다. 어플리케이션이 메모리(e.g., RAM)에 로드되면, 이를 실행하는 프로세스가 생성된다.

> CPU가 직접 접속할 수 있으면서 거리가 가까운 RAM 메모리에서 처리하는 게 HDD나 SSD와 같은 저장장치에서 실행하는 것보다 극적으로 빠르기 때문이다.

생성된 프로세스마다 [가상 주소 공간](../ko.COMPUTER_Memory/#가상-주소-공간)(virtual address space)이 할당되는데, 가상 주소 공간은 서로 고립되어 있기 때문에 하나의 프로세스에 문제가 발생하여도 타 프로세스에 영향을 주지 않는다. 즉, 가상 주소 공간은 프로세스 전용 메모리와 다름없다.

프로세스의 상태

* 생성(Created / New)
    : 프로세스가 처음으로 생성되었을 때의 상태이다.
    - [Created → Ready] : 곧바로 준비 상태로 전환된다.

* 준비(Ready)
    : 물리 메모리에서 CPU 프로세서로부터 즉시 실행될 수 있는 준비된 상태이다.
    - [Running → Ready] : *분배받은 퀀텀(일명, time slice) 소진, `Sleep(0)` 함수, 혹은 프로세스 우선순위로부터 밀려나는 등의 요인으로 준비 상태로 전환된다.*
    - [Waiting → Ready] : *대기 상태에서 탈출한 프로세스를 처리할 프로세스가 없으면 준비 상태로 전환된다.*

* 실행(Running)
    : 물리 메모리에서 CPU 프로세서로부터 실행되는 중이다.
    - [Ready → Running] : *준비 상태의 프로세스는 CPU로 실행될 프로세서를 지정 및 배치시키는 스케줄링 작업을 통해 실행 상태로 전환된다.*
    - [Waiting → Running] : *대기 상태에서 탈출한 프로세스를 곧바로 처리할 수 있는 프로세서가 있거나, 혹은 현재 실행 중인 프로세스보다 높은 우선순위를 갖고 있으면 곧바로 실행 상태로 전환된다.*

* 대기(Waiting / Blocked)
    : 물리 메모리에서 특정 이벤트가 발생할 때까지 실행될 수가 없는 유예된 상태이다.
    - [Running → Waiting] : *외부로부터 강제로 실행이 유예되었으므로 대기 상태에서 탈출하려면 타 실행 프로세스의 도움(예. `WaitingForSingleObject()` → `SetEvent()`)을 받거나 커널 동작(예. `Sleep(>0)`)을 기다려야 한다.*

* 종료(Terminated)
    : 프로세스가 프로그램 코드 실행을 전부 마쳤거나 외부로부터 kill되었을 시 종료 상태로 전환된다. 이때 리소스 관리가 제대로 되지 않으면 누수(leak)가 발생하여 시스템에 문제를 일으킬 수 있다.

## 스레드
[스레드](https://ko.wikipedia.org/wiki/스레드_(컴퓨팅))(thread)는 [스케줄링](#프로세스-스케줄링) 될 수 있는 프로세스에서 코드를 실행하는 가장 작은 흐름 단위이다. 프로세스에는 기본적으로 실행에 필요한 스레드 하나를 갖지만, 필요하면 한 개 이상의 스레드를 생성할 수 있다. 그러나 스레드가 종료되면 프로세스도 자동적으로 함께 종료된다. 즉, 스레드가 없는 프로세스는 존재하지 않는다.

> 정리하면 다음과 같다: *스레드는 실질적인 어플리케이션 실행의 주축이며, 프로세스는 스레드를 위한 메모리 및 리소스를 제공한다.*

그렇다고 프로세스 없이 스레드만 존재할 수 없다. 실행에 필요한 스택 및 heap 메모리, 실행 코드 등의 리소스를 프로세스가 가지고 있기 때문이다. 결국 프로그램 실행을 논할 때는 프로세스 단위로 설명한다.

프로세스 내의 스레드들은 하나의 가상 주소 공간에 있기 때문에 리소스를 서로 공유할 수 있다. 이는 프로세스 간 서로 고립적인 성질과 매우 대조적이다.

# 프로세스: 스케줄링
[스케줄링](https://ko.wikipedia.org/wiki/스케줄링_(컴퓨팅))(scheduling)은 프로그램 명령을 처리할 [프로세서](https://ko.wikipedia.org/wiki/중앙_처리_장치)(processor)에 어떤 프로세스 혹은 스레드를 어떻게 배분할 것인지 결정하는 작업을 말한다. 스케줄링에는 여러 가지 접근법이 있어 시스템 설계 목적이나 운영체제에 따라 다르다.

> [윈도우](https://ko.wikipedia.org/wiki/마이크로소프트_윈도우) 운영체제의 경우, *[선점형](https://ko.wikipedia.org/wiki/스케줄링_(컴퓨팅)#비선점형과_선점형) [Round-robin](https://ko.wikipedia.org/wiki/라운드_로빈_스케줄링) 스케줄링*을 택하였다.
>
> 스레드 혹은 (단일 스레드) 프로세스는 "퀀텀(Quantum; 혹은 time slice)"이란 일회성 시간제 티켓이 있어야만 프로세서로부터 처리될 수 있다. 프로세스는 작업 완료여부를 불문하고 time slice에 주어진 시간동안만 스레드를 처리하고 돌려보낸다. 작업이 완료되지 않은 스레드는 다시 time slice를 받기 위해 기다린다.

스케줄링은 결과적으로 운영체제의 [멀티태스킹](https://ko.wikipedia.org/wiki/다중작업)(multitasking)으로 구현된다. 덕분에 여러 개의 프로그램을 동시에 사용하거나 자동저장과 같은 실시간 기능이 가능해진다.

## 스케줄러
스케줄러는(scheduler)는 어떤 프로세스를 실행할 지 결정하는 운영체제의 일부분이다.

* 장기 스케줄링

* 중기 스케줄링
    : 중기 스케줄러(medium-term scheduler)는 swapping out (혹은 paging out) 그리고 swapping in (혹은 paging in) 작업을 수행한다. 자세한 내용은 [*페이징*](../ko.COMPUTER_Memory/#페이징)을 참고한다.

* 단기 스케줄링
    : 단기 스케줄러(short-term scheduler), 일명 CPU 스케줄러는 어느 ready 스레드에게 프로세서 시간을 분배할지 결정한다.

### Dispatcher
스케줄링 작업에서 프로세서 시간을 단기 스케줄링으로 지정된 프로세스에게 전달하는 모듈이다. Dispatcher 역할은 다음과 같다:

* 문맥 교환(context switch)
* 사용자 모드로 전환
* 프로세스가 생성(created) 상태로 변동되면 프로그램 재시작을 위해 사용자 모드 프로그램의 적절한 시작점으로 이동

Dispatcher은 매 스레드가 바뀔 때마다 실행되어야 하므로 가능한 동작이 빨라야 한다. Dispatcher가 프로세스 하나를 멈추고 새로운 프로세스를 실행시키는데 걸리는 시간을 dispatch latency라고 부른다. 문맥 교환 도중, 프로세서는 사실상 매우 잠깐동안 동작하지 않는다.

## 우선순위
스케줄링의 기본적인 기준은 프로세스와 스레드의 우선순위(priority)에 따라 결정된다. 우선순위는 총 0(최하) ~ 31(최상)으로 나뉘어진다.

> 최하 우선순위인 0은 zero-page 시스템 스레드만이 가질 수 있는 특수한 경우이다: 보안 목적을 갖고 있으므로 일반 스레드는 해당 우선순위를 사용하지 말아야 한다.

시스템은 동일한 우선순위를 갖는 스레드 간에는 [Round-robin](https://ko.wikipedia.org/wiki/라운드_로빈_스케줄링)(RR) 스케줄링을 사용하여 평등하게 취급한다. 만일 최고 우선순위에서 RR 스케줄링으로 실행할 스레드가 없으면, 차우선순위 스레드들을 RR 스케줄링한다.

스레드 우선순위은 다음 기준으로 결정된다:

* 프로세스의 우선순위 클래스

    * `IDLE_PRIORITY_CLASS`
    * `BELOW_NORMAL_PRIORITY_CLASS`
    * `NORMAL_PRIORITY_CLASS` *(default)*
    * `ABOVE_NORMAL_PRIORITY_CLASS`
    * `HIGH_PRIORITY_CLASS`
    * `REALTIME_PRIORITY_CLASS`

* 프로세스 우선순위 클래스 내의 스레드 우선순위 레벨
    
    * `THREAD_PRIORITY_IDLE`
    * `THREAD_PRIORITY_LOWEST`
    * `THREAD_PRIORITY_BELOW_NORMAL`
    * `THREAD_PRIORITY_NORMAL` *(default)*
    * `THREAD_PRIORITY_ABOVE_NORMAL`
    * `THREAD_PRIORITY_HIGHEST`
    * `THREAD_PRIORITY_TIME_CRITICAL`

우선순위 클래스와 레벨의 조합은 스레드의 기초 우선순위(base priority) 기준이 된다.

## 문맥 교환
[문맥](https://en.wikipedia.org/wiki/Context_(computing))(context)이란, 프로세스나 스레드 등이 중단된 시점에서부터 작업을 재개할 수 있도록 필요한 최소한의 정보들이다. 그리하여 문맥 교환(context switch)이란, 프로세스나 스레드를 나중에 재개하여 실행할 수 있도록 문맥을 저장하는 행위이다. 스케줄링과 함께 단일 코어 CPU에서 멀티태스킹을 가능하게 만드는 핵심 기능이다.

> 프로세스 문맥보다 스레드 문맥이 작으므로, 멀티프로세스보다 멀티스레드 문맥 교환이 더 빨리 이루어진다.

다음은 문맥 교환의 절차를 순차적으로 짚어서 설명한다:

1. Dispatcher에서 아래의 요인으로부터 스레드의 문맥을 저장한다.
    * 프로세서 시간(퀀텀; 일명 time slice) 소진
    * 우선순위가 더 높은 준비 중인 스레드 선점
    * 대기 상태로 전환

2. 준비 상태로 전환된 스레드는 스케줄링 대기열에 기다린다.

3. 스케줄러는 다음 준비 상태의 스레드에게 프로레서 시간을 분배한다.

4. Dispatcher는 시간 분배를 받은 스레드의 문맥을 불러와 실행을 재개한다.

## 우선순위 부스트
프로세스 클래스와 스레드 레벨에 의해 결정된 기초 우선순위가 있으나, 실제 스케줄링에서는 기초 우선순위가 반영된 동적 우선순위(dynamic priority)에 의해 결정된다. 동적 우선순위는 기초 우선순위 이상의 값을 가질 수 있으나, 절대로 낮을 수는 없다. 이를 통해 시스템은 필요에 따라 동적 우선순위를  부스팅(priority boost)하여 임시적으로 높일 수 있다 (단, 부스팅 대상은 기초 우선순위 0 ~ 15로 제한).

다음은 우선순위가 부스팅되는 일부 경우를 소개한다:

* `NORMAL_PRIORITY_CLASS` 우선순위의 프로세스가 foreground에 실행되면 스케줄러는 해당 프로세스의 우선순위을 부스트시켜 background 프로세스보다 높게 만든다. 그리고 foreground에 없으면 다시 원래 기초 우선순위으로 되돌린다.

* 윈도우 창에 연동된 타이머 신호를 받거나 마우스 혹은 키보드 메시지를 수신받을 시, 스케줄러는 해당 윈도우 창을 소유하는 스레드의 우선순위을 임시로 부스트시킨다.

우선순위 부스팅은 `SetProcessPriorityBoost` 혹은 `SetThreadPriorityBoost` 함수를 호출하여 비활성화 할 수 있다.

부스팅된 동적 우선순위는 단번에 기초 우선순위로 내려가지 않으며, 매 프로세서 시간을 배분받을 때마다 우선순위가 하나씩 낮아진다.

## 우선순위 반전
우선순위 반전(priority inversion)은 우선순위가 다른 스레드 두 개 이상이 스케줄링 과정에서 대치하고 있을 떄 발생한다. 여기서 언급한 대치 상황으로 아래의 예시를 둘 수 있다:

> 1. 스레드 1은 상위 우선순위로 스케줄링 준비가 되어있다.
> 2. 스레드 2는 하위 우선순위로 critical section의 코드를 실행하고 있다.
> 3. 스레드 2가 마무리되어야 실행될 수 있는 스레드 1은 대기 상태로 전환한다.
> 4. 스레드 3은 중간 우선순위이며, 대기 상태에 걸린 스레드 1 대신에 프로세서 타임을 분배받는다.
> 5. 스레드 2는 스레드 3보다 낮은 우선순위로 스케줄링에 의하여 마무리하지 못하고 준비 상태에 걸린다.

이러한 경우를 대비하여 스케줄러는 무작위로 준비 상태의 스레드 우선순위을 부스팅한다. 그러면 스레드 2는 critical section 코드 실행을 마무리할 수 있게 되며, 결과적으로 대기 상태에 있던 스레드 1도 실행될 수 있다.

## 다중 프로세서
여러 프로세서를 갖는 컴퓨터는 일반적으로 둘 중 하나의 아키텍처를 위해 설계되었다:

* 비균일 메모리 접속(non-uniform memory access; NUMA)
    : NUMA 컴퓨터의 각 프로세서는 메모리의 일부분을 더 빨리 접속하기 위해 메모리의 다른 부분에 비하여 더 가깝게 위치한다. NUMA 모델에서 시스템은 스레드가 위치하고 있는 메모리 부분과 가장 가까운 프로세서에 스케줄하려 한다.

* 대칭형 멀티프로세싱(symmetric multiprocessing; SMP)
    : SMP 컴퓨터는 두 개 이상의 동등한 프로세서 혹은 코어가 하나의 공용 메모리에 연결된다. SMP 모델에서 어떠한 스레드라도 아무런 프로세서에 할당될 수 있다. 즉, SMP 컴퓨터에서 스레드 스케줄링은 단일 프로세서에서 스케줄링하는 것과 유사하다.

스케줄링은 우선순위 외에도 (1) 스레드 affinity와 (2) 스레드 ideal processor 설정의 영향을 받는다.

### 스레드 Affinity
스레드 Affinity(def. a similiarity of characteristics)는 스레드를 특정 프로세서에서 실행되도록 강제시킨다. 이러한 행위는 스케줄러의 프로세서 시간 배분에 방해요소로 작용하기 때문에 최대한 기피되어야 한다. 최악의 경우, 스레드는 분명 사용할 수 있는 프로세서가 있음에 불구하고 실행될 수 없는 고갈 현상에 직면한다. 스레드 affinity는 각 프로세서를 테스트하는 용도만으로 사용하기를 권장한다.

### 스레드 Ideal Processor
스레드 ideal processor를 지정할 시, 스케줄러는 가능하면 스레드를 지정된 프로세서에 실행시키도록 노력한다. `SetThreadIdealProcessor` 함수는 이상적인 프로세서로 실행될거라는 보장은 아니지만 스케줄러에게 힌트를 준다. 즉, 강제성이 있는 스레드 affinity와의 확연히 다르다. 

## 스레드 Ordering 서비스
스레드 ordering 서비스(thread ordering service)는 하나 이상의 사용자 제작 클라이언트 스레드가 주어진 시간 안에 순서대로 한 번씩 실행하도록 제어한다. 스레드 ordering 서비스는 사용자가 수동으로 활성화해야 하며, 활성 시에는 시스템이 idle 상태에서도 매 5초마다 클라이언트 스레드들을 실행한다. 만일 에너지 효율성이 중요한 요소로 작용한다면 오히려 시스템 스케줄러를 통해 스레드 실행을 관리하기를 권장한다.

## Quality of Service
[QoS](https://ko.wikipedia.org/wiki/QoS)(Quality of Service)는 스레드의 성능 및 전력 효율성을 표시하는데 사용된다. 우선순위가 스케줄링을 결정하는 주요 척드로 작용한다면, QoS 레벨은 코어 선택 및 프로세서 전력 관리에 영향을 준다. 서로 다른 프로세서들로 이루어진 플랫폼에서, 스레드 QoS는 스케줄러에게 기피하거나 선호하는 프로세서를 알려준다.

# 프로세스: 멀티스레드
스레드는 프로세스 내에 위치하여 실행을 위해 스케줄링될 수 있는 존재이다. 모든 스레드는 프로세스의 가상 주소 공간 및 시스템 리소스를 공유한다. 각 프로세스는 모두 단일 스레드로 시작하지만 어느한 스레드로부터서라도 새로운 스레드를 생성할 수 있다.

## 스레드 스택
각 스레드마다 생성되면 코드 실행을 위한 자신만의 초기 할당(committed) 메모리와 예약 메모리(reserved)로 구성된 스레드 스택이 주어진다. 초기 할당 메모리는 참조될 때까지 물리 메모리를 사용하지 않지만 총 시스템 할당 한계치(물리 메모리 + 페이지파일)로부터 페이지를 가져온다.

> 페이지(page)란, 일정한 크기로 나뉘어진 운영체제에서 관리하는 가장 작은 단위의 가상 메모리이다.

예약 메모리는 추가 할당이 가능한 메모리 공간이며 최대로 가상 주소 공간만큼 확보할 수 있다. 필요 시 스레드는 "예약 메모리 최대 크기 - 1"만큼을 더 할당시킬 수 있는데, 이는 스택 오버플로우를 방지하는 차원이다. 그래도 안정적인 스레드 동작을 위해 가능한 작은 스택 크기로 할당하는 게 바람직하다.

스레드가 `return` 및 `ExitThread()` 함수로 종료되면 스택은 자동적으로 해제된다. 그러나 `TerminateThread()` 함수와 같이 타 스레드로부터 강제 종료된다면 cleanup이 진행되지 않아 스택이 잔여하는 메모리 누수 현상이 발생한다.

## 스레드 핸들
스레드는 `CreateThread()` 혹은 `CreateRemoteThread()` 함수로 생성되는데, 이때 스레드를 프로그램 상으로 처리할 수 있도록 하는 핸들(handle) 및 식별을 위한 스레드 고유 ID가 함께 반환된다. 스레드 ID를 알고 있으면 `OpenThread()` 함수로 스레드 핸들을 불러올 수 있다. 스레드 핸들은 (스레드 생성 때 설정한 플래그에 따라) 자식 프로세스가 상속받을 수 있고, 핸들을 복제시켜 제한된 권한을 갖는 스레드 핸들을 만들 수 있다. 스레드가 종료되어도 핸들이 열려있으면 스레드 객체는 잔여하기 때문에 반드시 직접 닫아주도록 한다.

`GetCurrentThread()` 함수는 현재 실행되고 있는 스레드의 pseudo 핸들을 가져오는데 사용된다. 그러나 이는 프로세스 호출을 위해서만 사용할 수 있으며, 다른 프로세스로의 상속 및 복제는 불가하다. 만일 pseudo 핸들로부터 실제 핸들을 가져오려면 해당 프로세스에서 `DuplicateHandle()` 함수를 사용한다.

## 스레드 유예
스레드는 타 스레드의 실행을 유예 및 재개시킬 수 있다; 다시 말해, 타 스레드의 상태를 [대기](#프로세스)(waiting)로 전환하거나 반대로 대기 상태를 해제할 수 있다는 의미이다. 유예된 스레드는 스케줄링에서 제외된다.

스레드가 `CREATE_SUSPENDED` 플래그가 설정된 상태로 생성되면 즉시 대기 상태에 진입한다. 타 스레드가 `ResumeThread()` 함수로 상태 전환을 하지 않는 이상 실행하지 않는다. 이러한 기능은 스레드가 실행되기 전에 초기화하는 목적으로 사용되거나, 단회성 동기화에서도 유용하다.

스레드 유예는 런타임 도중에도 진입될 수 있다:

* `SuspendThread()`
    : 원하는 지점에서 실행 유예를 할 수 없으므로 스레드 동기화 목적으로 사용되지 않는다. 디버깅 목적으로 사용되는 함수이다.

* `Sleep(>0)` 혹은 `SleepEx(>0)`
    : 특정 시간동안 실행을 임시적으로 보류하고, 커널로부터 재개된다.

* `SwitchToThread()`
    : `Sleep()` 함수와 유사하지만 시간을 정할 수 없다. 스레드에게 할당된 프로세서 타임을 포기하도록 한다.

## 스레드 동기화
여러 스레드가 공용 리소스에 접근할 때 발생 할 수 있는 [경쟁 상태](https://ko.wikipedia.org/wiki/경쟁_상태)(race condition) 혹은 [교착 상태](https://ko.wikipedia.org/wiki/교착_상태)(deadlock)를 방지하기 위해 동기화가 필요하다. 동기화는 또한 상호의존 코드가 순서대로 실행되도록 한다.

다음은 여러 스레드의 동기화에 사용될 수 있는 객체 핸들의 목록이다:

* 콘솔 입력 버퍼
* 이벤트
* [뮤텍스](https://ko.wikipedia.org/wiki/락_(컴퓨터_과학))
* 프로세스
* [세마포어](https://ko.wikipedia.org/wiki/세마포어)
* 스레드
* 타이머

위의 핸들은 signaled 될 수 있다는 특징이 있다. `WaitingForSingleObject()`이나 `SuspendThread()` 등의 대기 함수(wait functions)와 사용할 시, 객체의 signaled 여부에 따라 스레드의 실행을 막으므로써 동기화에 기여한다. 각 객체마다 signaled 되는 조건이 가지각색이다: 콘솔 입력 버퍼는 읽히지 않은 입력(마우스 클릭 혹은 키보드 버튼 다운)이 있을 경우, 프로세스 및 스레드는 종료되면 signaled 된다.

뮤텍스(mutex)는 동시다발적 공용 리소스 접근으로부터 보호하데 유용한 객체이다. 여러 스레드가 하나의 뮤텍스 핸들에 연동되었을 시, 뮤텍스는 signaled 되어 스레드 하나를 공용 리소스 접근시키자마자 바로 non-signaled로 되돌아간다. 공용 리소스에 접근한 스레드가 사용을 마쳤으면 직접 뮤텍스 객체에 signaled 설정을 해야 한다.

## 스레드 로컬 저장공간
스레드 로컬 저장공간(Thread Local Storage; TLS)는 오로지 자신만이 접근할 수 있는 스레드 개인 저장영역이다. 프로세스 내의 모든 스레드가 하나의 가상 주소 공간을 공유한다는 점을 염두하면, 일반적으로 스레드의 데이터는 항상 전역적이기 때문에 타 스레드가 언제든지 접근할 수 있다. 그리고 TLS는 이와 대조되는 개념을 갖는다.

스레드 개인 데이터를 저장하는 공간을 TLS 슬롯(TLS slot)이라고 부른다: `NULL`로 초기화된 `LPVOID` 자료형 배열이다. 그리고 TLS 슬롯 배열 중에서 어느 곳을 접근할지 TLS 인덱스(TLS index)에서 결정한다. TLS 인덱스는 `TlsAlloc()` 함수로 프로세스 가상 주소 공간에 영역을 확보, 즉 모든 스레드에 접근할 수 있는 전역 데이터이다.

TLS 인덱스에 해당하는 TLS 슬롯에 데이터를 입력(`TlsSetValue()` 함수) 및 호출(`TlsGetValue()` 함수)할 수 있다. TLS 인덱스 할당 영역을 해제하려면 `TlsFree()` 함수를 사용한다.

## 스레드 종료
스레드를 종료하면 다음 결과를 초래한다:

* 스레드의 exit 코드가 `STILL_ACTIVE`에서 변경된다.
* 스레드가 signaled 된다.
* 프로세스의 유일한 스레드일 경우, 프로세스는 종료된다.

단, 스레드 핸들이 아직 열려있다면 스레드 객체는 시스템에 잔여하여 원한다면 접근을 할 수 있다. 스레드의 마지막 핸들까지 닫힌 이후에서야 객체는 완전히 제거된다.

### 스레드 종료 방법
스레드를 종료하는 방법은 다음과 같다:

* 스레드에서 `return` 호출
* 스레드에서 `ExitThread` 함수 호출
* 프로세스 내의 아무 스레드가 `ExitProcess` 함수 호출

> 아래의 방법도 스레드를 종료하나 외부로부터 강제로 즉시 종료시키기 때문에 리소스 cleanup을 진행하지 않아 주의해야 한다.
> 
> * 다른 스레드가 해당 스레드의 핸들과 함께 `TerminateThread` 함수 호출
> * 다른 스레드가 해당 스레드가 위치한 프로세스의 핸들과 함께 `TerminateProcess` 함수 호출

## 스레드 풀
> [풀](https://en.wikipedia.org/wiki/Pool_(computer_science))(pool)이란, 리소스 관리 목적에 있어서 데이터나 객체를 미리 한군데에 모아둔 것이다.

스레드 풀(Thread pools)은 스레드를 작업할 객체들을 미리 한군데 모아둔 것을 가리킨다. 어플리케이션에서 생성하여 사용될 전체 스레드 개수를 줄이되 스레드 작업자들을 관리하므로써 효율성을 추구하는 목적으로 사용된다. 스레드 생성 및 파괴 과정에서 발생하는 overhead도 줄일 수 있는 장점을 갖는다.

# 프로세스: 자식 프로세스
기존의 프로세스로부터 새로이 생성된 프로세스를 "자식 프로세스(child process)"라고 부르며, 이를 생성한 프로세스를 "부모 프로세스(parent process)"라고 부른다.

## 프로세스 핸들
> 이전 장의 [*프로세스: 멀티스레드 - 스레드 핸들*](#스레드-핸들) 내용과 동일하다.

프로세스는 `CreateProcess()` 함수로 생성되는데, 이때 프로세스를 프로그램 상으로 처리할 수 있도록 하는 핸들(handle) 및 식별을 위한 프로세스 고유 ID가 함께 반환된다. 프로세스 ID를 알고 있으면 `OpenProcess()` 함수로 프로세스 핸들을 불러올 수 있다. 프로세스 핸들은 (프로세스 생성 때 설정한 플래그에 따라) 자식 프로세스가 상속받을 수 있고, 핸들을 복제시켜 제한된 권한을 갖는 프로세스 핸들을 만들 수 있다. 프로세스가 종료되어도 핸들이 열려있으면 프로세스 객체는 잔여하기 때문에 반드시 직접 닫아주도록 한다.

`GetCurrentProcess()` 함수는 현재 실행되고 있는 프로세스의 pseudo 핸들을 가져오는데 사용된다. 그러나 이는 프로세스 호출을 위해서만 사용할 수 있으며, 다른 프로세스로의 상속 및 복제는 불가하다. 만일 pseudo 핸들로부터 실제 핸들을 가져오려면 해당 프로세스에서 `DuplicateHandle()` 함수를 사용한다.

## 프로세스 열거
모든 사용자는 시스템에 있는 프로세스 목록을 읽어올 권한이 있다. 현재 활성 중인 프로세스를 열거하는 몇 가지의 함수가 존재하다.

* `EnumProcesses()`
    : 시스템 내에 있는 각 프로세스 객체의 고유 ID를 불러온다.
* `Process32First()`
    : 시스템 스냅샷에서 가장 먼저 마주한 프로세스 정보를 불러온다.
* `Process32Next()`
    : 시스템 스냅샷에서 그 다음으로 마주할 프로세스 정보를 불러온다.
* `WTSEnumerateProcesses()`
    : 특정 터미널 서버(혹은 특정 사용자 계정)에서의 활성 중인 프로세스들의 정보를 불러온다.

## 프로세스 상속
자식 프로세스가 생성되면서 부모 프로세스의 몇몇 성질을 상속받을 수 있다. 반대로 부모 프로세스는 자식 프로세스가 자신으로부터 성질을 상속받는 것을 방지할 수도 있다.

다음 성질들을 상속받을 수 있다:

* `CreateFile`(파일, 콘솔 입력 버퍼, 콘솔 스크린 버퍼 등), `CreateProcess`(프로세스), `CreateThread`(스레드), `CreateMutex`(mutex), `CreateEvent`(이벤트), `CreateSemaphore`(semaphore), `CreateNamedPipe`(네임드 파이프), `CreatePipe`(anonymous 파이프), 그리고 `CreateFileMapping`(파일 맵핑 객체)로부터 반환된 열린 핸들
    : 자식 프로세스는 부모 핸들의 일부를 상속받을 수 있으나, 나머지는 상속받을 수 없다. 핸들 상속을 위해서는 다음과 같이 해야 한다.

    * 상속될 핸들을 생성, 열기, 또는 복제할 때 상속받을 수 있도록 설정한다.
    * 핸들을 상속받을 프로세스를 생성할 때 `CreateProcess()` 함수의 `bInheritHandles` 매개변수를 `TRUE`로 설정한다.

    > 자식 프로세스에서 상속받은 핸들은 부모 프로세스가 접근하는 객체와 동일한 객체이다: 즉, 동일한 값에 동일한 권한을 갖는다. 그러므로 한 프로세스에서 핸들 상태를 수정하면 이는 나머지 프로세스에서도 그대로 반영된다.

    * 자식 프로세스가 상속받을 수 있는 핸들을 특정지을려면 `UpdateProcThreadAttribute` 함수에서 `PROC_THREAD_ATTRIBUTE_HANDLE_LIST` 플래그를 설정한다.

* 환경 변수
    : 기본적으로 자식 프로세스는 부모 프로세스의 환경변수를 상속받는다. `CreateProcess()` 함수로부터 부모 프로세스는 자식 프로세스가 다른 블록의 환경 변수를 사용하도록 지정할 수 있다.

* 현재 디렉토리
    : 현재 자식 프로세스의 디렉토리 위치는 기본적으로 부모와 동일하다. `CreateProcess()` 함수로부터 부모 프로세스는 자식 프로세스의 디렉토리를 변경할 수 있다.

* 프로세서 affinity 마스크

* Job 객체 연관성

* 콘솔창

자식 프로세스가 상속받지 않는 성질은 다음과 같다:

* 우선순위 클래스
* `HeapAlloc` 등의 메모리 할당 관련 핸들
* `GetCurrentProcess` 및 `GetCurrentThread`로부터 반환된 Pseudo 핸들
* DLL 모듈 핸들

## 환경 변수
모든 프로세스는 환경 변수(environment variables)와 그에 대한 값들을 묶음인 환경 블록(environment block)을 갖는다. 환경 변수에는 두 종류가 있다: (1) 각 사용자를 위한 "사용자 환경 변수" 그리고 (2) 모든 사용자를 위한 "시스템 환경 변수"이다.

기본적으로 자식 프로세스는 부모의 환경 변수를 상속받는다. 커맨드 프로세서(예. 명령 프롬프트 혹은 PowerShell 등)로부터 실행된 프로그램은 커맨드 프로세서의 환경 변수를 상속으며, `set` 명령어로 임시 환경 변수를 추가 및 수정할 수 있다. 자식 프로세스에 다른 환경을 지정하려면 새로운 환경 블록을 생성하여 그에 대한 포인터를 `CreateProces()` 함수의 인자로 넘겨준다.

## 프로세스 종료
프로세스를 종료하면 다음 결과를 초래한다:

* 프로세스의 모든 스레드가 signaled 및 exit 코드 변경과 함께 종료된다.
* 프로세스로부터 열린 모든 객체 핸들이 닫힌다.
* 프로세스의 exit 코드가 `STILL_ACTIVE`에서 변경된다.
* 프로세스가 signaled 된다.

단, 프로세스 핸들이 아직 열려있다면 프로세스 객체는 시스템에 잔여하여 원한다면 접근을 할 수 있다. 프로세스의 마지막 핸들까지 닫힌 이후에서야 객체는 완전히 제거된다. 일반적으로 부모 프로세스가 종료되면 자식 프로세스도 함께 종료된다 (예외 사항: [orphan process](https://en.wikipedia.org/wiki/Parent_process#Orphan_processes)).

### 프로세스 종료 방법
프로세스를 종료하는 방법은 다음과 같다:

* 프로세스이 마지막 스레드 종료
* 프로세스의 아무런 스레드에서 `ExitProcess` 함수 호출
* (콘솔 프로세스 한정) `CTRL+C` 혹은 `CTRL+BREAK`로 콘솔 제어 핸들러가 `ExitProcess` 함수 호출
* 사용자가 시스템을 종료하거나 로그아웃을 할 때

>  아래의 방법도 프로세스를 종료하나 외부로부터 강제로 즉시 종료시키기 때문에 리소스 cleanup을 진행하지 않아 주의해야 한다.
>
> * 다른 스레드가 해당 스레드가 위치한 프로세스의 핸들과 함께 `TerminateProcess` 함수 호출

주의: 현 스레드 상태를 확실히 알지 않는 이상 프로세스를 직접 종료하는 것은 위험하다. 특히 대기 상태의 스레드가 잔여하게 된다면 이를 종료할 때까지 프로세스 자체가 종료되지 않는데, 결국 어플리케이션 "응답 없음"을 야기한다. 이러한 문제를 방지하기 위해 primary 스레드에서 타 스레드의 종료름 먼저 확인하고 `ExitProcess` 혹은 `ExitThread`로 프로세스를 종료하는 게 안전하다.

# 프로세스: Job 객체
Job 객체는 여러 프로세스들을 하나의 단위로 관리될 수 있는 안전하고 공유할 수 있는 객체이다. Job 객체에 수행한 작업은 연동된 모든 프로세스들에 영향을 미친다; 우선순위 조정이나 프로세스 상태 전환 등을 Job 객체로 변경할 수 있다.

* `CreateJobObject()`
    : 아무런 프로세스사 연동되지 않은 Job 객체를 생성한다.

* `OpenJobObject`
    : 존재하는 Job 객체의 핸들을 연다.

* `AssignProcessToJobObject()`
    : 프로세스를 Job 객체에 연동시킨다; 한 번 연동된 프로세스는 해지될 수 없다.

> Job 객체에 연동된 프로세스가 `CreateProcess()` 함수로 자식 프로세스를 생성하면 자동으로 해당 Job 객체에 연동된다.

Job 객체는 연동된 프로세스의 각종 속성(예. 우선순위, affinity 등)에 제약을 걸 수 있다. 만일 연동된 프로세스가 개별적으로 Job 객체에 지정된 제약을 초과하여 변경할 시, 함수는 성공적으로 수행되었다고 알리지만 조용히 무시된다. 혹은 무시되지 않는 대신 notification을 발생시키도록 Job 객체를 설정할 수 있다.

Job 객체 핸들을 닫으려면 `CloseHandle` 함수를 사용하며, 마지막 핸들이 닫히고 연동된 모든 프로세스가 종료되어서야 객체는 파괴되어 signaled 된다. 그러나 `JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE` 플래그가 설정되면 마지막 핸들만을 닫는 것으로 객체를 파괴하고 연동 프로세스들을 한꺼번에 종료시킨다.

## Nested Job
어플리케이션은 Job 객체 안에 또다른 Job 객체가 있는 nested Job으로도 프로세스를 관리할 수 있다. 부모-자식 관계를 유지하며 부모 Job 객체가 갖는 프로세스의 일부를 갖는다. 만일 Job 객체에 이미 연동된 프로세스를 다른 Job 객체에서 연동하려고 할 시, 시스템에서 유효성을 판단하여 차후에 연동하려는 Job 객체를 먼저 연동한 Job 객체의 자식으로 지정한다.

# 프로세스: 파이버
[파이버](https://ko.wikipedia.org/wiki/파이버_(컴퓨터_과학))(fiber)는 어플리케이션에서 수동으로 스케줄링되는 실행 단위이다. 오로지 파이버만이 타 파이버를 실행히시킬 수 있으므로, 반드시 스레드 하나를 `ConverThreadToFiber()` 함수를 통해 파이버로 만들어야 한다. 그 이후로는 `CreateFiber()` 함수로 기존의 파이버가 새로운 파이버를 생성한다.

파이버의 문맥 교환은 사용자가 직접 해주기 때문에 선점형 스케줄링이 아니다. 시스템 스케줄링으로 스레드가 실행되기 때문에 파이버가 해당하는 스레드가 선점하면 파이버 역시 선점한다고 볼 수 있으나, 스레드가 실행하는 특정 파이버만이 실행되므로 "선택적"으로 선점한 것이 정확한 표현이다.

다음은 파이버 관련 함수 및 간랸한 설명을 제공한다:

* `ConvertThreadToFiber()`
    : 오로지 파이버만이 타 파이버를 생성 및 실행할 수 있으므로, 스레드를 파이버로 변환시킨다.

* `CreateFiber()`
    : 기존의 파이버로 새로운 파이버를 생성한다.

* `SwitchFiber()`
    : 다른 파이버(타 스레드의 파이버도 해당)로 문맥 교환하여 실행한다.

* `DeleteFiber()`
    : 해당 파이버 삭제 및 리소스 cleanup을 하며, 최종적으로 스레드도 `ExitThread()`로 종료한다.

여기서 주의할 점은 실행 중인 파이버가 타 파이버로부터 제거되면 되면 파이버 리소스가 cleanup 되어 비정상적으로 종료될 것이다.

## 파이버 로컬 저장공간
스레드에 파이버 로컬 저장공간(Fiber Local Storage; FLS)을 할당하면 각 파이버마다 데이터를 저장할 고유 변수를 생성한다. 파이버 문맥 스위칭이 잆으면 일반 TLS와 같이 동작하며, FLS 함수로 해당 파이버에 대하여 설정, 호출, 할당, 해제 등을 사용할 수 있다. 파이버 스위칭이 되면 스레드에 있는 FLS는 문맥 교환될 파이버의 것으로 바뀐다.

# 프로세스: UMS
사용자 모드 스케줄링(User-Mode Scheduling; UMS)은 어플리케이션이 자체적으로 스레드를 스케줄링하는 lightweight 매커니즘이다. 어플리케이션은 사용자 모드에서 시스템 스케줄러 관여 없이 UMS 스레드 간 문맥 교환이 가능하다.

> UMS와 [파이버](#프로세스-파이버)와 유사해 보이지만 확실한 차이점이 있다: UMS는 각 스레드마다 자신만의 스레드 문맥이 있는 반면, 파이버는 하나의 스레드에서 문맥을 공유한다.

UMS는 다중프로세서 혹은 다중코어 시스템에서 멀티스레드를 동시에 효율적으로 실행해야 하는 고성능 어플리케이션에 추천된다. UMS의 장점을 활용하기 위해 어플리케이션은 반드시 UMS 스레드를 관리 및 실행시키는 스케줄러 구성요소가 필요하다. 개발자는 어플리케이션 성능 요구사항에 따라 UMS 스케줄러 도입에 대하여 신중히 고려해야 한다. 만일 고성능 미만의 어플리케이션의 경우에는 오히려 시스템 스케줄러가 훨씬 더 효율적이다.

## UMS 스케줄러
UMS 스케줄러(UMS Scheduler)는 스케줄링 이외에도 UMS 스레드 생성, 관리, 그리고 제거까지 담당한다. 다음은 UMS 스케줄러가 수행하는 작업들을 나열한다.

* UMS 스레드를 실행할 프로세서마다 UMS 스케줄러 스레드를 생성한다.
* 어플리케이션 작업을 수행할 UMS worker 스레드를 생성한다.
* UMS worker 스레드를 대기시킬 자체 준비 대기열을 관리하고, 어플리케이션 스케줄링 정책에 따라 실행시킬 스레드를 선택한다.
* 하나 이상의 completion list를 생성 및 모니터링한다.
> 여기서 시스템 스케줄링과 차이점이 드러난다: 선점형 스케줄링은 새로 생성된 스레드가 대기열에 기다리지 않고 프로세서를 선점한다.
* 시스템으로부터 발생한 notificaiton을 처리할 스케줄러 entry point 함수를 제공한다.
* 실행을 마친 UMS worker 스레드를 cleanup 한다.
* 어플리케이션 요청 시, UMS 스케줄러의 순차적 종료를 진행한다.

### UMS 스케줄러 스레드
UMS 스케줄링 스레드(UMS Scheduling Thread)는 UMS 스케줄링에 가담할 프로세서에 UMS worker 스레드를 배분하는 역할을 수행한다. 일반 스레드로부터 `EnterUmsSchedulingMode()` 함수로 UMS 스케줄링 스레드로 변환한다. 이때 UMS 스케줄링에 연동될 completion list 및 entry point 함수를 지정한다.

UMS 스케줄러 스레드도 시스템 스케줄링에 의해 타 스레드와 우선순위가 비교되어 실행된다. UMS 스케줄러 스레드가 실행될 프로세서는 non-UMS 스레드와 마찬가지로 스레드 affinity의 영향을 받는다. 어플리케이션은 UMS 스케줄러 스레드의 affinity를 설정하여 특정 논리 프로세서가 관련없는 스레드를 배제시키므로써 

어플리케이션은 UMS 스레드를 실행할 프로세서마다 UMS 스케줄러 스레드를 생성할 수 있다. 어플리케이션은 또한 각 UMS 스케줄러 스레드에 affinity를 설정하여 그 외의 스레드가 특정 프로세서에 실행되는 것을 배제시키므로써 UMS 스케줄러 스레드의 효율을 높일 수 있다. 그러나 affinity는 스레드의 편중된 분배를 야기할 수 있어 시스템 성능 저하의 원인이 된다.

### UMS Worker 스레드
UMS worker 스레드는 UMS 스케줄링에서 작업을 실행하는 스레드이다. `CreateRemoteThreaEx()` 함수에서 `PROC_THREAD_ATTRIBUTE_UMS_THREAD` 플래그와 UMS 스레드 문맥, 그리고 completion list를 지정하여 생성한다. UMS worker 스레드를 실행려면 `ExecutreUmsThread()` 함수를 호출한다. 

### Completion List
Completion list는 커널에서 실행을 마친 UMS Worker 스레드를 시스템을 통해 전달받는 대기열이며, `CreateUmsCompletionList()` 함수로 생성된다. 새로운 UMS worker 스레드가 생성되면 무조건 completion list로 향한다. 대기 상태가 해제된 UMS worker 스레드도 completion list로 보내진다.

각 UMS 스케줄러 스레드는 하나의 completion list에 연동된다. 그러나 하나의 completion list는 여러 UMS 스케줄러 스레드에 연동될 수 있다. 심지어 UMS 스케줄러 스레드는 completion list의 포인터만 있으면 UMS 문맥을 가져올 수 있다.

Completion list는 비어있던 대기열에 UMS worker 스레드가 진입하면 시스템을 통해 signaled 된다. `GetUmsCompletionListEvent` 함수는 특정 completion list에 연동된 이벤트에 대한 핸들을 불러온다.

## UMS Entry point 함수
UMS 스케줄러 entry point 함수는 특정 UMS 스레드에 대하여 어떤 적절한 행동을 취할지 결정하는 역할을 담당한다. UMS 스케줄러 entry point 함수는 다음 상황이 발생할 때 callback 된다:

* `EnterUmsSchedulingMode`로 UMS 스케줄러 스레드가 생성되었을 때
    : *Entry point 호출 원인 → `EnterUmsSchedulingMode` 호출자로부터 지정된 데이터 참조*
* UMS worker 스레드가 `UmsThreadYield`를 호출할 때
    : *Entry point 호출 원인 → `UmsThreaYield` 호출자로부터 지정된 데이터 참조*
* UMS worker 스레드가 대기 상태로 전환할 때
    : *Entry point 호출 원인 → `NULL`*

스케줄러 entry point 함수가 호출되었다는 것은 UMS worker 스레드를 직접 관리할 필요하다는 의미이다. UMS worker 스레드를 Completion list에서 불러오는 `DequeueUmsCompletionListItmes()` 함수로 불러와 목록을 확인할 수 있다. 허나, 불러온 목록으로부터 곧바로 UMS worker 스레드를 실행하면 예측불가한 어플리케이션 동작이 발생할 수 있다. `GetNextUmsListItem()` 함수로 UMS worker 스레드 문맥을 하나씩 가져와 UMS 스케줄러 자체 대기열에 진입시켜 실행하도록 한다.
