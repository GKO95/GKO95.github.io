---
layout: docs
language: ko
category: 운영체제
title: 프로세스
meta: Process
order: 0x40
---
# 프로세스: 소개
> https://docs.microsoft.com/en-us/windows/win32/procthread/processes-and-threads

어플리케이션(application; 응용 프로그램): 컴퓨터 동작시키는 것 외에 특정 작업을 수행하기 위해 설계된 executable 소프트웨어(즉, 명령어 집합)이다. 어플리케이션이 특정 작업을 수행하기 위해 한 개 이상의 프로세스(process)를 생성한다.

----
프로세스는 어플리케이션을 실행할 때, 컴파일된 (기계어) 명령어 집합을 이행하는 객체이다. 각 프로세스마다 (커널로부터) 가상주소공간이 할당되고, 해당 가상주소공간은 프로세스의 컴파일된 executable 기계어 코드가 위치한 storage memroy (HDD, SSD etc)에 맵핑되어 실행된다. 즉, 컴파일된 executable이 RAM에 로드되지 않는다.

> think whether if 100GB game file able to load to 16GB RAM...of coures not!

각 프로세스의 가상주소공간은 고립형이므로 프로세스 하나에 문제가 생겨도 타 프로세스에 영향을 주지 않는다. 프로세스는 가상주소공간에서 최소 하나의 쓰레드로부터 실행하는데, 이를 primary thread라고 부른다.

File Explorer을 두 개를 켜면 하나의 프로그램 하에 두 개의 프로세스가 생성된다.

----
쓰레드(thread)는 실행을 위해 스케쥴될 수 있는, 프로세스를 구성하는 가장 작은 단위이다. 사실상 쓰레드가 실행에 있어 핵심이고, 프로세스는 이를 담는 instance라는 형태의 container라고 볼 수 있을거다. 단, 그 instance 안에는 코드 실행 외에도 프로세스 정보를 담고 있다.

> 어차피 프로세스는 기본적으로 primary thread를 생성하고, 하나의 쓰레드만으로도 프로세스가 수행되어야 할 작업을 처리할 수 있다.

비록 프로세스 간에는 가상주소공간으로 고립되었지만, 프로세스 안에 있는 쓰레드 간에는 동일한 가상주소공간 및 시스템 리소스를 공유한다. (CUDA에서 이런 내용 있던거 같던데...)

# 멀티태스킹
멀티태스킹은 프로세스 혹은 쓰레드가 (실행하기 위해) 필요로 하는 프로세서 사용 시간을 운영체제에서 나눈다.

시스템은 preemptive 멀티태스킹을 위해 설계되었다: 프로세서 time slice를 실행되는 각 쓰레드마다 할당한다. 그리고 실행되는 쓰레드의 할당된 time slice 타이머가 끝나면 다른 쓰레드가 실행된다. 해당 과정에서 선제적으로 실행된 쓰레드는 큐에 저장하고, 큐에서 대기하던 다음 쓰레드를 불러온다.

## 장점
사용자 관점:
멀티태스킹을 하면 여러 어플리케이션을 동시에 사용할 수 있다. (Word 프로세스 종료를 해야 Excel 프로세스를 사용하는게 아닌) Word와 Excel 어플리케이션을 동시에 사용할 수 있다.

개발자 관점:
멀티태스킹 덕분에 하나 이상의 프로세스를 사용하는 어플리케이션 혹은 하나 이상의 쓰레드를 사용하는 프로세스를 개발할 수 있다. 하나는 사용자 입력을 받는 쓰레드로 항시 대기되어야 하고, 그리고 다른 하나는 입력을 받는 거 이외의 다른 작업을 하는 등처럼 말이다.

## 언제 활용해야 하나?
멀티태스킹은...

(1) 단일 프로세스에 여러 쓰레드
(2) 여러 프로세스에서 각각 하나 이상의 쓰레드

...으로 접근할 수 있다. 나머지 쓰레드로부터 보호되어야 하거나 접근되지 말아야 하는 메모리 공간이나 리소스의 경우에는 별도의 프로세스가 사용된다.

일반적으로 어플리케이션이 하나의 프로세스에서 여러 쓰레드를 사용하는게 더 효율적이다.

* context switching을 쓰레드가 프로세스보다 더 빨리 할 수 있다. 여기서 context란, 해당 작업(process, thread, 혹은 fiber 등)이 잠시 인터럽트되어 나중에 다시 진행하기 위해 필요한 최소한의 데이터 집합이다. 그러니 context 크기가 작으면 스위칭이 더 빠르다는 것이다. 하지만 프로세스의 context는 쓰레드의 context보다 커서 수행 시간이 더 걸리는, 즉 overhead가 발생한다.

* 쓰레드는 동일한 주소 공간 및 리소스를 공유하기 때문에 쓰레드 간 통신이 빠르다. 

## 주의사항
시스템 리소스 사용을 최소화하기 위해 쓰레드를 적게 사용하는 것을 권고하며, 그러므로써 성능을 향상시킨다.

* 많은 양의 쓰레드는 프로세서 시간을 꾀나 소모하며 실행의 진척이 더디어진다. 실행되는 쓰레드가 하나의 프로세스에 집중되어 있으면 다른 프로세스의 쓰레드는 더 드믈게 스케쥴링된다.

공유된 리소스를 접근한다는 것은 충돌을 일으킬 수 있어 접근에 있어 동기화를 시켜야 한다. 특히 멀티태스킹으로 시스템 리소스를 접근하거나(직렬 포트 접근 등), 다중 프로세스 간에 공유되는 리소스를 접근하거나(파일 핸들 등), 하나의 프로세스 리소스를 여러 쓰레드가 접근(전역변수 등)할 때 말이다.

접근 동기화 실패 시 데드락이나 race condition 문제가 발생한다.

# 스케쥴링
시스템 scheduler는 대기 중인 쓰레드 중에서 누가 다음 프로세서 time slice를 할당 받을건지 결정하면서 멀티태스킹을 제어한다. 이는 scheduling 우선권으로 결정된다.

## scheduling priority
쓰레드는 각자 주어진 스케쥴링 우선권에 따라 스케쥴링된다. 우선권은 0(최하)~31(최상)으로 나뉘며, 오로지 zero-page 쓰레드(실행되어야 할 쓰레드가 없을 때 투입되는 시스템 쓰레드이며, 이전 데이터가 담겼던 페이지를 0으로 채워 비워두는 작업이다; 이전 프로세스의 데이터가 들어있으면 발생할 수 있는 보안 문제를 방지하기 위한 것)만이 최하 0번 순위를 가질 수 있다.

시스템은 동일한 우선권을 갖는 쓰레드를 평등하게 취급한다. 평등하게 할당하기 위해 round-robin, 즉 원형으로 나열하여 동일한 우선권의 쓰레드 사이에서도 서열을 구분짓지 않은 채로 돌아가며 time slice를 할당한다. 만일 실행할 준비가 된 쓰레드가 없으면 차우선권의 쓰레드로 가서 동일한 방법으로 time slice를 할당한다. 그러다가 상위 우선권의 쓰레드가 실행할 준비가 되었으면 시스템은 낮은 우선권을 갖는 쓰레드 실행을 (time slice가 끝나지 않았음에도) 도중에 중단시키고 full time slice를 실행 준비된 상위 우선권의 쓰레드에게 할당한다. [Context Switch 참조](#context_switching)

쓰레드 우선권은 다음 기준으로 결정된다:

* 프로세스의 우선권 클래스 (프로세스 정보 중 하나)

    default 프로세스 우선권은 `NORMAL_PRIORITY_CLASS`이다.

    * `IDLE_PRIORITY_CLASS`
        : screensaver, 주기적 application gui 업데이트
    * `BELOW_NORMAL_PRIORITY_CLASS`
    * `NORMAL_PRIORITY_CLASS`
    * `ABOVE_NORMAL_PRIORITY_CLASS`
    * `HIGH_PRIORITY_CLASS`
        : 장시간 사용시 나머지 쓰레드가 프로세서 시간을 얻지 못한다. 몇개의 쓰레드가 동시에 해당 우선권으로 설정되면 쓰레드는 효율성이 잃게 된다. 오로지 타이밍에 민감한 동작에 사용하도록! 그러므로 매우 주의해서 사용해야 함!
    * `REALTIME_PRIORITY_CLASS`
        : 키보드/마우스 입력 등을 처리하며, 하드웨어 상호작용이 아닌 이상 사용 금지!

* 프로세스 우선권 클래스 내의 쓰레드 우선권 레벨 (쓰레드 정보 중 하나)
    
    defualt 쓰레드 우선권은 `THREAD_PRIORITY_NORMAL`이다.

    * `THREAD_PRIORITY_IDLE`
    * `THREAD_PRIORITY_LOWEST`
    * `THREAD_PRIORITY_BELOW_NORMAL`
    * `THREAD_PRIORITY_NORMAL`
    * `THREAD_PRIORITY_ABOVE_NORMAL`
    * `THREAD_PRIORITY_HIGHEST`
    * `THREAD_PRIORITY_TIME_CRITICAL`

우선권 클래스와 레벨의 조합으로 쓰레드의 base priority가 형성된다.

## context switching
스케쥴러는 실행가능한 쓰레드들(aka. ready threads)의 큐를 각 우선권마다 관리한다. 사용 가능한 프로세서가 있으면 시스템은 context switch를 아래의 단계대로 수행한다.

1. 방금 실행을 마친 쓰레드의 context를 저장한다.
2. 방금 실행을 마친 쓰레드는 해당하는 우선권 큐의 맨 마지막에 위치시킨다.
3. ready thread가 있는 가장 높은 우선권 큐를 찾는다.
4. 큐 앞단의 쓰레드를 꺼내와서 해당 쓰레드 context를 불러와 실행한다.

contect switch가 발생하는 대표적인 요인은...

* time slice 마무리
* 진행되는 중이라도 더 높은 우선권의 쓰레드가 ready인 상태
* 실행되는 쓰레드가 대기해야 할 때

그러나 아래의 쓰레드는 ready thread가 아니다. 즉, 이들은 우선권이 높거나 사용할 수 있는 프로세서가 있어도 time slice를 할당받지 않는다.

* `CREATE_SUSPENDED` 플래그로 생성된 쓰레드
* 실행 도중에 `SuspendThread` 혹은 `SwitchToThread` 함수로 인해 중단된 쓰레드
* 동기화 객체 또는 입력을 기다리는 쓰레드

## 우선권 boost
각 쓰레드는 dynamic priority를 갖으며, 이것을 통해 스케쥴러가 어떤 쓰레드가 실행할지 결정한다. 일반적으로 dynamic priority는 base priority와 동일하나 시스템에서 dynamic priority를 올리거나 원상복구 시킬 수 있다 (boost 대상: 0~15). 이를 통해 시스템이 즉각적이고 프로세서 타임에 목마른 쓰레드가 발생하지 않게 만든다.

여기서 즉각적인 시스템이란 말이 무엇이냐 하면...

* `NORMAL_PRIORITY_CLASS` 우선권의 프로세스가 foreground로 불려졌으면 스케쥴러는 해당 프로세스의 우선권을 부스트시켜 background 프로세스보다 높게 만들어준다. 그리고 foreground에 없으면 다시 원래 우선권으로 되돌린다.

* 어느 창이 타이머, 마우스, 또는 키보드 메시지를 수신받으면 스케쥴러는 해당 창을 소유하는 쓰레드의 우선권을 부스트시킨다.

* 대기 조건으로 막힌 쓰레드가 조건을 드디어 충족하면 스케쥴러는 막혔던 쓰레드의 우선권을 높여준다.

하지만 이러한 우선권 부스팅은 `SetProcessPriorityBoost` 혹은 `SetThreadPriorityBoost` 함수를 호출하여 비활성 시킬 수 있다.

dynamic priority를 부스팅하였으면, 스케줄러는 단번에 base priority로 내리지 않고 매 time slice마다 우선권을 하나씩 낮춘다. 그러나 절대로 dynamic priority는 base priority보다 낮을 수 없다.

## 우선권 inversion
우선권 반전은 우선권이 다른 쓰레드 두 개 이상이 스케쥴링에서 대치되고 있을 때 발생한다.

> 쓰레드 1은 상위 우선권으로 스케쥴 준비가 되었다.
> 쓰레드 2는 하위 우선권으로 중요한 부분의 코드를 실행하고 있다.
> 쓰레드 1은 공유 리소스 떄문에 쓰레드 2가 마무리할 때까지 기다린다.
> 쓰레드 3은 중간 우선권이다.
> 쓰레드 1은 공유 리소스로부터 대기 상태에 결려 쓰레드 3이 프로세서 타임을 할당받는다.
> 쓰레드 2는 쓰레드 3보다 낮은 우선권 때문에 스케쥴링으로 인해 중요한 코드 부분을 떠나지 못한다.

이러한 경우를 대비하여 스케쥴러는 무작위로 ready thread의 우선권을 부스팅 시킨다 (위의 경우에는 하위 우선권의 쓰레드 2). 그러면 쓰레드 2는 중요한 부분 실행을 마무리할 만큼 남을 수 있어, 종료되면 상위 우선권이 진입할 수 있다.

## 다중 프로세서
여러 프로세서를 갖는 컴퓨터는 일반적으로 둘 중 하나의 아키텍처를 위해 설계되어 있다: 비균일 메모리 접속(non-uniform memory access; NUMA) 혹은 대칭형 멀티프로세싱(symmetric multiprocessing; SMP)

NUMA 컴퓨터의 각 프로세서는 메모리의 일부분을 더 빨리 접속하기 위해 메모리의 다른 부분에 비하여 더 가깝게 위치한다. NUMA 모델 하에서, 시스템은 쓰레드가 위치하고 있는 메모리 부분과 가장 가까운 프로세서에 스케쥴하려 한다.

SMP 컴퓨터는 두 개 이상의 동등한 프로세서 혹은 코어가 하나의 공용 메모리에 연결된다. SMP 모델 하에서, any 쓰레드는 any 프로세서에 할당될 수 있다. 즉, SMP 컴퓨터에서 쓰레드 스케쥴링은 단일 프로세서에서 스케쥴링하는 것과 유사하다. 다만 스케쥴러는 프로세서 목록이 있으므로, 쓰레드를 동시간에 실행시킬 수 있다는 차이가 있다. 스케쥴링은 여전히 쓰레드 우선권에 의해 결정되지만 thread affinity와 thread ideal processor 설정의 영향을 받을 수 있다.

### Thread Affinity
(later...)

### Thread Ideal Processor
(later...)

## NUMA 지원
(later...)

## Thread Ordering Service
Thread ordering service는 하나 이상의 client thread 실행을 제어한다. 각 client thread가 주어진 시간 안에 순서대로 한 번 실행하도록 보장한다.

thread ordering service는 기본적으로 비활성화되어 사용자가 직접 시작시켜야 한다. thread ordering service가 실행되는 중에 시스템이 idle 상태에서도 매5초마다 새로운 요청이 있는지 확인한다. 이는 시스템이 5초 이상 sleep 상태로 유지되는 것을 방지하여 전력을 더 많이 소모하게 만든다. 만일 에너지 효율성이 어플리케이션에서 매우 중요하게 작용하면 오히려 시스템 스케쥴러를 통해 쓰레드 실행을 관리하도록 한다.

## 멀티미디어 클래스 스케쥴러 서비스
(later...)

## 프로세서 그룹
(later...)

## Quality of Service
쓰레드에 연동된 QoS는 원하는 성능 및 전력 효율성을 가리키는데 사용된다. 각 쓰레드는 QoS 레벨에 할당된다. 스케쥴링 우선권이 어떠한 쓰레드를 다음으로 스케쥴링 할 것인지 결정하는 주요 척도로 작용하지만, QoS는 코어 선택 및 프로세서 전력 관리에 영향을 준다. 서로 다른 프로세서들로 이루어진 플랫폼에서 쓰레드의 QoS는 특정 프로세서로의 스케쥴링을 제한 또는 선호한다고 알려줄 수 있다.

# Multiple Threads
쓰레드는 프로세스 내에 위치하여 실행을 위해 스케쥴링될 수 있는 존재이다. 모든 쓰레드는 프로세스의 가상주소공간 및 시스템 리소스를 공유한다. 각 프로세스는 모두 단일 쓰레드로 시작하지만 어느한 쓰레드로부터서라도 새로운 쓰레드를 생성할 수 있다.

## 쓰레드 스택 크기