---
layout: docs
language: ko
category: 운영체제
title: 프로세스
meta: Process
order: 0x40
---
# 프로세스: 소개
> https://docs.microsoft.com/en-us/windows/win32/procthread/processes-and-threads

어플리케이션(application; 응용 프로그램): 컴퓨터 동작시키는 것 외에 특정 작업을 수행하기 위해 설계된 executable 소프트웨어(즉, 명령어 집합)이다. 어플리케이션이 특정 작업을 수행하기 위해 한 개 이상의 프로세스(process)를 생성한다.

----
프로세스는 어플리케이션을 실행할 때, 컴파일된 (기계어) 명령어 집합을 이행하는 객체이다. 각 프로세스마다 (커널로부터) 가상주소공간이 할당되고, 해당 가상주소공간은 프로세스의 컴파일된 executable 기계어 코드가 위치한 storage memroy (HDD, SSD etc)에 맵핑되어 실행된다. 즉, 컴파일된 executable이 RAM에 로드되지 않는다.

> think whether if 100GB game file able to load to 16GB RAM...of coures not!

각 프로세스의 가상주소공간은 고립형이므로 프로세스 하나에 문제가 생겨도 타 프로세스에 영향을 주지 않는다. 프로세스는 가상주소공간에서 최소 하나의 쓰레드로부터 실행하는데, 이를 primary thread라고 부른다.

File Explorer을 두 개를 켜면 하나의 프로그램 하에 두 개의 프로세스가 생성된다.

----
쓰레드(thread)는 실행을 위해 스케쥴될 수 있는, 프로세스를 구성하는 가장 작은 단위이다. 사실상 쓰레드가 실행에 있어 핵심이고, 프로세스는 이를 담는 instance라는 형태의 container라고 볼 수 있을거다. 단, 그 instance 안에는 코드 실행 외에도 프로세스 정보를 담고 있다.

> 어차피 프로세스는 기본적으로 primary thread를 생성하고, 하나의 쓰레드만으로도 프로세스가 수행되어야 할 작업을 처리할 수 있다.

비록 프로세스 간에는 가상주소공간으로 고립되었지만, 프로세스 안에 있는 쓰레드 간에는 동일한 가상주소공간 및 시스템 리소스를 공유한다. (CUDA에서 이런 내용 있던거 같던데...)

# 멀티태스킹
멀티태스킹은 프로세스 혹은 쓰레드가 (실행하기 위해) 필요로 하는 프로세서 사용 시간을 운영체제에서 나눈다.

시스템은 preemptive 멀티태스킹을 위해 설계되었다: 프로세서 time slice를 실행되는 각 쓰레드마다 할당한다. 그리고 실행되는 쓰레드의 할당된 time slice 타이머가 끝나면 다른 쓰레드가 실행된다. 해당 과정에서 선제적으로 실행된 쓰레드는 큐에 저장하고, 큐에서 대기하던 다음 쓰레드를 불러온다.

## 장점
사용자 관점:
멀티태스킹을 하면 여러 어플리케이션을 동시에 사용할 수 있다. (Word 프로세스 종료를 해야 Excel 프로세스를 사용하는게 아닌) Word와 Excel 어플리케이션을 동시에 사용할 수 있다.

개발자 관점:
멀티태스킹 덕분에 하나 이상의 프로세스를 사용하는 어플리케이션 혹은 하나 이상의 쓰레드를 사용하는 프로세스를 개발할 수 있다. 하나는 사용자 입력을 받는 쓰레드로 항시 대기되어야 하고, 그리고 다른 하나는 입력을 받는 거 이외의 다른 작업을 하는 등처럼 말이다.

## 언제 활용해야 하나?
멀티태스킹은...

(1) 단일 프로세스에 여러 쓰레드
(2) 여러 프로세스에서 각각 하나 이상의 쓰레드

...으로 접근할 수 있다. 나머지 쓰레드로부터 보호되어야 하거나 접근되지 말아야 하는 메모리 공간이나 리소스의 경우에는 별도의 프로세스가 사용된다.

일반적으로 어플리케이션이 하나의 프로세스에서 여러 쓰레드를 사용하는게 더 효율적이다.

* context switching을 쓰레드가 프로세스보다 더 빨리 할 수 있다. 여기서 context란, 해당 작업(process, thread, 혹은 fiber 등)이 잠시 인터럽트되어 나중에 다시 진행하기 위해 필요한 최소한의 데이터 집합이다. 그러니 context 크기가 작으면 스위칭이 더 빠르다는 것이다. 하지만 프로세스의 context는 쓰레드의 context보다 커서 수행 시간이 더 걸리는, 즉 overhead가 발생한다.

* 쓰레드는 동일한 주소 공간 및 리소스를 공유하기 때문에 쓰레드 간 통신이 빠르다. 

## 주의사항
시스템 리소스 사용을 최소화하기 위해 쓰레드를 적게 사용하는 것을 권고하며, 그러므로써 성능을 향상시킨다.

* 많은 양의 쓰레드는 프로세서 시간을 꾀나 소모하며 실행의 진척이 더디어진다. 실행되는 쓰레드가 하나의 프로세스에 집중되어 있으면 다른 프로세스의 쓰레드는 더 드믈게 스케쥴링된다.

공유된 리소스를 접근한다는 것은 충돌을 일으킬 수 있어 접근에 있어 동기화를 시켜야 한다. 특히 멀티태스킹으로 시스템 리소스를 접근하거나(직렬 포트 접근 등), 다중 프로세스 간에 공유되는 리소스를 접근하거나(파일 핸들 등), 하나의 프로세스 리소스를 여러 쓰레드가 접근(전역변수 등)할 때 말이다.

접근 동기화 실패 시 데드락이나 race condition 문제가 발생한다.

# 스케쥴링
시스템 scheduler는 대기 중인 쓰레드 중에서 누가 다음 프로세서 time slice를 할당 받을건지 결정하면서 멀티태스킹을 제어한다. 이는 scheduling 우선권으로 결정된다.

## scheduling priority
쓰레드는 각자 주어진 스케쥴링 우선권에 따라 스케쥴링된다. 우선권은 0(최하)~31(최상)으로 나뉘며, 오로지 zero-page 쓰레드(실행되어야 할 쓰레드가 없을 때 투입되는 시스템 쓰레드이며, 이전 데이터가 담겼던 페이지를 0으로 채워 비워두는 작업이다; 이전 프로세스의 데이터가 들어있으면 발생할 수 있는 보안 문제를 방지하기 위한 것)만이 최하 0번 순위를 가질 수 있다.

시스템은 동일한 우선권을 갖는 쓰레드를 평등하게 취급한다. 평등하게 할당하기 위해 round-robin, 즉 원형으로 나열하여 동일한 우선권의 쓰레드 사이에서도 서열을 구분짓지 않은 채로 돌아가며 time slice를 할당한다. 만일 실행할 준비가 된 쓰레드가 없으면 차우선권의 쓰레드로 가서 동일한 방법으로 time slice를 할당한다. 그러다가 상위 우선권의 쓰레드가 실행할 준비가 되었으면 시스템은 낮은 우선권을 갖는 쓰레드 실행을 (time slice가 끝나지 않았음에도) 도중에 중단시키고 full time slice를 실행 준비된 상위 우선권의 쓰레드에게 할당한다. [Context Switch 참조](#context_switching)

쓰레드 우선권은 다음 기준으로 결정된다:

* 프로세스의 우선권 클래스 (프로세스 정보 중 하나)

    default 프로세스 우선권은 `NORMAL_PRIORITY_CLASS`이다.

    * `IDLE_PRIORITY_CLASS`
        : screensaver, 주기적 application gui 업데이트
    * `BELOW_NORMAL_PRIORITY_CLASS`
    * `NORMAL_PRIORITY_CLASS`
    * `ABOVE_NORMAL_PRIORITY_CLASS`
    * `HIGH_PRIORITY_CLASS`
        : 장시간 사용시 나머지 쓰레드가 프로세서 시간을 얻지 못한다. 몇개의 쓰레드가 동시에 해당 우선권으로 설정되면 쓰레드는 효율성이 잃게 된다. 오로지 타이밍에 민감한 동작에 사용하도록! 그러므로 매우 주의해서 사용해야 함!
    * `REALTIME_PRIORITY_CLASS`
        : 키보드/마우스 입력 등을 처리하며, 하드웨어 상호작용이 아닌 이상 사용 금지!

* 프로세스 우선권 클래스 내의 쓰레드 우선권 레벨 (쓰레드 정보 중 하나)
    
    defualt 쓰레드 우선권은 `THREAD_PRIORITY_NORMAL`이다.

    * `THREAD_PRIORITY_IDLE`
    * `THREAD_PRIORITY_LOWEST`
    * `THREAD_PRIORITY_BELOW_NORMAL`
    * `THREAD_PRIORITY_NORMAL`
    * `THREAD_PRIORITY_ABOVE_NORMAL`
    * `THREAD_PRIORITY_HIGHEST`
    * `THREAD_PRIORITY_TIME_CRITICAL`

우선권 클래스와 레벨의 조합으로 쓰레드의 base priority가 형성된다.

## context switching
스케쥴러는 실행가능한 쓰레드들(aka. ready threads)의 큐를 각 우선권마다 관리한다. 사용 가능한 프로세서가 있으면 시스템은 context switch를 아래의 단계대로 수행한다.

1. 방금 실행을 마친 쓰레드의 context를 저장한다.
2. 방금 실행을 마친 쓰레드는 해당하는 우선권 큐의 맨 마지막에 위치시킨다.
3. ready thread가 있는 가장 높은 우선권 큐를 찾는다.
4. 큐 앞단의 쓰레드를 꺼내와서 해당 쓰레드 context를 불러와 실행한다.

contect switch가 발생하는 대표적인 요인은...

* time slice 마무리
* 진행되는 중이라도 더 높은 우선권의 쓰레드가 ready인 상태
* 실행되는 쓰레드가 대기해야 할 때

그러나 아래의 쓰레드는 ready thread가 아니다. 즉, 이들은 우선권이 높거나 사용할 수 있는 프로세서가 있어도 time slice를 할당받지 않는다.

* `CREATE_SUSPENDED` 플래그로 생성된 쓰레드
* 실행 도중에 `SuspendThread` 혹은 `SwitchToThread` 함수로 인해 중단된 쓰레드
* 동기화 객체 또는 입력을 기다리는 쓰레드

## 우선권 boost
각 쓰레드는 dynamic priority를 갖으며, 이것을 통해 스케쥴러가 어떤 쓰레드가 실행할지 결정한다. 일반적으로 dynamic priority는 base priority와 동일하나 시스템에서 dynamic priority를 올리거나 원상복구 시킬 수 있다 (boost 대상: 0~15). 이를 통해 시스템이 즉각적이고 프로세서 타임에 목마른 쓰레드가 발생하지 않게 만든다.

여기서 즉각적인 시스템이란 말이 무엇이냐 하면...

* `NORMAL_PRIORITY_CLASS` 우선권의 프로세스가 foreground로 불려졌으면 스케쥴러는 해당 프로세스의 우선권을 부스트시켜 background 프로세스보다 높게 만들어준다. 그리고 foreground에 없으면 다시 원래 우선권으로 되돌린다.

* 어느 창이 타이머, 마우스, 또는 키보드 메시지를 수신받으면 스케쥴러는 해당 창을 소유하는 쓰레드의 우선권을 부스트시킨다.

* 대기 조건으로 막힌 쓰레드가 조건을 드디어 충족하면 스케쥴러는 막혔던 쓰레드의 우선권을 높여준다.

하지만 이러한 우선권 부스팅은 `SetProcessPriorityBoost` 혹은 `SetThreadPriorityBoost` 함수를 호출하여 비활성 시킬 수 있다.

dynamic priority를 부스팅하였으면, 스케줄러는 단번에 base priority로 내리지 않고 매 time slice마다 우선권을 하나씩 낮춘다. 그러나 절대로 dynamic priority는 base priority보다 낮을 수 없다.

## 우선권 inversion
우선권 반전은 우선권이 다른 쓰레드 두 개 이상이 스케쥴링에서 대치되고 있을 때 발생한다.

> 쓰레드 1은 상위 우선권으로 스케쥴 준비가 되었다.
> 쓰레드 2는 하위 우선권으로 중요한 부분의 코드를 실행하고 있다.
> 쓰레드 1은 공유 리소스 떄문에 쓰레드 2가 마무리할 때까지 기다린다.
> 쓰레드 3은 중간 우선권이다.
> 쓰레드 1은 공유 리소스로부터 대기 상태에 결려 쓰레드 3이 프로세서 타임을 할당받는다.
> 쓰레드 2는 쓰레드 3보다 낮은 우선권 때문에 스케쥴링으로 인해 중요한 코드 부분을 떠나지 못한다.

이러한 경우를 대비하여 스케쥴러는 무작위로 ready thread의 우선권을 부스팅 시킨다 (위의 경우에는 하위 우선권의 쓰레드 2). 그러면 쓰레드 2는 중요한 부분 실행을 마무리할 만큼 남을 수 있어, 종료되면 상위 우선권이 진입할 수 있다.

## 다중 프로세서
여러 프로세서를 갖는 컴퓨터는 일반적으로 둘 중 하나의 아키텍처를 위해 설계되어 있다: 비균일 메모리 접속(non-uniform memory access; NUMA) 혹은 대칭형 멀티프로세싱(symmetric multiprocessing; SMP)

NUMA 컴퓨터의 각 프로세서는 메모리의 일부분을 더 빨리 접속하기 위해 메모리의 다른 부분에 비하여 더 가깝게 위치한다. NUMA 모델 하에서, 시스템은 쓰레드가 위치하고 있는 메모리 부분과 가장 가까운 프로세서에 스케쥴하려 한다.

SMP 컴퓨터는 두 개 이상의 동등한 프로세서 혹은 코어가 하나의 공용 메모리에 연결된다. SMP 모델 하에서, any 쓰레드는 any 프로세서에 할당될 수 있다. 즉, SMP 컴퓨터에서 쓰레드 스케쥴링은 단일 프로세서에서 스케쥴링하는 것과 유사하다. 다만 스케쥴러는 프로세서 목록이 있으므로, 쓰레드를 동시간에 실행시킬 수 있다는 차이가 있다. 스케쥴링은 여전히 쓰레드 우선권에 의해 결정되지만 thread affinity와 thread ideal processor 설정의 영향을 받을 수 있다.

### Thread Affinity
(later...)

### Thread Ideal Processor
(later...)

## NUMA 지원
(later...)

## Thread Ordering Service
Thread ordering service는 하나 이상의 client thread 실행을 제어한다. 각 client thread가 주어진 시간 안에 순서대로 한 번 실행하도록 보장한다.

thread ordering service는 기본적으로 비활성화되어 사용자가 직접 시작시켜야 한다. thread ordering service가 실행되는 중에 시스템이 idle 상태에서도 매5초마다 새로운 요청이 있는지 확인한다. 이는 시스템이 5초 이상 sleep 상태로 유지되는 것을 방지하여 전력을 더 많이 소모하게 만든다. 만일 에너지 효율성이 어플리케이션에서 매우 중요하게 작용하면 오히려 시스템 스케쥴러를 통해 쓰레드 실행을 관리하도록 한다.

## 멀티미디어 클래스 스케쥴러 서비스
(later...)

## 프로세서 그룹
(later...)

## Quality of Service
쓰레드에 연동된 QoS는 원하는 성능 및 전력 효율성을 가리키는데 사용된다. 각 쓰레드는 QoS 레벨에 할당된다. 스케쥴링 우선권이 어떠한 쓰레드를 다음으로 스케쥴링 할 것인지 결정하는 주요 척도로 작용하지만, QoS는 코어 선택 및 프로세서 전력 관리에 영향을 준다. 서로 다른 프로세서들로 이루어진 플랫폼에서 쓰레드의 QoS는 특정 프로세서로의 스케쥴링을 제한 또는 선호한다고 알려줄 수 있다.

# Multiple Threads
쓰레드는 프로세스 내에 위치하여 실행을 위해 스케쥴링될 수 있는 존재이다. 모든 쓰레드는 프로세스의 가상주소공간 및 시스템 리소스를 공유한다. 각 프로세스는 모두 단일 쓰레드로 시작하지만 어느한 쓰레드로부터서라도 새로운 쓰레드를 생성할 수 있다.

## 쓰레드 스택 크기
각 쓰레드 혹은 fiber는 초기 (thread 혹은 fiber에) committed 메모리(참조될 때까지 해당 메모리 페이지들은 물리적 메모리 사용하지 않음) 및 reserved 메모리(크기: 가상 메모리에 할당된 총 스택 크기, 즉 가상주소 범위 내로 한정!)로 구성된 자신만의 스택 공간을 받는다.

> 페이지(page)란, 일정한 크기로 나뉘어진 운영체제에서 관리하는 가장 작은 단위의 가상 메모리이다.

> 시스템 최대 commit 한계 크기: 페이지 파일 (보조기억장치가 RAM 물리적 메모리처럼 사용되는 부분) + 물리적 메모리 크기

시스템은 필요에 따라 reserved 페이지를 쓰레드 혹은 fiber에 commit하는데 위해 사용할 수 있고, 최대 (최대 reserved 크기 - 1)까지 가능하며 이는 스택 오버플로우를 방지하는 차원이다. 

안정적으로 쓰레드 혹은 fiber가 동작할 수 있도록 가능한 작은 스택 크기를 선정하고 필요로 하면 스택에 commit하는 것이 좋다. 스택으로 reserved 된 모든 페이지들은 그 외의 용도로는 사용할 수 없다.

스택은 쓰레드가 exit되면 할당이 해제된다. 그러나 다른 쓰레드로부터 terminated되면 그대로 남아있는다.

reserved 및 initially committed 스택 메모리의 기본 크기는 실행파일 헤더에 명시되어 있다. 만일 요청한 바이트 크기만큼의 reserved 또는 initially committed 메모리를 생성하지 못하면 쓰레드 혹은 fiber 생성은 실패한다. 기본 스택 크기는 1MB이다. 이를 변경하려면 `.def` 모듈 정의 파일에서 `STACKSIZE`문을 사용한다.

## 쓰레드 핸들 및 식별자
만일 `CreateThread` 혹은 `CreateRemoteThread` 함수로 새로운 쓰레드가 생성되었으면, 그에 대한 핸들이 반환된다. 기본적으로 핸들은 모든 권한을 갖으며, "보안성 접근 확인"을 이유로 쓰레드 핸들을 인자로 받는 아무런 함수에 사용될 수 있다. 해당 쓰레드 핸들은 (쓰레드 생성 때 설정한 플래그에 따라) 자식 프로세스가 상속받을 수 있다 (아마 자식 프로세스의 primary 쓰레드를 위한 것). 핸들을 복제시켜 제한된 권한을 갖는 쓰레드 핸들을 만들 수 있다. 핸들은 쓰레드가 끝날 때까지, 심지어 terminated 될 때까지 유효하다.

`CreateThread` 혹은 `CreateRemoteThread` 함수는 핸들 외에도 시스템에 통틀어 쓰레드를 구별할 수 있는 고유의 식별자를 반환한다. 그러니 만일 쓰레드 식별자를 알고 있으면 그에 대한 핸들을 `OpenThread` 함수를 호출하여 불러올 수 있으며, 접속 권한 및 상속가능여부 또한 설정할 수 있다.

`GetCurrentThread`를 통해 현재 실행되고 있는 쓰레드의 pseudo 핸들을 가져올 수 있다. 그러나 이는 프로세스 호출을 위해서만 사용할 수 있으며, 다른 프로세스로의 상속 및 복제는 불가하다. 만일 pseudo 핸들로부터 실제 핸들을 가져오려면 해당 프로세스에서 `DuplicateHandle` 함수를 사용한다.

## suspending 쓰레드 실행
쓰레드는 다른 쓰레드의 실행을 유예 및 재개할 수 있다. 유예되는 동안 프로세서로의 시간이 스케쥴링되지 않는다.

쓰레드가 (`CREATE_SUSPENDED` 플래그로부터) 유예 상태로 생성되었다면 다른 쓰레드가 `ResumeThread` 함수를 사용하지 않는 한 실행되지 않는다. 이는 쓰레드가 실행되기 전에 쓰레드의 상태를 초기화하는데 유용하다. 특히 `ResumeThread` 함수로 실행시킬 수 있으므로 one-time 동기화에서도 유용하다.

반면 도중에서 유예시키는 `SuspendThread` 함수는 쓰레드 동기화를 목적으로 사용되지 않으며, 이는 쓰레드의 어느 특정 코드에서 실행을 유예시키지 않기 때문이다. 해당 함수는 디버깅을 위해 사용된다.

`Sleep` 또는 `SleepEx` 함수로 특정 시간동안 실행을 임시적으로 보류할 수 있다. Sleep 도중에는 프로세서 타임을 할당받지 않는다.

`SwitchToThread`는 Sleep과 유사하지만 시간을 정할 수 없다. 이는 쓰레드에게 할당된 time slice를 포기하도록 한다.

## 여러 쓰레드의 실행 동기화
race condition이나 deadlock을 방지하기 위해, 여러 쓰레드의 공용 리소스 접속은 동기화시킬 필요가 있다. 동기화는 또한 상호의존 코드가 적합한 순서로 실행되도록 한다.

다음은 여러 쓰레드의 동기화에 사용될 수 있는 객체 핸들의 목록이다:
* 콘솔 입력 버퍼
* 이벤트
* mutexes
* 프로세스
* Semaphores
* 쓰레드
* 타이머

위의 핸들이 갖는 상태는 signaled 되었는지의 여부이다. 만일 쓰레드 핸들을 위의 어느한 객체와 함께 wait function에 사용하면, 쓰레드는 위의 어느한 객체가 signaled 될 때까지 쓰레드 실행이 막힌다.

이들 중에서는 이벤트가 실행될 때까지 실행을 막는 객체가 있다. 콘솔 입력 버퍼와 같은 경우에는 읽히지 않은 입력(마우스 클릭이나 키보드 버튼 클릭)이 있으면 signaled가 된다. 프로세스나 쓰레드는 terminated 될 때 signaled 된다.

동시다발적 공용 리소스 접속으로부터 보호하데 유용한 객체도 있다. 여러 쓰레드 중에서 각 쓰레드는 하나의 mutex 객체의 핸들을 갖는다. 공용 리소스를 접속하기 전에 쓰레드는 wait function을 통해 mutex 객체가 signaled 할 때까지 기다린다. 만일 mutex 객체가 signaled 하였으면 대기 중인 쓰레드 하나만이 공용 리소스에 접근하며, mutex는 곧바로 non-signaled로 되돌아가 나머지 쓰레드의 접근을 막는다. 접근한 쓰레드가 공용 리소스 사용을 마쳤으면 다음 쓰레드가 접속할 수 있도록 mutex 객체의 상태를 signaled로 설정해 주어야 한다.

단일 프로세스의 다중 쓰레드의 경우, mutex 객체보다 critical-section 객체로 동기화하여 사용하는게 더 효율적이다

### GDI 객체의 멀티쓰레드
성능향상을 위해 GDI(그래픽 디바이스 인터페이스; palette, device contexts...MFC에서 본 것들인데????) 접속은 serialized 되어있지 않다. 이는 GDI를 공유하는 여러 쓰레드 간에 접속하려는 잠재적 위험을 프로세스에 가져온다. 공유가 불가피하다면 어플리케이션은 자체적 동기화 매커니즘을 제공해야 한다.

## 쓰레드 로컬 storage
프로세스 내의 모든 쓰레드는 하나의 가상주소공간을 공유하여 쓰레드가 접속할 수 있는 데이터는 전역적이다. 그러나 각 쓰레드마다 자신들만이 접속할 수 있는 지역적 데이터를 만들려면 쓰레드 로컬 storage(TLS)를 사용한다.

쓰레드 내에서 지역적 데이터를 저장하는 공간을 TLS slot이라고 부른다: NULL 초기화된 `LPVOID` 자료형 배열이다. Microsoft Docs 문서에서는 시스템에서 할당한다고 하지만, 사실은 개발자가 직접 heap 영역에 공간을 확보한 것이다.

그리고 TLS slot 중에서 어디를 접속할 것인지는 TLS index로 결정한다: `TlsAlloc` 함수로 TLS 인덱싱 영역을 확보한다. 아마 민감한 부분이라서 별도로 할당 함수를 만든게 아닌가 싶다. 그러나 TLS index는 전역 데이터이므로, 지역 데이터를 접속한다 하더라도 전역 데이터가 필요하다.

TLS index에 데이터 입력 및 호출운 `TlsSetValue` 및 `TlsGetValue`로 이루어진다.
그리고 TLS index 할당을 해제하기 위해 `TlsFree` 함수를 사용한다.

## terminating 쓰레드
쓰레드 terminate은 다음과 같은 결과를 초래한다:

* 쓰레드가 갖고 있던 리소스는 free 된다.
* 쓰레드 exit 코드가 설정된다.
* 쓰레드 객체가 signaled 된다.
* 프로세스의 유일한 쓰레드일 경우, 프로세스가 종료된다.

그러나 쓰레드가 terminate 되었을 때, 해당 쓰레드의 핸들이 닫혔을 때까지 객체는 free 되지 않는다 (아마 스택만이 free 되지 않는 점과 관련이 있어 보인다).

### 쓰레드 terminate 방법
쓰레드 terminate 방법에는 다음과 같다:

* 쓰레드가 `return`
* 쓰레드가 `ExitThread` 함수 호출
* 프로세스 내의 아무 쓰레드가 `ExitProcess` 함수 호출

* 다른 쓰레드가 해당 쓰레드의 핸들과 함께 `TerminateThread` 함수 호출
* 다른 쓰레드가 해당 쓰레드가 위치한 프로세스의 핸들과 함께 `TerminateProcess` 함수 호출
    : 쓰레드 cleanup이 이루어지지 않으므로 매우 극한 상황에서만 사용하도록!

## 쓰레드 보안 및 접속 권한
마이크로소프트 윈도우 OS는 쓰레드 객체로의 접속 제어를 활성화할 수 있다.
