---
layout: docs
language: ko
category: 컴퓨터 과학
title: MCS-51
icon: icon-8051.png
meta: MCS-51
order: 0x20
---
# **MCS-51: 소개**
> *참조: [http://www.8052mcu.com/](http://www.8052mcu.com/)*

[인텔 MCS-51](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%85%94_8051), 일명 "8051"이라 불리는 반도체 칩은 1980년에 개발된 임베디드 시스템을 위한 8비트 단일칩 마이크로컨트롤러(micr-controller unit; MCU)이다. 기존 8051에서 내장 RAM 메모리가 확장된 "8052", 혹은 내장 ROM 메모리가 없는 "8031" 등의 파생 모델들을 MCS-51 패밀리라고 부른다. 인텔은 2007년부로 MCS-51 패밀리 생산을 중단하였으나, 임베디드에서는 워낙 유명한 동시에 활용도가 높아 Dallas나 Texas Instruments 등 여러 다른 제조사에서 개선된 8051 제품을 현재까지도 생산하고 있다.

## MCS-51 구조
다음은 인텔 MCS-51 마이크로컨트롤러 아키텍처 구조를 개략적으로 보여준다. 자세한 내용은 다음 장에서부터 설명할 예정이므로 아래의 그림은 간단히 훑어보도록 한다.

![그림 1. 인텔 MCS-51 마이크로컨트롤러 아키텍처](/images/docs/8051/8051_architecture.png)

위의 그림 중에서 일부 블록은 여덟 개의 화살표가 뻗어나가는 것을 볼 수 있다. 각 화살표마다 데이터는 비트 단위로 전송 및 수신되며, 여덟 개의 화살표가 모여 하나의 바이트를 이루는 것이다.

### 비트
비트(bit; binary digit)는 디지털 회로에서 가장 작은 정보의 단위를 가리킨다. 비트는 0 혹은 1만을 가지는 이진수이며, 여덟 개의 비트가 모여 하나의 바이트(byte)를 구성한다. 프로그래밍에서 비트와 바이트는 각각 `0b` 및 `0x`를 통해 표현한다.

```csharp
byte A = 0b11100100;    // 십진수: 228
byte B = 0xE4;          // 십진수: 228
```

일반적으로 프로그래밍에서 자료형들은 바이트 단위로 정의되었으나, 임베디드 시스템에서는 비트 단위를 중심으로 데이터 송수신이 이루어지거나 메모리 할당 등이 이루어지므로 반드시 이해하도록 한다.

# **MCS-51: CPU**
중앙 처리 장치(central processing unit; CPU)는 시스템에게 주어진 명령어(instruction)를 입력받아 대응하는 동작을 수행하도록 하는 컴퓨터에서 가장 핵심되는 부품 중 하나이다. 아래는 단일 프로세서를 가지는 CPU의 대략적인 구성 및 신호 흐름도이다. 

![그림 2. 단일 프로세서 중앙 처리 장치](/images/docs/8051/8051_cpu.gif)

여기서 "단일 프로세서"를 강조한 이유는 현재 사용되고 있는 대부분의 CPU는 한 개 이상의 프로세서 혹은 코어(core)를 가지기 때문이다. CPU 분류 중에서 콰드 코어나 헥사 코어 등이 바로 CPU 내에 몇 개의 프로세서가 들어있는지를 알려준다.

MCS-51 MCU는 내부에 8비트 연산 CPU를 가지지만, *그림1. 인텔 MCS-51 마이크로컨트롤러 아키텍처*에서는 CPU가 정확히 어디에 있는지 명시되어 있지 않다. 이는 CPU 구성 장치들이 다른 장치들과 함께 복합적으로 연결되어 있어 한 군데를 지적해 CPU라고 단정지을 수 없기 때문이다.

## 명령어
명령어(instruction)는 비트, 숫자 혹은 문자로 구성된 일련의 패턴이며, 프로그램을 통해 장치를 구동할 수 있도록 하는 소프트웨어와 하드웨어 간의 약속된 데이터이다. 명령어는 일반적으로 어떠한 연산을 처리할 것인지를 나타내는 명령 코드(opcode)와 해당 명령 코드에 의해 연산될 피연산자(operand)로 구성되어 있다. 아래는 32비트 MIPS 명령어 중 하나인 "Add Imediate", 즉 덧셈에 대한 이진 패턴이다.

![그림 3. MIPS "Add Immediate" 명령어](/images/docs/8051/8051_cpu_instruction.svg)

여기서 MIPS는 RISC 기반의 명령어 집합(instruction set) 중 하나이며, MCS-51의 경우에는 독자적인 CISC 기반의 명령어 집합를 가지며 [여기](https://www.win.tue.nl/~aeb/comp/8051/set8051.html)에서 확인할 수 있다. 그리고 명령어 집합이 바로 시스템의 아키텍처(architecture)를 나타낸다.

> 가장 대표적인 x86 아키텍처 또한 인텔 8086 마이크로프로세서에서의 명령어 집합을 사용하는 시스템을 가리킨다. [*(명령어 목록)*](https://en.wikipedia.org/wiki/X86_instruction_listings)

8051 아키텍처는 명령어는 반드시 1바이트의 명령 코드를 시작으로 최대 2바이트 크기의 피연산자로 구성되어 있다; 즉, 명령어는 총 1~3바이트 크기를 가진다. 그렇지만 8051 아키텍처는 8비트 마이크로컨트롤러임은 변함이 없으며, 다음 8051 아키텍처의 하드웨어 규격을 통해 확인할 수 있다.

* 8비트 크기 프로세서 및 레지스터
* 8비트 크기 데이터 통신 버스 
* 16비트 크기 메모리 주소

아무리 8비트 마이크로컨트롤러라 하더라도 최소한 16비트 길이의 메모리 주소를 가진다. 8비트 주소를 사용할 시 오로지 256 바이트라는 터무니 없이 적은 용량의 메모리밖에 사용할 수 없는 문제가 발생하기 때문이다. 반면 16비트 메모리를 사용하면 최대 64 kB 용량이 확보된다.

## 제어 장치
제어 장치(control unit)는 CPU 구성요소 중 하나이며, CPU에서 수신받은 명령어를 해독하여 이에 따른 동작을 실행하도록 CPU를 지휘하는 역할을 담당한다. 8051 아키텍처 구조에서 `Timing and Control` 블록이 제어 장치이며, 바로 옆에 있는 `Instruction Register` (명령 레지스터; IR) 메모리에서 제어 장치의 명령어 해독 및 실행이 진행된다.

명령어 해독을 마치고 이에 대응하는 동작을 실행하는 데에는 여러 번의 데이터 이동 및 연산 과정을 거쳐야 한다. 이러한 명령어 오퍼레이션을 구성하는 최소 단위의 데이터 처리 동작을 마이크로 오퍼레이션(micro-operation)이라고 부른다. 제어 장치가 CPU를 지휘한다는 표현도 마이크로 오퍼레이션 실행에 직접적으로 관여하기 때문인데, 바로 `OSC`에서 입력받는 클럭 신호의 한 주기마다 하나의 마이크로 오퍼레이션을 실행한다. 

> `OSC` 블록은 발진기(oscillator)를 의미하며, 일정한 주기(혹은 주파수)를 가지는 클럭 신호(clock signal)를 발생시킨다. 일정한 주파수를 가지고 있기 때문에 클럭 신호는 디지털 회로의 동작 기준이 되는 메트로놈 역할을 한다. 일반적으로 수정 발진기(crystal oscillator)를 사용하며, 인텔 MCS-51 마이크로컨트롤러의 경우 클럭 신호는 11.059 MHz 주파수를 가진다. 

## 레지스터
레지스터(register)는 CPU 및 MCU 내에 존재하는 메모리 장치이며, 대체로 프로세서의 비트 크기만큼의 작은 저장공간 용량을 가진다. 그럼에도 불구하고 RAM이나 ROM과 같은 주기억장치 대신 레지스터를 사용하는 이유는 데이터 접근 속도가 훨씬 더 빠르기 때문이다. 한 클럭 주기 혹은 마이크로 오퍼레이션만에 레지스터 데이터를 불러올 수 있지만, 주기억장치의 경우는 몇 번의 클럭 주기를 거쳐야 한다.

다음은 8051 아키텍처에서 매우 중요한 여섯 가지의 레지스터에 대한 설명이다.

* **누산기** (어셈블리: `AX`)
    : 산술 및 논리 연산의 결과물을 저장하는 8비트 레지스터이다.

    ```armasm
    MOV AX, #1        ; 누산기로 정수 1 이동
    ADD AX, #3        ; 누산기로 정수 3 덧셈
    ; 결과: AX = 4
    ```

* **B 레지스터**
    : 곱셈 및 나눗셈 계산 전용 8비트 레지스터이다.

* **R 레지스터** (어셈블리: `R0`~`R7`)
    : `R0`부터 `R7`까지의 8비트 레지스터 집합(일명, 뱅크 레지스터; bank register)은 보조 메모리 역할을 하는 레지스터이다. 예를 들어, R 레지스터는 누산기 하나만으로 계산이 불가능한 복잡한 산술 계산 도움을 줄 수 있다.

* **데이터 포인터** (약칭. `DPTR`)
    : 8051 마이크로컨트롤러에서 외부 메모리를 접근하는데 사용되는 사용자 접속이 가능한 16비트 레지스터이다. 여기서 외부 메모리란, MCU에 내장되지 않은 주기억장치를 말한다.

* **프로그램 카운터** (약칭. `PC`)
    : CPU의 제어 장치가 처리해야 할 다음 명령어가 주기억장치의 어느 주소에 있는지 알려주는 사용자 접속이 불가한 16비트 레지스터이다. 프로그램 카운터는 항상 `0x0000` 주소부터 시작하여 8비트마다 +1만큼 순차적으로 증가시켜 다음 명령어를 준비한다.

* **스택 포인터** (약칭. `SP`)
    : 마이크로컨트롤러에 내장되어 있는 256바이트 RAM을 스택 메모리로 사용하도록 하는 8비트 레지스터이다. 스택 포인터는 기본적으로 `0x07`로 초기화되어 있으며, 이는 뱅크 레지스터를 고려한 내장 RAM의 메모리 주소이다. 스택 메모리에 데이터가 푸쉬되면 SP의 값이 +1 증가하며 `0x08` 주소를 가리키며, 데이터가 팝이 되면 SP의 값은 -1 감소하여 다시 `0x07`을 가리키게 되는 전형적인 선형적 FILO(first-in last out)를 구현한다.

* **프로그램 상태 워드** (약칭. `PSW`)
    : 아래와 같은 중요한 플래그 비트 상태를 저장하는 8비트 상태 레지스터이다. 
    
    | 비트  |  기호  |         플래그         | 설명                                                  |
    | :--: | :------: | :------------------: | ------------------------------------------------------------ |
    |  7   |    CY    |      캐리 플래그      | 부호 없는 숫자의 연산 결과가 비트 범위를 넘어섰을 때 (일명 캐리; carry) 참이 된다. |
    |  6   |    AC    | 보조 캐리 플래그 | 인진화 십진법의 연산 결과가 비트 범위를 넘어섰을 때 (일명 캐리; carry) 참이 된다. |
    |  5   |    F0    |        플래그 0        | -                                                            |
    | 4, 3 | RS1, RS0 |   레지스터 선택    | 0에서부터 3 사이의 R 레지스터 뱅크를 선택한다.                           |
    |  2   |    OV    |    오버플로우 플래그    | 부호 있는 숫자의 연산 결과가 비트 범위를 넘어섰을 때 (일명 오버플로우; overflow) 참이 된다.            |
    |  1   |    UD    |     사용자 정의     | -                                                            |
    |  0   |    P     |        패리티 플래그       | 연산 결과물의 비트 값 1의 개수가 짝수이면 참이 된다.       |

이 외에도 프로그램 카운터에서 알려준 명령어 주소를 주기억장치로부터 호출하는 16비트 메모리 주소 레지스터(Memory address register; `MAR`), 그리고 해당 주기억장치 주소의 명령어를 받아오는 8비트 메모리 버퍼 레지스터(Memory buffer register; `MBR`)이 존재한다.

## 산술 논리 장치
산술 논리 장치(arithmetic logic unit; `ALU`)는 CPU 및 GPU의 핵심으로 십진수 정수 산술 계산과 이진수 비트 논리 연산을 처리한다.

![그림 4. 산술 논리 장치의 기호](/images/docs/8051/8051_cpu_alu.gif)

| 신호         | 설명                                                  |
| --------------- | ------------------------------------------------------------ |
| 입력 데이터: `A`, `B`    | 연산 처리되어야 할 정수 (일명 피연산자)                |
| 출력 데이터: `Y`   | 연산 처리 이후의 정수 (일명 결과)                 |
| 명령 코드: `Opcode`          | ALU의 연산 선택; 4비트의 길이로 총 16가지의 연산을 수행할 수 있으나, 이는 명령어의 명령 코드와 별개이다. |
| 상태 입력 | *캐리*와 같은 산술 연산에 필요한 부가적 정보를 수신받는다.  |
| 상태 출력 | *캐리*, *패리티*, *오버플로우* 등의 산술 연산 결과물의 부가적 정보를 제공한다. |

# **MCS-51: 메모리**
메모리는 데이터와 프로그램, 그리고 명령어를 저장하는 하드웨어 장치이다. 메모리는 두 가지의 분류로 나뉘어진다:

* **주기억장치**
    : 데이터를 임시로 저장하는 휘발성 메모리이며, 전력 공급이 중단되면 저장된 모든 데이터를 손실한다. 내부 데이터 통신 버스를 사용하기 때문에 프로세서가 직접 접근할 수 있는 메모리 장치이다. 대표적으로 랜덤 엑세스 메모리(random-access memory; RAM)이 있다.

* **보조기억장치**
    : 데이터를 장기간 저장하는 비휘발성 메모리이며, 전력 공급이 중단되어도 모든 데이터가 유지된다. 외부 직력 ATA(일명 SATA) 케이블을 통해 데이터 전송이 되므로 프로세서가 직접 접근할 수 없는 메모리 장치이다. 통상적으로 컴퓨터 부품에서의 HDD(하드 디스크)나 SSD가 바로 보조기억장치를 가리킨다.

주기억장치가 프로세서로부터 직접 접근이 가능한 점에서 보조기억장치보다 훨씬 빠른 점도 있지만, 휘발성이 가지는 특성 또한 메모리 접근 속도에 영향을 미친다. RAM 용량이 크다는 것은 더 많은 데이터와 명령어를 불러올 수 있으므로 CPU 성능을 높이는데 기여한다. 

MCS-51의 경우에는 마이크로컨트롤러 안에 세 가지의 메모리가 존재한다: 내장, 외장, 그리고 프로그램 메모리가 있다.

## 내장 메모리
MCS-51 마이크로컨트롤러에는 256바이트의 RAM이 내장되어 있다. 하지만 내장 메모리 중에서도 일부 주소에 따라 사용되는 목적이 상이하며, 하단 128바이트(`0x00`~`0x7F`)는 IRAM이라고 칭하고 상단 128바이트(`0x80`~`0xFF`)는 SFR이라고 부른다.

> 여기서부터 비트와 바이트 단위가 복합적으로 사용되므로 주의하도록 한다.

![그림 5. MCS-51의 내장 메모리](/images/docs/8051/8051_memory_internal.gif)

IRAM은 128바이트 전체가 RAM으로 사용되지 않으며, 안에는 (1) 레지스터 뱅크("R" 레지스터 집합)와 (2) 비트 주소 메모리가 포함되어 있다. 기본적으로 `R0`~`R7`이 하나의 레지스터 뱅크를 구성하여 총 네 개의 뱅크가 `0x00`~`0x1F` 주소를 차지하고 있다. 원한다면 `0x00`~`0x07` 범위의 레지스터 뱅크 0 하나만을 사용할 수 있다. 비트 주소 메모리는 총 16바이트, 즉 128비트의 공간을 차지하여 각 비트가 IRAM의 128바이트 주소를 나타내는데 사용되나 선택사항이다. 만일 IRAM 내에 네 개의 레지스터 뱅크와 비트 주소 메모리가 포함되어 있다면 실질적으로 RAM으로 활용할 수 있는 공간은 `0x30`~`0x7F`이다.

SFR(Special Function Register; 특수 목적 레지스터)은 8051 MCU의 특정 기능들을 제어하기 위해 사용된다. 대표적인 예로 직렬 포트 제어, 전송 속도 설정, 타이머 제어 및 접근 등이 있다. SFR 안에는 다른 레지스터들을 포함하고 있다: 스택 포인터(`0x81`), 데이터 포인터(`0x82`~`0x83`), PSW(`0xD0`), 누산기(`0xE0`), 그리고 B 레지스터(`0xF0`)가 이에 해당한다. 비록 SFR은 내장 메모리의 반을 차지하지만 오직 21바이트만 사용하고 있다. 나머지 주소는 IRAM과 같이 RAM처럼 사용된다.

## 외장 메모리
MCS-51 마이크로컨트롤러는 외장 메모리(XRAM)를 연결하여 사용할 수도 있다. 비록 내장 메모리보다 속도는 느리지만 16비트 메모리를 통해 최대 64 kB 용량까지 확보할 수 있다.

## 프로그램 메모리
프로그램 메모리(PMEM), 일명 코드 메모리는 16비트의 보조기억장치로 임베디드 시스템에서 프로그램 코드를 저장한다. 읽기 전용의 EPROM/EEPROM이나 플래시 메모리가 프로그램 메모리 역할을 한다. 프로그램 메모리는 칩에 내장되어 있거나 외부에 존재, 혹은 둘 다 해당할 수 도 있으나 일반적으로 프로그램 메모리는 마이크로컨트롤러 외부에 위치한다.

# **MCS-51: SFR**
SFR에는 마이크로컨트롤러에 있는 중요한 기능 및 설정들이 포함되어 있다. 비록 *MCS-51: 메모리* 장에서 간략하게 설명하였으나, 이번 장에서는 더 구체적으로 SFR에 대하여 소개한다. 아래 그림은 SFR에 할당된 기능 및 설정들이 어디에 위치하는지 보여준다.

![그림 6. MCS-51의 특수 목적 레지스터](/images/docs/8051/8051_sfr_address.gif)

|                            색상                             | 설명                                                  |
| :----------------------------------------------------------: | ------------------------------------------------------------ |
| **<span style="background-color:skyblue; color: black;">파란색</span>** | 양방향 입출력 포트.          |
| **<span style="background-color: yellow; color:black">노란색</span>** | 제어 SFR: 마이크로컨트롤러가 어떻게 동작하는지 설정. |
| **<span style="background-color:lightgreen; color:black;">초록색</span>** | 보조 SFR: 마이크로컨트롤러 설정에 기여하지 않지만 동작에 있어서 필요. |

## 양방향성 입출력 포트
MCS-51은 네 개의 양방향 입출력 포트(P0: `0x80`, P1: `0x90`, P2: `0xA0`, P3: `0xB0`)를 가지며, 이는 8051 아키텍처 구조에서 각각 `Port 0`~`Port 3 Driver`에 해당한다. 레지스터의 각 비트는 마이크로컨트롤러의 핀과 일대일 대응한다. 예를 들어 `P0.0`~`P0.7` 핀은 `P0`의 0~7번째 비트를 의미하며, 0과 1은 LOW 및 HIGH 신호를 나타낸다. 그러나 외장 메모리를 연결할 시 `P0`와 `P2`는 사용하지 않도록 한다. 이는 `P0`와 `P2`가 데이터 포인터가 가리킨 외장 메모리 주소를 전송하는데 활용되기 때문이다.

## 상위/하위 데이터 포인터
8비트의 상위 데이터 포인터(`DPH`)과 8비트의 하위 데이터 포인터(`DPL`)를 합쳐 16비트 주소를 표현할 수 있는 데이터 포인터는 접근할 외장 메모리 주소를 가리킨다.

## 타이머
MSC-51 마이크로컨트롤러는 개별적으로 설정할 수 있는 두 개의 타이머를 가진다. MCU에서 타이머는 세 가지의 기능을 가진다: (1) 시간을 측정과 (2) 발생한 이벤트의 셈, 그리고 (3) 직렬 통신을 위한 보 레이트(baud rate)을 발생시킬 수 있다.

|     SFR     | 이름             | 설명                                                  |
| :---------: | :--------------- | ------------------------------------------------------------ |
|   `TCON`    | 타이머 제어 | 타이머 오버플로우 플래그(`TF`) 및 타이머 ON/OFF 스위치 역할(`TR`)을 한다. |
|   `TMOD`    | 타이머 모드 | 타이머 모드를 선택한다: 13비트, 16비트, 8비트 자동 재할당, 그리고 스플릿 타이머가 있다. |
| `TL0`/`TH0` | 타이머 0 카운터 | 하위 및 상위 바이트 `TL0`와 `TH0`를 합쳐 총 16비트의 크기를 가지는 타이머 0 카운터이다. |
| `TL1`/`TH1` | 타이머 1 카운터 | 히위 및 상위 바이트 `TL1`와 `TH1`를 합쳐 총 16비트의 크기를 가지는 타이머 1 카운터이다. |

> `TCON`의 총 여덟 비트 중에서 오로지 `TCON.4`~`TCON.7` 네 비트만 타이머에 사용된다. 나머지 `TCON.0`~`TCON.3` 네 비트는 마이크로컨트롤러의 인터럽트(interrupt)에 사용되며, 이에 대한 내용은 차후에 소개한다.

명령 주기(instruction cycle; machine cycle)란, 하나의 명령을 실행하기 위해 필요한 최소한의 클럭 펄스 주기이다. *MCS-51: CPU § 제어 장치* 부문에서 설명하였 듯이 하나의 클럭 신호를 입력받을 때마다 마이크로 오퍼레이션이 실행되고, 여러 마이크로 오퍼레이션이 모여 하나의 명령어에 의한 오퍼레이션을 구성한다. 인텔 MCS-51의 명령 주기는 최소 12 클럭 펄스를 가지지만 일반적으로 다른 명령어들은 이보다 더 많은 주기를 필요로 하다. 그러나 타이머 카운터의 경우에는 단 한 번의 명령 주기만에 실행되는 매우 간단한 동작이므로 12 클럭 펄스 값을 그대로 사용한다.

### 타이머 모드
타이머에는 총 네 개의 모드가 존재하며, 아래는 각 모드에 대한 설명이다.

* **모드 0: 13비트 타이머**
    : `TL*`가 다섯 비트로 0~31까지 명령 주기를 카운트를 하며, 31 이후에는 0으로 리셋되고 `TH*`에 +1 증가시켜 총 13비트를 사용한다. 이는 MCS-51의 이전 프로세서인 인텔 MCS-48과의 호환성을 위한 것이며, 현재 임베디드 시스템 개발에서는 거의 활용되지 않는 타이머 모드이다.

* **모드 1: 16비트 타이머**
    : `TL*`가 여덟 비트로 0~255까지 명령 주기를 카운트를 하며, 255 이후에는 0으로 리셋되고 `TH*`에 +1 증가시켜 총 16비트를 사용한다.

* **모드 2: 8비트 자동 재할당 타이머**
    : `TL*`가 여덟 비트로 0~255까지 명령 주기를 카운트를 하며, 255 이후에는 0이 아닌 `TH*`에서 저장된 값으로 리셋되어 카운트를 재개한다. `TH*`의 역할이 `TLx`에서 리셋될 시 오버플로우를 카운트하는 게 아니라 카운트를 다시 시작할 값을 마련해 주는 것이기 때문에 "자동 재할당(auto-reload)"이라는 명칭이 붙었다.

* **모드 3: 스플릿 타이머**
    : 하나의 16비트 타이머를 두 개의 8비트 타이머로 나눈다. 만일 타이머 0이 스플릿 타이머 모드로 설정될 경우, `TL0`과 `TH0`가 각각 0~255까지 카운트를 하는 타이머 0와 타이머 1이 된다. 한편, 실제 타이머 1 카운터 `TL1`과 `TH1`은 묵묵히 명령 주기마다 카운팅을 하지만 이를 제어하는 `TCON`은 절대 타이머 1을 OFF시키면 안된다. 현재 `TCON`에서 타이머 1 제어 비트는 바로 `TH0`으로 연동되어 있기 때문이다. 또한 두 개의 타이머가 동시에 스플릿 타이머 모드로 설정될 수 없다.

### 시간 측정
위에서 언급한 클럭 주파수와 명령 주기를 통해 다음과 같은 초당 실행 명령어 수치를 계산할 수 있다.

$$
\frac{\text{클럭 주파수}}{\text{명령 주기}}
= \frac{11,059,000 \ \text{주기}/\text{초}} {12 \ \text{주기}/\text{명령어}}
= 921,583 \ \text{명령어}/\text{초}
$$

즉, 타이머가 921,583 명령 주기를 카운트하였으면 이는 1초가 지났음을 알 수 있다. 그러나 921,583을 카운트하기 위해서는 최소한 20비트가 필요하므로 16비트가 한계인 타이머 카운터로는 절대 표현할 수 없는 수치이다. 하지만 0.05초에 대하여 계산하면

$$
0.05 \ \text{초} \times 921,583 \ \text{명령어}/\text{초} = 46,079.15 \ \text{명령어}
$$

46,079 번의 명령 주기를 카운트, 혹은 타이머가 `0xB3FF` 값을 저장하면 0.049999873 초가 지났음을 의미이다. 그러나 0.001%도 안되는 오차를 가지며, 이는 2개월마다 단 1초 차이만 생기므로 0.05로 반올림하여도 타이머 역할로써는 큰 문제를 가지지 않는다.

### 이벤트 카운터
이벤트(event)란, 어떠한 상호작용으로 발생하는 사건을 가리키며 마이크로 오퍼레이션이나 명령어를 지칭하는 게 아니다. 컴퓨터 과학에서도 동일한 의미의 이벤트가 존재하는데, 바로 마우스 및 키보드 버튼 클릭 등이 있다. 마찬가지로 임베디드 시스템에 대한 예시로는 외부 센서의 물체 감지가 있다. 그리고 이벤트 카운터 역할을 바로 타이머가 수행할 수 있다.

SFR의 `TMOD.2`와 `TMOD.6` 비트는 `C/T` 이름을 가지는 것을 확인할 수 있다. 해당 비트가 0이면 명령 주기를 카운트하는 타이머로 동작하지만, 1의 값을 가지면 이벤트 카운터 역할을 한다. 이벤트 카운터는 HIGH 펄스를 감지할 때마다 +1 증가하는데, 어느 신호의 펄스를 감지할 것인지는 소프트웨어 측에서 지정해야 한다.

### 보 레이트
> 해당 부분은 [*MCS-51: SFR § 직렬 포트*](#직렬-포트)와 직접적인 연관을 가지므로 해당 내용을 먼저 확인하는 것을 권장한다.

보 레이트(baud rate), 혹은 심볼율(symbol rate)란 데이터 통신에서 초당 심볼 변화(혹은 심볼 전송 개수)를 의미하며 보(baud; Bd)라는 단위를 사용한다. 여기서 심볼(symbol)은 디지털 통신 분야에서 인코딩된 신호가 가질 수 있는 값을 말한다. 즉, 8비트 데이터를 주고받는 MCS-51 마이크로프로세서는 0과 1의 이진수로 인코딩된 여덟 비트 길이의 바이트가 하나의 심볼이 된다. 예를 들어, 9600 Bd는 초당 9600 심볼 속도로 데이터를 전송한다.

직렬 포트의 보 레이트는 타이머 1을 8비트 자동 재호출 모드로 설정한 다음 오버플로우가 발생하도록 `TH1` 값을 아래의 계산식을 통해 입력하면 된다.

$$
\text{TH1}=256-\left( \frac{ \text{클럭 주파수} / 384}{\text{보 레이트}} \right)
$$

여기서 "클럭 주파수"는 수정 발진기에서 발생하는 일정한 주파수(11.059 MHz)이며, "보 레이트"는 사용자가 원하는 직렬 포트의 보 레이트를 말한다. 이 두 개의 변수가 결정되면 `TH1`에 어떠한 값을 설정되어야 하는지 구할 수 있다.

추가적으로 SFR에 `PCON`이란 전력 설정에서 일곱 번째 비트는 보 레이트를 배속으로 올릴 수 있도록 한다. 만일 `PCON.7`에 의해 보 레이트가 배속으로 되면 계산식은 아래와 같이 변환다.

$$
\mathrm{TH1_{\text{배속}}}=256-\left( \frac{ \text{클럭 주파수} / 192}{\text{보 레이트}} \right)
$$

## 직렬 포트
MCS-51은 하나의 UART(universal asynchronous receiver/transmitter; 범용 비동기화 송수신기) 직렬 포트를 가진다. SFR에서 UART는 `SCON`에서 직렬 포트를 제어(control)하며, `SBUF`를 통해 데이터를 수신받거나 전송하는 버퍼(buffer)이다. 다음은 `SCON`의 각 비트가 가지는 역할을 설명한다.

| 비트  |   이름   | 설명                                                  |
| :--: | :------: | ------------------------------------------------------------ |
| 7, 6 | `SM0`, `SM1` | 직렬 포트 모드: 8비트 UART/시프트 레지스터 그리고 9비트 UART가 있다 (고정/가변 보 레이트 선택). |
|  5   |   `SM2`    | 멀티프로세서 통신 활성화: 수신된 8번째 비트가 1일 때만 `RI`가 성공적으로 수신받았다고 인정하도록 한다. |
|  4   |   `REN`    | UART 데이터 수신 활성화.  |
|  3   |   `TB8`    | 8번째 비트 전송 (9비트 UART 모드 전용). |
|  2   |   `RB8`    | 8번째 비트 수신 (9비트 UART 모드 전용). |
|  1   |    `TI`    | 송신 인터럽트: UART를 통해 성공적으로 데이터를 송신하였으면 참이 된다. |
|  0   |    `RI`    | 수신 인터럽트: UART를 통해 성공적으로 데이터를 수신받았으면 참이 된다. |

그러나 8051 MCU 아키텍처 구조를 보면 UART 직렬 포트가 따로 명시되어 있지 않다; UART 수신과 송신은 `P3.0`(양방향 입출력 3번 포트의 0번 핀)과 `P3.1`(양방향 입출력 3번 포트의 1번 핀)을 통해 이루어진다. 입출력 포트의 여덟 개의 핀을 전부 사용하지 않는 이유는 "필요가 없어서"이다. UART는 직렬 통신이기 때문에 여덟 개의 비트는 한 개의 심볼로 인코딩되어 핀 하나로만 통신된다.

## 인터럽트
인터럽트(interrupt)는 최상위 작업순위를 가지는 이벤트이다. 가장 우선적으로 처리해야 하기 때문에 현재 진행 중인 일반 프로그램 실행을 잠시 중단시키고 인터럽트를 우선적으로 처리한다. 임베디드 시스템에서 인터럽트의 존재는 매우 중요한 이유는 바로 멀티태스킹에 필요한 쓰레드(thread) 작업이 불가능하기 때문이다.

MCS-51에는 다섯 개의 인터럽트가 존재하며, 이에 대한 설명은 다음과 같다.

| 인터럽트  |   플래그   | 벡터 주소  | 처리순서    | 설명  |
| :--- | :------: | ---- |:---:| ------------------- |
| 외부 0 | `IE0` | `0x0003` | 1 | 외부에서 유입된 인터럽트 신호 0 |
| 타이머 0 |   `TF0` | `0x000B` | 2 | 타이머 0 오버플로우 |
| 외부 1 |   `IE1`    | `0x0013` | 3 | 외부에서 유입된 인터럽트 신호 1 |
| 타이머 1 |   `TF1`    | `0x001B` | 4 | 타이머 1 오버플로우 |
| 직렬 |   `RI/TI`    | `0x0023` | 5 | UART 데이터 송수신 |

인터럽트의 플래그가 참이 되면 주요 프로그램 실행이 일시적으로 중지되고 해당하는 인터럽트 처리가 실행된다. 인터럽트 처리자 코드는 프로그램 메모리의 고정된 주소에 위치하는데 이를 벡터 주소(vector address)라고 부른다.

### 인터럽트 우선순위
인터럽트 내에서도 고우선순위 및 저우선순위를 SFR의 `IP`에서 지정할 수 있다. 비트 값이 1이면 해당 인터럽트는 고우선순위로 처리된다.

| 비트      | 이름    | 설명               |
|:-------:|:-----:|------------------|
| 7, 6, 5 | -     | 미지정              |
| 4       | `PS`  | 직렬 인터럽트 우선순위     |
| 3       | `PT1` | 타이머 1 인터럽트 우선순위 |
| 2       | `PX1` | 외부 1 인터럽트 우선순위   |
| 1       | `PT0` | 타이머 0 인터럽트 우선순위  |
| 0       | `PX0` | 외부 0 인터럽트 우선순위   |

다음은 인터럽트의 우선순위에 따른 처리 방식에 대하여 설명한다:

* 저우선순위 인터럽트가 고우선순위 인터럽트를 중단시킬 수 없다.
* 동일한 우선순위의 인터럽트를 중단시킬 수 없다.
* 저우선순위 인터럽트는 다른 실행 중인 인터럽트가 없을 때만 처리된다.
* 두 인터럽트가 동시에 발생하였으면 고우선순위가 먼저 처리된다. 만일 우선순위가 동일하면 처리순서에 따라 결정된다.

### 인터럽트 처리 절차
인터럽트가 발생되면 마이크로컨트롤러에 의해 다음 동작들이 자동적으로 진행된다:

1. 현재 프로그램 카운터가 스택에 저장된다.
2. 동일 우선순의 혹은 낮은 우선순위의 인터럽트를 차단한다.
3. 타이머 및 외부 인터럽트의 경우, 1로 설정된 해당 플래그를 0으로 리셋한다.
4. 해당하는 인터럽트 처리자의 벡터 주소로 이동 및 코드를 실행한다.
