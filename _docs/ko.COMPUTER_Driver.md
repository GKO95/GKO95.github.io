---
layout: docs
language: ko
category: 
title: 드라이버
meta: Driver
order: null
---
# 드라이버: 소개
[디바이스 드라이버](https://ko.wikipedia.org/wiki/장치_드라이버)(device driver; 일명 장치 드라이버)는 특정 하드웨어와 상호작용하기 위해 짜여진 프로그래밍 인터페이스이다. 비록 운영체제나 어플리케이션이 구체적으로 하드웨어가 어떻게 동작하는지 몰라도 해당 하드웨어 특성을 파악하고 있는 드라이버를 통해 간편하게 사용할 수 있다. 하드웨어를 사용해야 할 때마다 운영체제의 [커널](../ko.EMBEDDED_Kernel)(kernel) 프로그램이 디바이스 드라이버를 시스템 부팅 이후에도 언제든지 불러올 수 있는데, 이러한 모듈성(modularity) 덕분에 드라이버 개발은 비교적 쉬워진다.

> 어플리케이션에서 하드웨어 장치로부터 데이터를 전달하거나 요청하기 위해 해당 동작을 수행하는 운영체제 함수를 호출한다. 그리고 운영체제는 해당 동작을 수행하는 디바이스 드라이버 함수를 호출한다. 만일 데이터 요청 시, 장치로부터 확보한 데이터는 다시 역순으로 운영체제를 거쳐 어플리케이션으로 도달한다.

## 설계 원칙
프로그래밍 설계 원칙에 앞서 매커니즘(mechanism)과 정책(policy)에 대한 소개가 필요하다:

| 프로그램 설계 | 의미 | 해석                     |
|:-------:|---|------------------------|
| 매커니즘    | 시스템의 동작 허가 및 리소스 할당을 제어하는 부분 | "어떠한 기능성이 제공되어야 하는가?"  |
| 정책      | 시스템의 동작 허가 및 리소스 할당을 선택하는 부분 |"기능성들이 어떻게 활용될 수 있는가?" |

> 그래픽 드라이버(graphic driver)는 [그래픽 카드](https://ko.wikipedia.org/wiki/그래픽_카드)의 [병렬 컴퓨팅](https://ko.wikipedia.org/wiki/병렬_컴퓨팅) 매커니즘을 통해 고화질 해상도를 화면에 출력하는 정책을 선보인다. 그러나 동일한 매커니즘을 통해 3D 렌더링 및 기계학습 또는 가상화폐 채굴 등의 다양한 정책에도 활용된다.

컴퓨터 과학에서는 [매커니즘과 정책을 분리](https://en.wikipedia.org/wiki/Separation_of_mechanism_and_policy)하는 설계 원칙이 있으며, 이는 매커니즘이 정책을 구속하거나 과하게 제한해서는 안된다는 점을 서술한다. 다시 말해, 기능성을 제공하는 코드(매커니즘)와 제공된 기능성을 활용하는 코드(정책)를 별개로 처리할 수 있으면 소프트웨어 패키지 개발은 훨씬 수월해지고 필요에 따른 접목이 가능해진다.

드라이버 설계에서도 매커니즘과 정책의 분리 원칙은 반영되어야 한다. 하드웨어가 어떻게 활용되는지는 사용자마다 가지각색이므로 특정 정책을 염두하기보다 다양한 용도에서 지원할 수 있도록 매커니즘을 최대한으로 제공하는 것에 집중한다. 이러한 무(無)정책 드라이버는 다음과 같은 일반적인 특징들을 갖는다:

* 동기 및 비동기식 동작 지원
* 동시에 드라이버 다중 접근 가능
* 하드웨어의 기능성을 최대한으로 이용 가능
* 기능성 제공을 위한 별도의 소프트웨어 부재

이러한 특징들을 갖춘 드라이버는 사용자들에게 유용하게 사용될 뿐만 아니라 드라이버 개발과 관리가 매우 간편해진다.

## 운영체제
디바이스 드라이버는 운영체제 내에 있는 커널에 의해 동작한다. 운영체제 종류에 따라 디바이스 드라이버도 달라지며, 본 문서는 대표적인 운영체제 중에서 리눅스(Linux)와 윈도우(Windows)를 위주로 살펴본다. 본문에서 사용되는 운영체제 종류는 다음과 같다.

* 리눅스 - **Debian 11 "Bullseye"** *(커널: 리눅스 5.10)*

* 윈도우 - **Windows 11** *(커널: Windows NT 10.0)*

### 리눅스
> *참조: [Linux Device Drivers, Third Edition [LWN.net]](https://lwn.net/Kernel/LDD3/)*

[리눅스](https://ko.wikipedia.org/wiki/리눅스_커널)(Linux)는 운영체제 커널이며, 이를 사용하는 리눅스 배포판 운영체제가 대표적으로 [우분투](https://ko.wikipedia.org/wiki/우분투_(운영_체제))(Ubuntu)/[데비안](https://ko.wikipedia.org/wiki/데비안)(Debian), [페도라](https://ko.wikipedia.org/wiki/페도라_리눅스)(Fedora), [안드로이드](https://ko.wikipedia.org/wiki/안드로이드_(운영_체제))(Android) 등이 있다. 배포판이 아닌 "순수" 리눅스를 설치하여 사용해보겠다는 생각을 가질 수 있겠으나, 커널 자체는 하드웨어와 소프트웨어의 징검다리 역할을 할 뿐이며 사용자 측에서 사용할 수 있는 소프트웨어가 없으므로 부팅 이후에 아무것도 실행되지 않는다

리눅스는 장치의 종류, 일명 클래스(class)를 크게 세 가지로 분류하며 자세한 내용은 차후에 설명할 예정이다.

| 클래스     | 설명                     | 예시                                           |
|:-------:|------------------------|----------------------------------------------|
| 문자 장치   | 일련의 바이트로 장치 접근 및 처리    | 직렬 포트 (키보드, 마우스, 그래픽카드 등)                    |
| 블록 장치   | 블록이란 바이트 묶음의 장치 입출력 처리 | 대용량 저장장치 (하드디스크, CD/DVD, 플래시 메모리 등)          |
| 네트워크 장치 | 패킷 단위의 데이터를 송수신        | 네트워크 인터페이스 제어장치 (LAN, 무선인터넷, Bluetooth 카드 등) |

### 윈도우
> *참조: [Windows 하드웨어 개발자 설명서](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/)*

[윈도우](https://ko.wikipedia.org/wiki/마이크로소프트_윈도우)(Windows) 운영체제는 [윈도우 NT](https://ko.wikipedia.org/wiki/윈도우_NT) 계열의 제품군으로 [사용자 모드](https://ko.wikipedia.org/wiki/사용자_공간)(user mode)와 [커널 모드](https://ko.wikipedia.org/wiki/보호_링#수퍼바이저_모드)(kernel mode) 계층으로 구성된 [아키텍처](https://ko.wikipedia.org/wiki/윈도우_NT_아키텍처)를 사용한다. 프로그램이 실행되는 코드에 따라 사용자 혹은 커널 모드로 전환되어 프로세스가 동작하는데, 여기서 커널 모드는 커널 자체를 가리키는 게 절대 아니다 (윈도우 NT의 커널은 Executive와 HAL 사이에 위치한다).

윈도우에서 드라이버는 기존보다 확장된 개념을 지닌다: 하드웨어와 운영체제의 상호작용 외에도 이를 관측하는 프로그램도 드라이버로 정의한다.

| 종류      | 역할                     |
|:-------:|------------------------|
| 기능 드라이버 | 장치와 직접 (혹은 간접적으로) 상호작용 |
| 필터 드라이버 | 기능 드라이버에 도달하기 전에 보조 처리 |
| 소프트웨어 드라이버 | 커널 모드에 위치한 보호된 데이터 접근 |

# (윈도우) 드라이버:



윈도우 운영체제를 구동하는 프로세서는 두 가지의 모드가 있다.
프로세서는 어떠한 코드가 실행되냐에 따라 사용자 모드와 커널 모드로 전환된다. 어플리케이션은 사용자 모드, 대부분의 디바이스 드라이버를 포함한 운영체제의 핵심은 커널 모드로 동작한다.

사용자 모드 어플리케이션을 실행하면 윈도우 시스템이 어플리케이션을 위한 프로세스(프로세서가 아님)를 생성한다. 프로세스는 어플리케이션에 전용 제한적 가상 주소 공간(virtual address space) 및 개인 핸들 테이블을 제공한다. 어플리케이션의 가상 주소 공간은 해당 어플리케이션 전용이므로 다른 어플리케이션이 접근할 수 없다. 사용자 모드 어플리케이션들은 각자 고립적으로 수행되어 하나의 어플리케이션에 충돌이 발생하여도 해당 어플리케이션에만 영향을 주고 나머지 어플리케이션 및 운영체제에는 영향을 주지 않는다. 운영체제를 위해 확보된 가상 주소 공간 접근하지 못하도록 하여 운영체제가 갖는 민감한 데이터 변동 및 손상을 방지한다.

커널 모드에서 실행되는 코드들은 모두 단일 가상 주소 공간을 공유한다. 즉, 커널 모드에서 동작하는 드라이버는 타 드라이버 및 운영체제로부터 고립된 프로세스가 아니어서 마냥 잘못된 데이터를 write 할 경우 시스템 전체에 문제를 야기하게 되며, 드라이버 충돌은 시스템 충돌로 이어진다.


윈도우에서는 디바이스 드라이버의 의미가 확장된다: 하드웨어와 운영체제의 상호작용에 기여하는 것 외에도 관측하는 것도 포함된다.

[드라이버 스택](https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/driver-stacks)

* 기능 드라이버(function driver): 장치와 직접적으로 통신하는 드라이버 (PCI 장치; PCI 포트 및 메모리 리소스에 맵핑된 주소를 가져와 직접 통신)
    하지만 대부분 장치는 PCI 버스에 직접 연결되지 않고 PCI 버스에 연결된 [호스트 버스 어댑터](https://ko.wikipedia.org/wiki/호스트_어댑터)(host bus adapter; HBA)를 통해 연결된다.

    > 호스트 어댑터는 호스트 시스템(즉, 컴퓨터)을 다른 네트워크, 저장장치, USB 등과 연결한다.
    >
    > * 네트워크 호스트 어댑터: 호스트를 네트워크에 연결하는 HBA로 일반적으로 네트워크 인터페이스 컨트롤러(NIC)를 가리킨다 - 이더넷, 와이파이, 블루투스.
    > 
    > * 저장장치 호스트 어댑터: HDD 및 SSD 연결에 사용되는 SATA도 HBA가 있다. 단, 마더보드에 있는 SATA 포트는 PCI가 아니다.
    
    가장 흔히 쓰이는 USB 호스트 어댑터 (USB 호스트 컨트롤러)는 기본적으로 마더보드에 장착되어 있으나, 확장을 하기 위해 PCI를 통해서도 

* 필터 드라이버(filter driver): 기능 드라이버에 도달하기 전에 보조적 처리를 수행하는 드라이버
    그 중에서 일부 필터 드라이버는 디바이스 상호작용에 기여하기 않고 관측 및 기록에 기여한다. 이들은 스택에 있는 다른 드라이버들이 입출력을 제대로 처리하는지 검증하는 등의 용도로 활용되기도 한다.



소프트웨어 드라이버

일부 드라이버는 하드웨어 장치와 무관한 것도 있다. 일반적으로 드라이버는 운영체제의 커널 모드를 통해 장치에 접근하는 것이 목적이지만, 소프트웨어 드라이버는 운영체제의 사용자 모드 및 커널 모드에 저장된 보호된 데이터들을 접근하는 목적으로 사용된다.



버스 드라이버