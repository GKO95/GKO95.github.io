---
layout: docs
language: ko
category: 운영체제
title: 메모리
meta: Memory
order: 0x41
---
# 메모리 관리
32비트 윈도우 OS에서의 각 프로세스는 최대 4GB 메모리까지 도달할 수 있는 가상주소공간을 갖는다.

64비트 윈도우 OS에서의 각 프로세스는 최대 8TB 메모리까지 도달할 수 있는 가상주소공간을 갖는다.

모든 프로세스의 쓰레드는 이 가상주소공간에 접근할 수 있으나 다른 프로세스의 가상주소공간에는 접근할 수 없다. 이를 통해 한 프로세스가 다른 프로세스에 영향을 주는 것을 방지한다.

## 가장주소공간
프로세스를 위한 가상주소공간은 프로세스가 사용할 수 있는 가상 메모리 주소의 집합이다. 각 프로세스의 주소공간은 private으로 공유하지 않는 이상 다른 프로세스가 접속할 수 없다.

가상주소는 메모리에 소재하는 객체의 실제 물리적 위치를 반영하지 않는다. 시스템이 각 프로세스에 대한 페이지 테이블을 관리한다.

> 페이지 테이블은 가상주소를 대응하는 물리적 주소로 변환시켜주는 내부 데이터 구조이다.

매번 쓰레드가 주소를 참조할 때, 시스템은 가상주소를 물리적 주소로 변환한다.

32비트 윈도우에서의 가상주소공간은 4GB 크기로 두 파티션으로 나뉘어 사용된다: 하나는 프로세스를 위한 것이며, 다른 하나는 시스템을 위한 reserved된 공간이다.

### 가상주소공간과 물리적 저장장치
운영체제 버전에 따라 마이크로소프트 윈도우가 지원하는 최대 물리 메모리(e.g. RAM)은 2GB ~ 24TB이다. 각 프로세스의 가상주소공간은 컴퓨터에서 사용할 수 있는 총 물리 메모리 용량보다 작거나 클 수 있다. 프로세스의 가상주소공간 일부 중 물리 메모리에 위치한 것은 working set이라고 칭한다. 프로세스의 쓰레드가 현재 물리 메모리에서 제공할 수 있는 용량 이상을 요구하면 시스템은 일부 메모리 내용을 저장장치로 page한다. 즉, 프로세스가 사용할 수 있는 총 가상주소공간 용량은 물리 메모리 + 저장장치의 빈 공간(일명 pagefile)이다.

> 페이지(page)란, 일정한 크기로 나뉘어진 운영체제에서 관리하는 가장 작은 단위의 가상 메모리이다. 크기는 호스트 시스템마다 다르며 x86 컴퓨터의 경우에는 4kB이다.

> pagefile 명칭은 가상 메모리의 page가 file을 저장하는 저장장치에서 처리하기 때문에 이 두 용어를 통합한 것으로 보인다; page를 가리키는 file.

메모리 관리의 유연성을 최대화하기 위해, 시스템은 물리 메모리의 페이지에서 저장장치의 페이지파일로(page out) 혹은 그 반대로(page in)도 이동시킬 수 있다. 물리 메모리의 페이지로 옮겨지면 시스템은 이로부터 영향을 받은 프로세스의 페이지 맵을 업데이트 시킨다. 만일 시스템이 물리 메모리를 필요로 한다면 가장 오랫동안 사용되지 않은 물리 메모리 페이지를 페이지파일로 옮긴다. 이러한 시스템에 의한 물리 메모리의 변동은 가상주소공간에서만 동작하는 어플리케이션 관점에서는 알아챌 수 없다.

### Working Set
Working set는 프로세스 가상주소공간 중에서 물리 메모리에 머물고 있는 페이지 집합이다. Working set는 페이지될 수 있는 메모리 할당만을 포함하며, (Address Windowing Extension이나 large page allocation 등의) 페이지 될 수 없는 메모리 할당은 working set에서 제외된다.

프로세스가 working set가 아닌 페이지될 수 있는 메모리를 참조하면 page fault(페이지 부재)가 발생한다. 시스템의 page fault 처리자는 page fault를 해결하려 하며, 성공할 시 해당 페이지는 working set에 추가된다 (AWE 또는 large page allocation 접근은 페이지될 수 있는 메모리가 아니기 때문에 항상 물리 메모리에 있어 page fault 문제가 발생하지 않는다).

Hard page fault(참조하려는 페이지가 저장장치에 있는 경우)는 페이지의 backing store로부터 페이지 내용(페이지파일 혹은 프로세스로 생성된 메모리 맵 파일)을 읽어서만 문제를 해결할 수 있다. Soft page fault(참조하려는 페이지가 메모리 어딘가에 있는 경우)는 backing store를 접근하지 않고서도 해결될 수 있다.

> Backing store("backing" as "back-up"; store = memory)이란, 저장장치 중에서 페이징 혹은 스와핑 시스템이 정보를 저장하는데 사용되는 공간이다.

Soft page fault는 다음과 같은 이유로 발생한다.

* 프로세스에서 참조하려는 페이지가 물리 메모리에 있으나 다른 프로세스의 working set인 경우
* (1) 해당 페이지를 사용하는 모든 프로세스의 working set로부터 제거되었으나 repurpose되지 않아거나 혹은 (2) 메모리 관리자의 prefetch 동작 등으로 페이지가 in transition인 경우
* 프로세스가 할당된 가상 메모리 페이지를 처음으로 참조하는 경우 (aka. demand-zero fault)

페이지는 다음으로 인하여 프로세스의 working set으로부터 제거될 수 있다:

* 프로세스가 `SetProcessWorkingSetSize`, `SetProcessWorkingSetSizeEx` 혹은 `EmptyWorkingSet` 함수 호출로 자신의 working set 페이지를 제거 혹은 비울 수 있다.
* 프로세스가 `VirtualUnlock` 함수 호출로 특정 메모리 범위의 page들을 저장장치 페이지파일로 swap
* 프로세스가 `UnmapViewOfFile` 함수로 파일의 mapped view를 unmap
* 메모리 관리자가 더 많은 메모리를 사용할 수 있도록 working set 크기를 줄일 경우
* 메모리 관리자가 새로운 페이지를 위하여 어쩔 수 없이 페이지를 제거해야 할 경우 (working set가 최대치에 달하던가 하면)

만일 몇몇 프로세스가 페이지를 공유하고 있을 시, 하나의 프로세스의 working set에서 해당 페이지를 제거한다 하더라도 다른 프로세스에는 영향을 미치지 않는다 (아마 제거를 한 프로세스가 참조를 하지 않을 뿐). 허나 모든 프로세스의 working set로부터 제거되면 페이지는 transition page가 된다.

> transition page는 다른 프로세스로부터 참조되거나 메모리 관리자로부터 repurpose(예를 들어 0으로 채운 다음 다른 프로세스에게 전달되는 등)될 때까지 RAM 캐시안에 잔여한다.

만일 transition page가 마지막으로 저장장치에 write된 이후 변경사항이 발생하였을 때 (즉, 페이지가 "dirty" 할 때), 해당 transition page는 repurpose 되기 전에 먼저 backing store에 write되어야 한다. 시스템은 dirty transition page를 발견한 즉시 backing store에 write하도록 한다.

각 프로세스는 프로세스의 가상 메모리 페이징 동작에 영향을 주는 working set의 최소 및 최대 크기가 있다. 특정 프로세스의 현재 working set 크기를 확인하기 위해서는 `GetProcessMemoryInfo` 함수를 호출한다. 최소 및 최대 working set 크기에 대한 함수로는 `GetProcessWorkingSetSizeEx`와 `SetProcessWorkingSetSizeEx`가 있다.

프로세스 상태 어플리케이션 프로그래밍 인터페이스(PSAPI)는 프로세스의 working set와 관련된 자세한 정보를 반환하는 여러 함수들을 제공한다.

## 페이지 상태
프로세스의 가상주소공간에 있는 페이지는 다음 상태 중 하나에 속한다.

* Free
    페이지가 reserved 또는 committed 되지 않은 상태이다. 프로세스는 해당 페이지를 접근할 수 없다. reserved나 committed, 혹은 reserved이면서 committed 상태 페이지로 사용될 수 있다. free 페이지를 read 혹은 write 하려고 하면 access violation 예외처리가 발생한다.

* Reserved
    페이지가 나중에 사용될 것으로 예약된 상태이다. 해당 범위의 reserved 페이지들은 다른 할당 함수로부터 사용될 수 없다. 해당 페이지는 접근될 수 없으며 물리적 저장장치가 관여하지 않는다. 오로지 committed 상태로만 사용될 수 있다.

* Committed
    총 RAM 및 저장장치 페이지파일 크기만큼 할당될 수 있는 메모리이다. 페이지는 접근될 수 있으며, 그리고 접근은 메모리 보호 상수 중 하나로부터 제어된다. 시스템은 각 committed 페이지에 처음으로 read 혹은 write하려고 할 때만 초기화하여 물리 메모리에 로드한다. 프로세스가 terminate되면 시스템은 committed 페이지에 대한 공간을 할당 해제한다.

## 할당된 메모리 범위
프로세스가 메모리 할당 함수(`HeapAlloc`, `VirtualAlloc`, `GlobalAlloc`, 또는 `LocalAlloc`)로 할당한 모든 메모리는 해당 프로세스로부터만이 접근할 수 있다. 하지만 DLL로부터 할당된 메모리는 DLL을 호출한 프로세스의 주소공간 내에 할당되며, 이는 동일한 DLL을 사용하는 프로세스라도 접근할 수가 없다. 만일 공용 메모리를 생성하려면 파일 매핑을 사용해야 한다.

네임드 파일 매핑은 공용 메모리 블록을 만드는 가장 쉬운 방법을 제공한다. 프로세스는 파일 매핑 객체를 생성하기 위해 `CreateFileMapping` 함수를 호출할 때 이름을 지정할 수 있다. 타 프로세스는 `CreateFileMapping` 혹은 `OpenFileMapping` 함수에 이름을 제시하여 매핑 객체의 핸들을 가져올 수 있다.

각 프로세스는 `MapViewOfFile` 함수에 파일 매핑 객체의 핸들을 제시하므로써 view of file을 자신의 주소공간에 매핑할 수 있다. 모든 프로세스에 대한 단일 파일 매핑 객체

(...what the heck is the "view"?)

## 데이터 실행 방지
데이터 실행 방지(Data Execution Prevention; DEP)는 윈도우 XP 및 서버 2003부터 운영체제게 탑재된 시스템-레벨 메모리 보호 기능이다. DEP는 시스템이 하나 이상의 페이지를 실행불가한 메모리로 표시 할 수 있도록 한다. 메모리 영역을 실행불가한 메모리로 marking하는 것은 해당 영역의 메모리에서 코드를 실행할 수 없음을 의미하며, 이는 buffer overrun을 남용을 어렵게 만든다.

DEP는 코드가 기본 heap, stack, 혹은 메모리 pools과 같은 data page에서 코드가 실행되는 것을 방지한다. 어플리케이션이 보호된 데이터 페이지에서 코드를 실행하려고 하면 accession violation이 발생하여 에외처리가 되지 않으면 프로세스는 terminate 된다.

DEP는 모든 남용으로부터 포괄적 방어를 제공하려는 것이 아니다. 당신의 어플리케이션의 안전성은 그 목적을 위해 제작된 도구를 사용해서 안전성을 확보해야 한다.

### DEP 원리
만일 어플리케이션이 보호된 페이지로부터 코드를 실행하려고 할 시, 어플리케이션은 상태 코드 `STATUS_ACCESS_VIOLATION`의 exception을 받는다. 만일 어플리케이션이 반드시 해당 메모리에서 코드를 실행해야 할 시, 적절한 가상 메모리 할당 및  보호 attribute를 설정해주어야 한다. 할당 시에는 `PAGE_EXECUTE`, `PAGE_EXECUTE_READ`, `PAGE_EXECUTE_READWRITE`, 또는 `PAGE_EXECUTE_WRITECOPY`로 되어야 한다.

어플리케이션은 프로세스의 기본 stack 또는 heap에서 코드를 실행할 수 없다: `malloc`과 `HeapAlloc` 함수로 할당된 heap 영역은 코드 실행불가 메모리이다.

DEP는 부팅 설정 데이터에 있는 no-execute page protection policy setting에 의해 시스템 부팅 때 설정된다. 어플리케이션은 현재 정책 설정을 `GetSystemDEPPolicy` 함수로 불러올 수 있다. 정책 설정에 따라 어플리케이션은 현재 프로세스에 대한 DEP 설정을 `SetProcesDEPPolicy` 함수로 변경할 수 있다.

### 프로그래밍 고려사항
어플리케이션은 `VirtualAlloc` 함수로 적절한 메모리 보호 옵션과 함께 실행가능한 메모리를 할당할 수 있다. 어플리케이션을 최소한 `PAGE_EXECUTE` 메모리 보호 옵션으로 설정하기를 제안한다. 실행가능한 코드를 생성한 이후, 어플리케이션에서 할당된 메모리에 write를 불허하도록 메모리 보호를 설정하기를 권장하며, 이는 `VirtualProtect` 함수로 할 수 있다. 이를 통해 코드 실행 메모리 영역을 최대한의 보호를 보장받을 수 있다. 어플리케이션을 만들 때 메모리가 남용될 수 있는 용량을 최소화하기 위해 최소한의 실행가능한 주소공간을 사용하도록 한다.

어플리케이션의 가상 메모리 레이아웃을 제어하여 실행 영역을 만드는 것도 해보도록 한다. 해당 실행 영역은 실행불가 영역보다 하위 메모리 공간에 위치하도록 한다. 그러므로써 비실행영역의 데이터가 실행영역으로 overflow 되는 것을 방지할 수 있다.

### 어플리케이션 호환성
일부 어플리케이션 기능은 DEP와 호환되지 않는다. 이는 동적 코드 생성(예를 들어 JIT 코드 생성)을 하고 명시적으로 생성된 코드에 실행 권한을 표시하지 않으면 DEP를 사용하는 컴퓨터와 호환성 문제가 발생한다. 대다수의 DEP 불가한 수행을 하는 어플리케이션은 제대로 동작하기 위해 업데이트되어야 한다.

소수의 실행 파일 및 라이브러리는 이미지 파일의 데이터 영역에 실행가능한 코드가 들어있을 수 있다. 일부 경우, 어플리케이션은 작은 코드 조각을 데이터 영역에 놓기도 할 수 있다. 하지만 DEP는 실행가능 attribute가 적용되지 않는 이상, 메모리로 로드된 이미지 파일을 실행불가한 영역으로 표시한다.

그러므로 데이터 영역에 있는 실행가능한 코드들은 코드 영역으로 옮겨지거나, 혹은 데이터 영역에 있는 실행가능한 코드는 명시적으로 실행가능하다고 표시되어야 한다.

## 메모리 보호
프로세스가 소유하는 메모리는 private 가상주소공간으로 암묵적으로 보호되어있다. 게다가 Window 운영체제는 가상 메모리 하드웨어를 통해 메모리 보호를 제공하고 있다. 이러한 메모리 보호는 프로세서에 따라 어떻게 사용되는지 다르다: 예를 들어 프로세스 주소공간의 코드 페이지는 읽기전용으로 표시되어 사용자 모드 쓰레드로 인한 변경으로부터 보호받을 수 있다.

### Copy-on-Write 보호
copy-on-write 보호는 프로세스 하나가 페이지를 변경하지 않는 이상, 여러 프로세스가 자신의 가상주소공간을 매핑하여 물리적 페이지를 공유할 수 있도록 하는 최적화이다. 이러한 기술은 일명 lazy evaluation이라 칭하며, 이는 시스템이 물리적 메모리는 물론 (정말로 필요하지 않는 이상 아무런 동작을 수행하지 않아도 되므로써) 시간까지 절약할 수 있도록 한다.

만일 두 프로세스가 하나의 물리 메모리를 공유하고 있다고 가정한다. 프로세스 1이 물리 메모리의 페이지 하나를 변경하였다면, 변경한 내용은 물리 메모리에서 새로운 페이지에 적용되고 가상 메모리 매핑은 업데이트된다. 그러므로 매핑 업데이트가 일어나지 않은 프로세스 2는 프로세스 1이 변경한 내용을 절대 볼 수 없다!

### 어플리케이션 및 DLL 불러오기
윈도우 기반의 어플리케이션의 여러 객체(aka. process(es))가 실행되었을 시, 각 객체는 자신만의 보호된 가상주소공간을 갖는다. 그러나 객체들의 객체 핸들은 일반적으로 동일한 값을 갖는다. 핸들 값은 어플리케이션의 가상주소공간의 base 주소(like the pointer of the beginning of the instance)를 의미한다. 만일 각 객체가 기본 base 주소에 로드될 수 있다면 copy-on-write 보호를 통해 하나의 물리 메모리를 매핑하여 다른 객체들과 공유할 수 있다. 어떠한 이유로 이들 객체 중에서 하나가 base 주소에 로드될 수 없으면, 그 객체는 자신만의 물리 페이지들을 할당 받는다.

DLL을 불러오면 자신만의 기본 base 주소가 있다. 모든 프로세스는 DLL을 불러올 때, DLL을 주소공간을 자신들의 주소공간에서 로드하려고 한다. 만일 여러 어플리케이션이 자신들만의 기본 가상주소에 DLL을 로드할 수 있다면, 하나의 물리 메모리를 통해 DLL 주소공간을 공유할 수 있다. 어떠한 이유로 프로세스가 DLL을 프로세스의 기본 base 주소에 로드할 수 없다면 DLL을 다른 위치에 로드한다. copy-on-write 보호는 이러한 프로세스를 위해 일부 DLL 페이지를 다른 물리 페이지로 강제로 복사시킨다. 이러한 이유는 jump 명령에 대한 수정은 DLL 페이지 내에 write하는데, 이러한 과정이 없으면 해당 프로세스에 대해서만 달라지게 되기 때문이다. 만일 코드 영역이 많은 데이터 영역을 참조한다면, 일부 페이지가 아닌 코드 영역 통째로가 복사될 수 있다.
